{"meta":{"title":"ligangit","subtitle":"时光，不会辜负每一个默默努力的人","description":"在码农的世界里面默默的挣扎着","author":"Li Gang","url":"http://ligangit.com","root":"/"},"pages":[],"posts":[{"title":"RabbitMQ-消息确认机制","slug":"RabbitMQ-消息确认机制","date":"2020-08-22T07:45:49.000Z","updated":"2020-08-22T08:40:59.212Z","comments":true,"path":"2020/08/22/RabbitMQ-消息确认机制/","link":"","permalink":"http://ligangit.com/2020/08/22/RabbitMQ-消息确认机制/","excerpt":"","text":"RabbitMQ-消息确认机制确认并且保证消息被送达，提供了两种方式：发布确认和事务。两者不可同时使用，在channel为事务时，不可引入确认模式，同样channel为确认模式下，不可使用事务。 发布确认有两种方式：消息发送成功确认和消息发送失败回调。 消息发送成功确认在rabbitmq的配置文件spring-rabbitmq.xml添加配置： connectionFactory中启用消息确认： 12345678&lt;!--publisher-confirms=\"true\" 表示：启用了消息确认--&gt;&lt;rabbit:connection-factory id=\"connectionFactory\" host=\"$&#123;spring.rabbitmq.host&#125;\" port=\"$&#123;rabbitmq.port&#125;\" username=\"$&#123;rabbitmq.username&#125;\" password=\"$&#123;rabbitmq.password&#125;\" virtual-host=\"$&#123;rabbitmq.virtual-host&#125;\" publisher-confirms=\"true\"/&gt; 编写消息确认回调方法： 1234567891011121314/** * 消息确认与回退 */public class MsgSendConfirmCallBack implements RabbitTemplate.ConfirmCallback &#123; @Override public void confirm(CorrelationData correlationData, boolean b, String s) &#123; if (b) &#123; System.out.println(\"消息确认成功.....\"); &#125; else &#123; //处理丢失消息 System.out.println(\"消息确认失败，\"+s); &#125; &#125;&#125; 配置消息确认回调方法： 1234567891011121314&lt;!--publisher-confirms=\"true\" 表示：启用了消息确认--&gt;&lt;rabbit:connection-factory id=\"connectionFactory\" host=\"192.168.0.8\" port=\"5672\" username=\"ligangit\" password=\"ligangit\" virtual-host=\"/ligangit\" publisher-confirms=\"true\"/&gt; &lt;!--消息回调处理类--&gt;&lt;bean id=\"confirmCallBack\" class=\"com.ligangit.springboot.config.MsgSendConfirmCallBack\"/&gt;&lt;!--定义rabbitTemplate对象操作，可以在代码中方便发送消息--&gt;&lt;!--confirm-callback=\"confirmCallBack\"表示消息成功回调--&gt;&lt;rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\" confirm-callback=\"confirmCallBack\"/&gt; 测试： 发送消息：spring_queue队列需要手动添加，测试代码中没有 123456789/** * 消息确认测试 */@Testvoid queueTest() &#123; rabbitTemplate.convertAndSend( \"spring_queue\", \"只发队列spring_queue的消息\");&#125; 管理界面确认消息发送成功： 消息确认回调 消息发送失败回调在rabbitmq的配置文件spring-rabbitmq.xml添加配置： connectionFactory中启用消息确认：注意和确认回调参数是不一样的 12345678&lt;!--publisher-returns=\"true\" 表示：启用了失败回调--&gt;&lt;rabbit:connection-factory id=\"connectionFactory\" host=\"192.168.0.8\" port=\"5672\" username=\"ligangit\" password=\"ligangit\" virtual-host=\"/ligangit\" publisher-returns=\"true\"/&gt; 编写消息失败回调方法 12345678910/** * 消息发送失败回调 */public class MsgSendReturnCallBack implements RabbitTemplate.ReturnCallback &#123; @Override public void returnedMessage(Message message, int i, String s, String s1, String s2) &#123; String msgJson = new String(message.getBody()); System.out.println(\"Return Message: \"+msgJson); &#125;&#125; 配置消息失败回调方法 注意：需要配置mandatory=”true” 1234567&lt;!--消息失败回调处理类--&gt;&lt;bean id=\"returnCallBack\" class=\"com.ligangit.springboot.config.MsgSendReturnCallBack\"/&gt;&lt;!--定义rabbitTemplate对象操作，可以在代码中方便发送消息--&gt;&lt;!--confirm-callback=\"confirmCallBack\"表示消息失败回调--&gt;&lt;!--return-callback=\"returnCallBack\"表示消息失败回调，同时配置mandatory=\"true\"，否则消息则丢失--&gt;&lt;rabbit:template id=\"rabbitTemplate\" connection-factory=\"connectionFactory\" confirm-callback=\"confirmCallBack\" return-callback=\"returnCallBack\" mandatory=\"true\"/&gt; 测试 发送消息：test_fail_exchange交换机需要手动添加，测试代码中没有 1234567891011/** * 消息失败回调测试 */@Testvoid testFailQueueTest() &#123; //exchange 正确，queue 错误，confirm被回调，ack=true；return被回调 replyTest:NO_ROUTE rabbitTemplate.convertAndSend( \"test_fail_exchange\", \"\", \"只发队列spring_queue的消息\");&#125; 失败回调结果如下 事务支持","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://ligangit.com/tags/中间件/"}]},{"title":"RabbitMQ-延迟队列","slug":"RabbitMQ-延迟队列","date":"2020-08-22T07:32:55.000Z","updated":"2020-08-22T07:45:20.043Z","comments":true,"path":"2020/08/22/RabbitMQ-延迟队列/","link":"","permalink":"http://ligangit.com/2020/08/22/RabbitMQ-延迟队列/","excerpt":"","text":"RabbitMQ-延迟队列简介延迟队列存储的对象是对应的延迟消息；所谓“延迟消息”是指当消息被发送后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。 在RabbitMQ中延迟队列可以通过 过期时间+死信队列 来实现； 流程具体流程图所示： 在上图中：分别设置了两个5秒、10秒的过期队列，然后等到时间到了则会自动将这些消息转移投递到对应的死信队列中，然后消费者再从这些死信队列接收消息就可以实现消息的延迟接收。 具体过程如过期时间进入死信队列。 应用场景延迟队列的应用场景：如： 在电商项目中的支付场景；如果在用户下单之后的十几分钟内没有支付成功；那么这个支付的订单算是支付失败，要进行支付失败的异常处理（将库存加回去），这时候可以通过使用延迟队列来处理。 在系统中如果需要在指定的某个时间之后执行的任务都可以通过延迟队列处理。","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://ligangit.com/tags/中间件/"}]},{"title":"RabbitMQ-死信队列","slug":"RabbitMQ-死信队列","date":"2020-08-22T06:22:17.000Z","updated":"2020-08-22T07:33:03.755Z","comments":true,"path":"2020/08/22/RabbitMQ-死信队列/","link":"","permalink":"http://ligangit.com/2020/08/22/RabbitMQ-死信队列/","excerpt":"","text":"RabbitMQ-死信队列简介DLX，全称为Dead-Letter-Exchange，可以称之为死信交换机，也有人称为死信邮箱。当消息在一个队列中变成死信（dead message）之后，它能被重新发送到另一个交换机中，这个交换机就是DLX，绑定DLX的队列称之为死信队列。 消息变成死信，可能是由于一下原因： 消息被拒绝 消息过期 队列达到最大长度 DLX也是一个正常的交换机，和一般的交换机没有区别，它能在任何的队列上被指定，实际上就是设置某一个队列的属性。当这个队列中存在死信时，RabbitMQ就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。 要想使用死信队列，只需要在定义队列的时候设置队列参数x-dead-letter-exchange指定交换机即可。 使用方式定义死信交换机在rabbitmq的配置文件spring-rabbitmq.xml添加配置： 123456789&lt;!--定义定向交换机中的持久化死信队列，不存在则自动创建--&gt;&lt;rabbit:queue id=\"my_dlx_queue\" name=\"my_dlx_queue\" auto-declare=\"true\"/&gt;&lt;!--定义广播类型交换机；并绑定上述两个队列--&gt;&lt;rabbit:direct-exchange name=\"my_dlx_exchange\" id=\"my_dlx_exchange\" auto-declare=\"true\"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding key=\"my_ttl_dlx\" queue=\"my_dlx_queue\"&gt;&lt;/rabbit:binding&gt; &lt;rabbit:binding key=\"my_max_dlx\" queue=\"my_dlx_queue\"&gt;&lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt;&lt;/rabbit:direct-exchange&gt; 队列设置死信交换机为了测试消息在过期、队列达到最大长度后都将被投递到死信交换机上；所以添加配置如下： 在rabbitmq的配置文件spring-rabbitmq.xml添加配置： 12345678910111213141516171819202122232425262728293031323334353637&lt;!--定义定向交换机中的持久化死信队列，不存在则自动创建--&gt;&lt;rabbit:queue id=\"my_dlx_queue\" name=\"my_dlx_queue\" auto-declare=\"true\"/&gt;&lt;!--定义广播类型交换机；并绑定上述两个队列--&gt;&lt;rabbit:direct-exchange name=\"my_dlx_exchange\" id=\"my_dlx_exchange\" auto-declare=\"true\"&gt; &lt;rabbit:bindings&gt; &lt;!--绑定路由键my_ttl_dlx、my_max_dlx，可以将过期的消息转移到my_dlx_queue队列--&gt; &lt;rabbit:binding key=\"my_ttl_dlx\" queue=\"my_dlx_queue\"&gt;&lt;/rabbit:binding&gt; &lt;rabbit:binding key=\"my_max_dlx\" queue=\"my_dlx_queue\"&gt;&lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt;&lt;/rabbit:direct-exchange&gt;&lt;!--定义过期队列及属性，不存在则自动创建--&gt;&lt;rabbit:queue id=\"my_ttl_dlx_queue\" name=\"my_ttl_dlx_queue\" auto-declare=\"true\"&gt; &lt;rabbit:queue-arguments&gt; &lt;!--投递到该队列的消息如果没有消费都将在6秒之后被删除--&gt; &lt;entry key=\"x-message-ttl\" value-type=\"long\" value=\"6000\"/&gt; &lt;!--当消息过期后，投递到对应的死信交换机--&gt; &lt;entry key=\"x-dead-letter-exchange\" value=\"my_dlx_exchange\"/&gt; &lt;/rabbit:queue-arguments&gt;&lt;/rabbit:queue&gt;&lt;!--定义限制长度的队列及属性，不存在则自动创建--&gt;&lt;rabbit:queue id=\"my_max_dlx_queue\" name=\"my_max_dlx_queue\" auto-declare=\"true\"&gt; &lt;rabbit:queue-arguments&gt; &lt;!--投递到该队列的消息最多2个消息，如果超过则最早的消息被删除投递到死信交换机--&gt; &lt;entry key=\"x-max-length\" value-type=\"long\" value=\"2\"/&gt; &lt;!--当消息长度超过2个，最早的会投递到对应的死信交换机--&gt; &lt;entry key=\"x-dead-letter-exchange\" value=\"my_dlx_exchange\"/&gt; &lt;/rabbit:queue-arguments&gt;&lt;/rabbit:queue&gt;&lt;rabbit:direct-exchange name=\"my_normal_exchange\" id=\"my_normal_exchange\" auto-declare=\"true\"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding key=\"my_ttl_dlx\" queue=\"my_ttl_dlx_queue\"&gt;&lt;/rabbit:binding&gt; &lt;rabbit:binding key=\"my_max_dlx\" queue=\"my_max_dlx_queue\"&gt;&lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt;&lt;/rabbit:direct-exchange&gt; 消息过期的死信队列测试1234567891011/** * 过期消息投递到死信队列 * 投递到一个正常的队列，但是该队列有设置过期时间，到过期时间之后消息会被投递到死信交换机（队列） */@Testvoid dlxTTLMessageTest() &#123; rabbitTemplate.convertAndSend( \"my_normal_exchange\", \"my_ttl_dlx\", \"测试过期消息：6秒过期后会被投递到死信交换机\");&#125; 测试结果： 未过期时： 过期后： 消息过长的死信队列测试最早的那条会投递到死信队列 123456789101112131415161718/** * 消息长度超过2，会投递到死信队列中 */@Testvoid dlxMaxMessageTest() &#123; rabbitTemplate.convertAndSend( \"my_normal_exchange\", \"my_max_dlx\", \"发送消息1：消息长度超过2，会被投递到死信队列中！\"); rabbitTemplate.convertAndSend( \"my_normal_exchange\", \"my_max_dlx\", \"发送消息2：消息长度超过2，会被投递到死信队列中！\"); rabbitTemplate.convertAndSend( \"my_normal_exchange\", \"my_max_dlx\", \"发送消息3：消息长度超过2，会被投递到死信队列中！\");&#125; 测试结果： 整体： 第一条进入死信队列： 流程","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://ligangit.com/tags/中间件/"}]},{"title":"RabbitMQ-过期时间TTL","slug":"RabbitMQ-过期时间TTL","date":"2020-08-22T05:42:02.000Z","updated":"2020-08-22T06:32:56.321Z","comments":true,"path":"2020/08/22/RabbitMQ-过期时间TTL/","link":"","permalink":"http://ligangit.com/2020/08/22/RabbitMQ-过期时间TTL/","excerpt":"","text":"RabbitMQ-过期时间TTL过期时间TTL表示可以对消息设置预期的时间，在这个时间内都可以被消费这接收获取；过来之后消息将自动被删除。RabbitMQ可以对消息和队列设置TTL。目前有两种方法可以设置。 第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间； 第二种方法是对消息进行单独设置，每条消息TTL可以不同。 如果上述两种方法同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。消息在队列的生存时间一旦超过设置的TTL值，就称为dead message被投递到死信队列，消费者将无法再收到该消息。 设置队列TTL 编写rabbitmq配置文件spring-rabbitmq.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd\"&gt; &lt;!--定义过期队列及属性，不存在则自动创建--&gt; &lt;rabbit:queue id=\"my_ttl_queue\" name=\"my_ttl_queue\" auto-declare=\"true\"&gt; &lt;rabbit:queue-arguments&gt; &lt;!--投递到该队列的消息如果没有消费都将在6秒之后被删除--&gt; &lt;entry key=\"x-message-ttl\" value-type=\"long\" value=\"6000\"/&gt; &lt;/rabbit:queue-arguments&gt; &lt;/rabbit:queue&gt;&lt;/beans&gt; 在启动类导入配置文件 1234@SpringBootApplication//导入配置文件@ImportResource(\"classpath:/spring/spring-rabbitmq.xml\")public class SpringbootRabbitmqProducerApplication &#123; 编写测试类 12345678910111213141516@SpringBootTestclass SpringbootRabbitmqProducerApplicationTests &#123; @Autowired private RabbitTemplate rabbitTemplate; /** * 过期队列消息 * 投递到该队列的消息如果没有消费都将在6秒之后被删除 */ @Test void ttlQueueTest() &#123; //路由键与队列同名 rabbitTemplate.convertAndSend(\"my_ttl_queue\",\"发送消息到过期队列my_ttl_queue，6秒内不消费则不能再被消费\"); &#125;&#125; 结果 设置消息TTL消息的过期时间；只需要在发送消息（可以发送到任何队列，不管该队列是否属于某个交换机）的时候设置过期时间即可。在测试类中编写如下方法发送消息并设置过期时间到队列： 12345678910111213/** * 过期时间 * 该消息投递任何交换机或队列的时候，如果到了过期时间则将从该队列中删除 */@Testvoid ttlMessageTset() &#123; MessageProperties messageProperties = new MessageProperties(); //设置消息的过期时间，5秒 messageProperties.setExpiration(\"5000\"); Message message = new Message(\"测试过期消息，5秒钟过期\".getBytes(),messageProperties); //路由键与队列同名 rabbitTemplate.convertAndSend(\"my_ttl_queue\",message);&#125; expiration字段以微妙为单位表示TTL值。且与x-message-ttl具有相同的约束条件。因为expiration字段必须为字符串类型，broker将只会接受以字符串形式表达的数字。 当同时指定了queue和message的TTL值，则两者中较小的那个才会起作用","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://ligangit.com/tags/中间件/"}]},{"title":"SpringBoot学习-整合RabbitMQ","slug":"SpringBoot学习-整合RabbitMQ","date":"2020-08-22T02:42:47.000Z","updated":"2020-08-22T04:47:33.771Z","comments":true,"path":"2020/08/22/SpringBoot学习-整合RabbitMQ/","link":"","permalink":"http://ligangit.com/2020/08/22/SpringBoot学习-整合RabbitMQ/","excerpt":"","text":"SpringBoot学习-整合RabbitMQ简介在SpringBoot中，只需要引入对应的amqp启动器依赖即可，方便的使用RabbitTemplate发送消息，使用注解接收消息。 一般开发过程中： 生产者工程： application.yml文件配置RabbitMQ相关信息； 在生产者工程中编写配置类，用于创建交换机和队列，并进行绑定； 注入RabbitTemplate对象，通过RabbitTemplate对象发送消息到交换机。 消费者工程： application.yml文件配置RabbitMQ相关信息； 创建消息处理类，用于接收队列中的消息并进行处理。 搭建生产者工程 创建SpringBoot工程 引入依赖 123456789101112&lt;dependencies&gt; &lt;!--引入RabbitMQ依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--使用SpringMVC进行测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写配置文件 12345678#RabbitMQ配置spring: rabbitmq: host: 192.168.0.8 port: 5672 virtual-host: /ligangit username: ligangit password: ligangit 绑定交换机和队列 创建RabbitMQ队列与交换机绑定的配置类RabbitMQConfig 12345678910111213141516171819202122232425262728/** * RabbitMQ配置类 */@Configurationpublic class RabbitMQConfig &#123; //交换机名称 public static final String ITEM_TOPIC_EXCHANGE = \"item_topic_exchange\"; //队列名称 public static final String IMTE_QUEUE = \"item_queue\"; //声明交换机 @Bean(\"itemTopicExchange\") public Exchange topicExchange() &#123; return ExchangeBuilder.topicExchange(ITEM_TOPIC_EXCHANGE).durable(true).build(); &#125; //声明队列 @Bean(\"itemQueue\") public Queue itemQueue() &#123; return QueueBuilder.durable(IMTE_QUEUE).build(); &#125; //绑定队列和交换机 @Bean public Binding itemQueueExchange(@Qualifier(\"itemQueue\") Queue queue, @Qualifier(\"itemTopicExchange\") Exchange exchange) &#123; return BindingBuilder.bind(queue).to(exchange).with(\"item.#\").noargs(); &#125;&#125; 消息发送Controller 12345678910111213141516171819202122232425/** * 发送消息的测试类 */@RestControllerpublic class SendMsgController &#123; //注入RabbitTemplate模板 @Autowired private RabbitTemplate rabbitTemplate; /** * 测试 */ @GetMapping(\"/sendmsg\") public String sendMsg(@RequestParam String msg, @RequestParam String key) &#123; /** * 发送消息 * 参数一：交换机名称 * 参数二：路由key * 参数三：发送的消息 */ rabbitTemplate.convertAndSend(RabbitMQConfig.ITEM_TOPIC_EXCHANGE,key,msg); //返回信息 return \"发送消息成功\"; &#125;&#125; 测试 http://localhost:8888/sendmsg?msg=helloSpringboot&amp;key=item.insert 结果 搭建消费者工程 创建SpringBoot工程 引入依赖 123456789101112&lt;dependencies&gt; &lt;!--引入RabbitMQ依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--使用SpringMVC进行测试--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写配置文件 12345678#RabbitMQ配置spring: rabbitmq: host: 192.168.0.8 port: 5672 virtual-host: /ligangit username: ligangit password: ligangit 编写消息监听处理类 12345678910/** * 消费者监听类 */@Componentpublic class MyListener &#123; @RabbitListener(queues = \"item_queue\") public void msg(String msg) &#123; System.out.println(\"消费者消费消息了：\"+msg); &#125;&#125; 测试 http://localhost:8888/sendmsg?msg=helloSpringbootConsumer&amp;key=item.insert 结果","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/tags/RabbitMQ/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"}]},{"title":"RabbitMQ-工作模式","slug":"RabbitMQ-工作模式","date":"2020-08-21T14:01:19.000Z","updated":"2020-08-22T02:40:18.413Z","comments":true,"path":"2020/08/21/RabbitMQ-工作模式/","link":"","permalink":"http://ligangit.com/2020/08/21/RabbitMQ-工作模式/","excerpt":"","text":"RabbitMQ-工作模式RabbitMQ提供了6中模式：简单模式，工作队列模式，Plublish/Subscribe发布/订阅模式，Routing路由模式，Topics主题模式，RPC远程调用模式（远程调用，不太算MQ；暂不做介绍）。 Exchange 交换机Exchange：一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如传递交给某个特别队列、递交给所有队列、或者将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型： Fanout：广播，将消息交给所有绑定到交换机的队列； Direct：定向，把消息交给符合指定Routing key 的队列； Topic：通配符，把消息交给符合Routing pattern（路由模式）的队列。 简单模式（”Hello World!”） 一个生产者，一个消费者。 具体案例已经在《RabbitMQ学习》中使用。 工作队列模式（Work queues）简介 Work queues与简单模式相比，多了一个或一些消费端，多个消费端共同消费同一个队列中的消息。 应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。 代码示例Work queues与简单模式的代码几乎一样，可以完全复制一个或多个消费者进行多个消费者同时消费消息的测试。 1）工具类： 123456789101112131415161718public class ConnectionUtil &#123; public static Connection getConnection() throws IOException, TimeoutException &#123; //创建连接 ConnectionFactory connectionFactory = new ConnectionFactory(); //主机地址：默认为localhost connectionFactory.setHost(\"192.168.0.8\"); //连接端口 connectionFactory.setPort(5672); //虚拟主机名称：默认为/ connectionFactory.setVirtualHost(\"/ligangit\"); //连接用户名：默认为guest connectionFactory.setUsername(\"ligangit\"); //连接密码：默认为guest connectionFactory.setPassword(\"ligangit\"); //创建连接 return connectionFactory.newConnection(); &#125;&#125; 2）生产者： 1234567891011121314151617181920212223242526272829303132333435public class Producer &#123; static final String QUEUE_NAME = \"work_queue\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); //声明（创建）队列 /** * 参数一：队列名称 * 参数二：是否定义持久化队列 * 参数三：是否独占本次连接 * 参数四：是否在不使用的时候自动删除队列 * 参数五：队列其他参数 */ channel.queueDeclare(QUEUE_NAME, true, false, false, null); for (int i = 1; i &lt;= 30; i++) &#123; //发送消息 String message = \"你好！work模式===\"+i; /** * 参数一：交换机名称，如果没有指定则使用默认Deafult Exchange * 参数二：路由key，简单模式可以传递队列名称 * 参数三：消息其他属性 * 参数四：消息内容 */ channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes()); System.out.println(\"已发送消息：\" + message); &#125; //释放资源 channel.close(); connection.close(); &#125;&#125; 3）消费者1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Consumer1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); //创建队列，并设置消息处理 channel.queueDeclare(Producer.QUEUE_NAME, true, false, false, null); //监听消息 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; /** * consumerTag：消息标签，在 channel.basicConsume 的时候可以指定 * envelope：消息包内容，可从中获取消息id，消息routingkey，交换机，消息和重转标记（收到消息失败后是否需要重新发送） * properties：消息属性 * body：消息 */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"\"); System.out.println(\"=========================消费者1开始=====================================\"); System.out.println(\"\"); //路由key System.out.println(\"路由key为：\"+envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\"+envelope.getExchange()); //消息id System.out.println(\"消息id为：\"+envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者1__接收到的消息：\" + new String(body, \"UTF-8\")); System.out.println(\"\"); System.out.println(\"===============================消费者1结束===============================\"); System.out.println(\"\"); //为了看到效果，让当前线程休眠 try &#123; Thread.sleep(1000);//休眠1秒钟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; /** * 监听消息 * 参数一：队列名称 * 参数二：是否自动确认，设置为true表示消息接收到自动向mq回复接收到了，mq接收到回复消息后会删除消息；设置为false则需要手动确认 */ channel.basicConsume(Producer.QUEUE_NAME,true,consumer); //不关闭资源，应该一直监听消息// channel.close();// connection.close(); &#125;&#125; 4）消费者2： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Consumer2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); //创建队列，并设置消息处理 channel.queueDeclare(Producer.QUEUE_NAME, true, false, false, null); //监听消息 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; /** * consumerTag：消息标签，在 channel.basicConsume 的时候可以指定 * envelope：消息包内容，可从中获取消息id，消息routingkey，交换机，消息和重转标记（收到消息失败后是否需要重新发送） * properties：消息属性 * body：消息 */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"\"); System.out.println(\"=========================消费者2开始=====================================\"); System.out.println(\"\"); //路由key System.out.println(\"路由key为：\"+envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\"+envelope.getExchange()); //消息id System.out.println(\"消息id为：\"+envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者2___接收到的消息：\" + new String(body, \"UTF-8\")); System.out.println(\"\"); System.out.println(\"=========================消费者2结束=====================================\"); System.out.println(\"\"); //为了看到效果，让当前线程休眠 try &#123; Thread.sleep(1000);//休眠1秒钟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; /** * 监听消息 * 参数一：队列名称 * 参数二：是否自动确认，设置为true表示消息接收到自动向mq回复接收到了，mq接收到回复消息后会删除消息；设置为false则需要手动确认 */ channel.basicConsume(Producer.QUEUE_NAME,true,consumer); //不关闭资源，应该一直监听消息// channel.close();// connection.close(); &#125;&#125; 测试结果消费者1结果： 消费者2结果： 小结一个队列如果有多个消费者，那么消费者之间对于同一个消息的关系是竞争的关系。 发布/订阅模式（Plublish/Subscribe）简介简单模式、工作队列模式中，只有3个角色 P：生产者，也就是要发送消息的程序； C：消费者，消息的接收者，会一直等待消息的到来； Queue：消息队列 在发布/订阅模式中，多了一个exchange角色，而且过程略有变化： P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发送给X（交换机）； C：消费者，消息的接收者，会一直等待消息的到来； Queue：消息队列，接收消息、缓存消息； Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如传递交给某个特别队列、递交给所有队列、或者将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型： Fanout：广播，将消息交给所有绑定到交换机的队列； Direct：定向，把消息交给符合指定Routing key 的队列； Topic：通配符，把消息交给符合Routing pattern（路由模式）的队列。 Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失。 发布订阅模式： 每个消费者监听自己的队列； 生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息 代码示例1）工具类： 123456789101112131415161718public class ConnectionUtil &#123; public static Connection getConnection() throws IOException, TimeoutException &#123; //创建连接 ConnectionFactory connectionFactory = new ConnectionFactory(); //主机地址：默认为localhost connectionFactory.setHost(\"192.168.0.8\"); //连接端口 connectionFactory.setPort(5672); //虚拟主机名称：默认为/ connectionFactory.setVirtualHost(\"/ligangit\"); //连接用户名：默认为guest connectionFactory.setUsername(\"ligangit\"); //连接密码：默认为guest connectionFactory.setPassword(\"ligangit\"); //创建连接 return connectionFactory.newConnection(); &#125;&#125; 2）生产者： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 发布/订阅模式使用的交换机类型为：fanout */public class Producer &#123; //交换机名称 static final String FANOUT_EXCHANGE = \"fanout_exchange\"; //队列名称 static final String FANOUT_QUEUE_1 = \"fanout_queue_1\"; //队列名称 static final String FANOUT_QUEUE_2 = \"fanout_queue_2\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); /** * 声明交换机 * 参数一：交换机名称 * 参数二：交换机类型，fanout、topic、direct、headers */ channel.exchangeDeclare(FANOUT_EXCHANGE, BuiltinExchangeType.FANOUT); //声明（创建）队列 /** * 参数一：队列名称 * 参数二：是否定义持久化队列 * 参数三：是否独占本次连接 * 参数四：是否在不使用的时候自动删除队列 * 参数五：队列其他参数 */ channel.queueDeclare(FANOUT_QUEUE_1, true, false, false, null); channel.queueDeclare(FANOUT_QUEUE_2, true, false, false, null); //队列绑定交换机 channel.queueBind(FANOUT_QUEUE_1, FANOUT_EXCHANGE, \"\"); channel.queueBind(FANOUT_QUEUE_2, FANOUT_EXCHANGE, \"\"); for (int i = 1; i &lt;= 10; i++) &#123; //发送消息 String message = \"你好！发布订阅模式===\"+i; /** * 参数一：交换机名称，如果没有指定则使用默认Deafult Exchange * 参数二：路由key，简单模式可以传递队列名称 * 参数三：消息其他属性 * 参数四：消息内容 */ channel.basicPublish(FANOUT_EXCHANGE, \"\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); &#125; //释放资源 channel.close(); connection.close(); &#125;&#125; 3）消费者1： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Consumer1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.FANOUT_EXCHANGE, BuiltinExchangeType.FANOUT); //创建队列，并设置消息处理 channel.queueDeclare(Producer.FANOUT_QUEUE_1, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.FANOUT_QUEUE_1, Producer.FANOUT_EXCHANGE, \"\"); //监听消息 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; /** * consumerTag：消息标签，在 channel.basicConsume 的时候可以指定 * envelope：消息包内容，可从中获取消息id，消息routingkey，交换机，消息和重转标记（收到消息失败后是否需要重新发送） * properties：消息属性 * body：消息 */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"\"); System.out.println(\"=========================消费者1开始=====================================\"); System.out.println(\"\"); //路由key System.out.println(\"路由key为：\"+envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\"+envelope.getExchange()); //消息id System.out.println(\"消息id为：\"+envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者1__接收到的消息：\" + new String(body, \"UTF-8\")); System.out.println(\"\"); System.out.println(\"===============================消费者1结束===============================\"); System.out.println(\"\"); //为了看到效果，让当前线程休眠 try &#123; Thread.sleep(1000);//休眠1秒钟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; /** * 监听消息 * 参数一：队列名称 * 参数二：是否自动确认，设置为true表示消息接收到自动向mq回复接收到了，mq接收到回复消息后会删除消息；设置为false则需要手动确认 */ channel.basicConsume(Producer.FANOUT_QUEUE_1,true,consumer); //不关闭资源，应该一直监听消息// channel.close();// connection.close(); &#125;&#125; 4）消费者2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Consumer2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.FANOUT_EXCHANGE, BuiltinExchangeType.FANOUT); //创建队列，并设置消息处理 channel.queueDeclare(Producer.FANOUT_QUEUE_2, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.FANOUT_QUEUE_2, Producer.FANOUT_EXCHANGE, \"\"); //监听消息 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; /** * consumerTag：消息标签，在 channel.basicConsume 的时候可以指定 * envelope：消息包内容，可从中获取消息id，消息routingkey，交换机，消息和重转标记（收到消息失败后是否需要重新发送） * properties：消息属性 * body：消息 */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"\"); System.out.println(\"=========================消费者2开始=====================================\"); System.out.println(\"\"); //路由key System.out.println(\"路由key为：\"+envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\"+envelope.getExchange()); //消息id System.out.println(\"消息id为：\"+envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者2__接收到的消息：\" + new String(body, \"UTF-8\")); System.out.println(\"\"); System.out.println(\"===============================消费者2结束===============================\"); System.out.println(\"\"); //为了看到效果，让当前线程休眠 try &#123; Thread.sleep(1000);//休眠1秒钟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; /** * 监听消息 * 参数一：队列名称 * 参数二：是否自动确认，设置为true表示消息接收到自动向mq回复接收到了，mq接收到回复消息后会删除消息；设置为false则需要手动确认 */ channel.basicConsume(Producer.FANOUT_QUEUE_2,true,consumer); //不关闭资源，应该一直监听消息// channel.close();// connection.close(); &#125;&#125; 测试结果消费者1： 消费者2： 小结交换机需要与队列进行绑定，绑定之后，一个消息可以被多个消费者都收到。 发布订阅模式与工作队列模式的区别： 工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机； 发布/订阅模式的生产者是向交换机发送消息，工作队列模式的生产者是面向队列发送消息（底层使用默认交换机）； 发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑定到默认的交换机上。 路由模式（Routing）简介路由模式的特点： 队列和交换机绑定，不能是任意绑定了，而是指定一个Routing Key（路由key）； 生产者在向Exchange发送消息时，也必须指定消息的Routing Key； Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routing Key与消息的Routing Key完全一致，才会接收到消息。 P：生产者，向Exchange发送消息，发送消息时，会指定一个Routing Key； X：Exchange（交换机），接收生产者的消息，然后把消息递交给与Routing Key完全匹配的队列； C1：消费者，其所在队列指定了需要Routing Key为error的消息； C2：消费者，其所在队列指定了需要Routing Key为info、error、warning的消息； 路由模式与发布订阅模式的区别： 路由模式中交换机的类型为：Direct，发布订阅模式中交换机类型为Fanout； 路由模式队列绑定交换机的时候，需要指定Routing Key，发布订阅模式不需要。 代码示例1）生产者： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 路由模式使用的交换机类型为：direct */public class Producer &#123; //交换机名称 static final String DIRECT_EXCHANGE = \"direct_exchange\"; //队列名称 static final String DIRECT_QUEUE_INSERT = \"direct_queue_insert\"; //队列名称 static final String DIRECT_QUEUE_UPDATE = \"direct_queue_update\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); /** * 声明交换机 * 参数一：交换机名称 * 参数二：交换机类型，fanout、topic、direct、headers */ channel.exchangeDeclare(DIRECT_EXCHANGE, BuiltinExchangeType.DIRECT); //声明（创建）队列 /** * 参数一：队列名称 * 参数二：是否定义持久化队列 * 参数三：是否独占本次连接 * 参数四：是否在不使用的时候自动删除队列 * 参数五：队列其他参数 */ channel.queueDeclare(DIRECT_QUEUE_INSERT, true, false, false, null); channel.queueDeclare(DIRECT_QUEUE_UPDATE, true, false, false, null); //队列绑定交换机 /** * 参数一：队列名称 * 参数二：队列需要绑定的交换机名称 * 参数三：路由key */ channel.queueBind(DIRECT_QUEUE_INSERT, DIRECT_EXCHANGE, \"insert\"); channel.queueBind(DIRECT_QUEUE_UPDATE, DIRECT_EXCHANGE, \"update\"); //发送消息 String message = \"你好！路由模式===新增了商品。routing key 为 insert\"; /** * 参数一：交换机名称，如果没有指定则使用默认Deafult Exchange * 参数二：路由key，简单模式可以传递队列名称 * 参数三：消息其他属性 * 参数四：消息内容 */ channel.basicPublish(DIRECT_EXCHANGE, \"insert\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); //发送消息 message = \"你好！路由模式===修改了商品。routing key 为 update\"; /** * 参数一：交换机名称，如果没有指定则使用默认Deafult Exchange * 参数二：路由key，简单模式可以传递队列名称 * 参数三：消息其他属性 * 参数四：消息内容 */ channel.basicPublish(DIRECT_EXCHANGE, \"update\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); //释放资源 channel.close(); connection.close(); &#125;&#125; 2）消费者1： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Consumer1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.DIRECT_EXCHANGE, BuiltinExchangeType.DIRECT); //创建队列，并设置消息处理 channel.queueDeclare(Producer.DIRECT_QUEUE_INSERT, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.DIRECT_QUEUE_INSERT, Producer.DIRECT_EXCHANGE, \"insert\"); //监听消息 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; /** * consumerTag：消息标签，在 channel.basicConsume 的时候可以指定 * envelope：消息包内容，可从中获取消息id，消息routingkey，交换机，消息和重转标记（收到消息失败后是否需要重新发送） * properties：消息属性 * body：消息 */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"\"); System.out.println(\"=========================消费者1开始=====================================\"); System.out.println(\"\"); //路由key System.out.println(\"路由key为：\"+envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\"+envelope.getExchange()); //消息id System.out.println(\"消息id为：\"+envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者1__接收到的消息：\" + new String(body, \"UTF-8\")); System.out.println(\"\"); System.out.println(\"===============================消费者1结束===============================\"); System.out.println(\"\"); //为了看到效果，让当前线程休眠 try &#123; Thread.sleep(1000);//休眠1秒钟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; /** * 监听消息 * 参数一：队列名称 * 参数二：是否自动确认，设置为true表示消息接收到自动向mq回复接收到了，mq接收到回复消息后会删除消息；设置为false则需要手动确认 */ channel.basicConsume(Producer.DIRECT_QUEUE_INSERT,true,consumer); //不关闭资源，应该一直监听消息// channel.close();// connection.close(); &#125;&#125; 3）消费者2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Consumer2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.DIRECT_EXCHANGE, BuiltinExchangeType.DIRECT); //创建队列，并设置消息处理 channel.queueDeclare(Producer.DIRECT_QUEUE_UPDATE, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.DIRECT_QUEUE_UPDATE, Producer.DIRECT_EXCHANGE, \"update\"); //监听消息 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; /** * consumerTag：消息标签，在 channel.basicConsume 的时候可以指定 * envelope：消息包内容，可从中获取消息id，消息routingkey，交换机，消息和重转标记（收到消息失败后是否需要重新发送） * properties：消息属性 * body：消息 */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"\"); System.out.println(\"=========================消费者2开始=====================================\"); System.out.println(\"\"); //路由key System.out.println(\"路由key为：\"+envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\"+envelope.getExchange()); //消息id System.out.println(\"消息id为：\"+envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者2__接收到的消息：\" + new String(body, \"UTF-8\")); System.out.println(\"\"); System.out.println(\"===============================消费者2结束===============================\"); System.out.println(\"\"); //为了看到效果，让当前线程休眠 try &#123; Thread.sleep(1000);//休眠1秒钟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; /** * 监听消息 * 参数一：队列名称 * 参数二：是否自动确认，设置为true表示消息接收到自动向mq回复接收到了，mq接收到回复消息后会删除消息；设置为false则需要手动确认 */ channel.basicConsume(Producer.DIRECT_QUEUE_UPDATE,true,consumer); //不关闭资源，应该一直监听消息// channel.close();// connection.close(); &#125;&#125; 测试结果消费者1： 消费者2： 小结路由模式要求队列在绑定交换机的时候需要指定Routing Key，消息会转发到符合Routing Key的队列。 主题模式（Topics）简介Exchange的Topic类型和Direct相比，都是可以根据Routing Key把消息路由到不同的队列，只不过Topic类型Exchange可以让队列在绑定Routing Key的时候使用通配符！ Routing Key一般都是由一个或多个单词组成，多个单词之间以“.”分隔，例如：item.insert。 通配符规则： #：匹配一个或多个词； *：只匹配一个词。 举例： item.#：能够匹配 item.insert.abc 或者 item.insert； item.*：只能匹配item.insert。 图解： 红色Queue：绑定的是usa.#，因此凡是以usa.开头的routing key都会被匹配到； 黄色Queue：绑定的是#.news，因此凡是以.news结尾的routing key都会被匹配。 代码示例1）生产者： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 主题模式(通配符topics)使用的交换机类型为：topic */public class Producer &#123; //交换机名称 static final String TOPIC_EXCHANGE = \"topic_exchange\"; //队列名称 static final String TOPIC_QUEUE_1 = \"topic_queue_1\"; //队列名称 static final String TOPIC_QUEUE_2 = \"topic_queue_2\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); /** * 声明交换机 * 参数一：交换机名称 * 参数二：交换机类型，fanout、topic、direct、headers */ channel.exchangeDeclare(TOPIC_EXCHANGE, BuiltinExchangeType.TOPIC); //声明（创建）队列 /** * 参数一：队列名称 * 参数二：是否定义持久化队列 * 参数三：是否独占本次连接 * 参数四：是否在不使用的时候自动删除队列 * 参数五：队列其他参数 */ channel.queueDeclare(TOPIC_QUEUE_1, true, false, false, null); channel.queueDeclare(TOPIC_QUEUE_2, true, false, false, null); //队列绑定交换机 /** * 参数一：队列名称 * 参数二：队列需要绑定的交换机名称 * 参数三：路由key */ channel.queueBind(TOPIC_QUEUE_1, TOPIC_EXCHANGE, \"item.#\"); channel.queueBind(TOPIC_QUEUE_2, TOPIC_EXCHANGE, \"*.delete\"); //发送消息 String message = \"你好！Topics模式===新增了商品。routing key 为 item.insert\"; /** * 参数一：交换机名称，如果没有指定则使用默认Deafult Exchange * 参数二：路由key，简单模式可以传递队列名称 * 参数三：消息其他属性 * 参数四：消息内容 */ channel.basicPublish(TOPIC_EXCHANGE, \"item.insert\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); //发送消息 message = \"你好！Topics模式===修改了商品。routing key 为 item.update\"; channel.basicPublish(TOPIC_EXCHANGE, \"item.update\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); //发送消息 message = \"你好！Topics模式===删除了商品。routing key 为 product.delete\"; channel.basicPublish(TOPIC_EXCHANGE, \"product.delete\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); //发送消息 message = \"其他信息发送过来了。。。。。。。routing key 为 item.delete.abc\"; channel.basicPublish(TOPIC_EXCHANGE, \"item.delete.abc\", null, message.getBytes()); System.out.println(\"已发送消息：\" + message); //释放资源 channel.close(); connection.close(); &#125;&#125; 2）消费者1： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Consumer1 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.TOPIC_EXCHANGE, BuiltinExchangeType.TOPIC); //创建队列，并设置消息处理 channel.queueDeclare(Producer.TOPIC_QUEUE_1, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.TOPIC_QUEUE_1, Producer.TOPIC_EXCHANGE, \"item.#\"); //监听消息 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; /** * consumerTag：消息标签，在 channel.basicConsume 的时候可以指定 * envelope：消息包内容，可从中获取消息id，消息routingkey，交换机，消息和重转标记（收到消息失败后是否需要重新发送） * properties：消息属性 * body：消息 */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"\"); System.out.println(\"=========================消费者1开始=====================================\"); System.out.println(\"\"); //路由key System.out.println(\"路由key为：\"+envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\"+envelope.getExchange()); //消息id System.out.println(\"消息id为：\"+envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者1__接收到的消息：\" + new String(body, \"UTF-8\")); System.out.println(\"\"); System.out.println(\"===============================消费者1结束===============================\"); System.out.println(\"\"); //为了看到效果，让当前线程休眠 try &#123; Thread.sleep(1000);//休眠1秒钟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; /** * 监听消息 * 参数一：队列名称 * 参数二：是否自动确认，设置为true表示消息接收到自动向mq回复接收到了，mq接收到回复消息后会删除消息；设置为false则需要手动确认 */ channel.basicConsume(Producer.TOPIC_QUEUE_1,true,consumer); //不关闭资源，应该一直监听消息// channel.close();// connection.close(); &#125;&#125; 3）消费者2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Consumer2 &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 Connection connection = ConnectionUtil.getConnection(); //创建频道 Channel channel = connection.createChannel(); //声明交换机 channel.exchangeDeclare(Producer.TOPIC_EXCHANGE, BuiltinExchangeType.TOPIC); //创建队列，并设置消息处理 channel.queueDeclare(Producer.TOPIC_QUEUE_2, true, false, false, null); //队列绑定交换机 channel.queueBind(Producer.TOPIC_QUEUE_2, Producer.TOPIC_EXCHANGE, \"*.delete\"); //监听消息 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; /** * consumerTag：消息标签，在 channel.basicConsume 的时候可以指定 * envelope：消息包内容，可从中获取消息id，消息routingkey，交换机，消息和重转标记（收到消息失败后是否需要重新发送） * properties：消息属性 * body：消息 */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; System.out.println(\"\"); System.out.println(\"=========================消费者2开始=====================================\"); System.out.println(\"\"); //路由key System.out.println(\"路由key为：\"+envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\"+envelope.getExchange()); //消息id System.out.println(\"消息id为：\"+envelope.getDeliveryTag()); //收到的消息 System.out.println(\"消费者2__接收到的消息：\" + new String(body, \"UTF-8\")); System.out.println(\"\"); System.out.println(\"===============================消费者2结束===============================\"); System.out.println(\"\"); //为了看到效果，让当前线程休眠 try &#123; Thread.sleep(1000);//休眠1秒钟 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; /** * 监听消息 * 参数一：队列名称 * 参数二：是否自动确认，设置为true表示消息接收到自动向mq回复接收到了，mq接收到回复消息后会删除消息；设置为false则需要手动确认 */ channel.basicConsume(Producer.TOPIC_QUEUE_2,true,consumer); //不关闭资源，应该一直监听消息// channel.close();// connection.close(); &#125;&#125; 测试结果消费者1： 消费者2： 小结Topics主题模式可以实现发布订阅模式和路由模式的功能，只是Topics在配置Routing Key的时候可以使用通配符，显得更加灵活。 远程调用模式（RPC） 当客户端启动的时候，创建一个匿名的独享的回调队列。 在RPC请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 reply_to 属性，另一个是设置唯一值的 correlation_id 属性。 该请求被发送到rpc_queue队列。 RPC工作者（又名：服务器）等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给reply_to字段指定的队列。 客户端等待回调队列里的数据。当有消息出现的时候，它会检查correlation_id属性。如果此属性的值与请求匹配，将它返回给应用。 模式总结RabbitMQ工作模式： 简单模式 HelloWorld 一个生产者，一个消费者，不需要设置交换机（使用默认交换机）； 工作队列模式 Work Queue 一个生产者，多个消费者（竞争关系），不需要设置交换机（使用默认交换机）； 发布订阅模式 Plublish/Subscribe 需要设置类型为fanout的交换机，并且交换机和队列进行绑定，当消息到交换机后，交换机会将消息发送到绑定的队列； 路由模式 Routing 需要设置类型为direct的交换机，交换机与队列进行绑定，并且指定Routing Key，当发送消息到交换机后，交换机会根据Routing Key将消息发送到对应的队列； 主题模式 Topics 需要设置类型为topic的交换机，交换机与队列进行绑定，并且指定通配符方式的Routing Key，当发送消息到交换机后，交换机会根据Routing Key将消息发送到对应的队列；","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://ligangit.com/tags/中间件/"}]},{"title":"RabbitMQ学习","slug":"RabbitMQ学习","date":"2020-08-21T09:48:48.000Z","updated":"2020-08-22T02:40:11.333Z","comments":true,"path":"2020/08/21/RabbitMQ学习/","link":"","permalink":"http://ligangit.com/2020/08/21/RabbitMQ学习/","excerpt":"","text":"RabbitMQ学习消息队列MQ全称为Message Queue，消息队列应用程序和应用程序之间的通信方法。 为什么使用MQ在项目中，可将一些无需即时返回且耗时的操作提取出来，进行异步处理，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而提高了系统的吞吐量。 应用场景 任务异步处理 将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理，提高了应用程序的响应时间。 应用程序解耦合 MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合 削峰填谷 AMQP和JMSMQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。 AMQPAMQP（Advanced Message Queue 高级消息队列协议）是一种协议，更准确的说是一种链接协议。这是和JMS的本职差别，AMQP不是API层进行限定，而是直接定义网络交换的数据格式。 JMSJMS即Java消息服务（JavaMessage Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于两个应用程序之间，或分布式系统中发送消息，进行异步通信。 AMQP和JMS的区别 JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式； JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的； JMS规定了两种消费模式；而AMQP的消息模式更加丰富。 消息队列产品 ActiveMQ：基于JMS； ZeroMQ：基于C语言开发 RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好 RocketMQ：基于JMS，阿里巴巴产品 Kafka：类似MQ产品；分布式消息系统，高吞吐量 RabbitMQRabbitMQ，是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。 RabbitMQ提供了6中模式：简单模式，工作队列模式，Plublish/Subscribe发布/订阅模式，Routing路由模式，Topics主题模式，RPC远程调用模式（远程调用，不太算MQ；暂不做介绍）。 RabbitMQ运转流程(以简单模式为例)生产者发送消息 生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker（服务节点）； 声明队列并设置属性；如是否排它，是否持久化，是否自动删除； 将路由键（空字符串）与队列绑定起来； 发送消息值RabbitMQ Broker； 关闭信道 关闭连接 代码： 生产者： 123456789101112131415161718192021222324252627282930313233343536373839public class Producer &#123; static final String QUEUE_NAME = \"simple_queue\"; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 ConnectionFactory connectionFactory = new ConnectionFactory(); //主机地址：默认为localhost connectionFactory.setHost(\"192.168.0.8\"); //连接端口 connectionFactory.setPort(5672); //虚拟主机名称：默认为/ connectionFactory.setVirtualHost(\"/ligangit\"); //连接用户名：默认为guest connectionFactory.setUsername(\"ligangit\"); //连接密码：默认为guest connectionFactory.setPassword(\"ligangit\"); //创建连接 Connection connection = connectionFactory.newConnection(); //创建频道 Channel channel = connection.createChannel(); //声明（创建）队列 /** * 参数一：队列名称 * 参数二：是否定义持久化队列 * 参数三：是否独占本次连接 * 参数四：是否在不使用的时候自动删除队列 * 参数五：队列其他参数 */ channel.queueDeclare(QUEUE_NAME, true, false, false, null); //要发送的消息 String message = \"世界，你好！\"; channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes()); System.out.println(\"已发送消息：\" + message); //释放资源 channel.close(); connection.close(); &#125;&#125; 生产者流转过程说明 消费者接收消息 消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker； 向RabbitMQ Broker请求消费相应队列中的消息，设置相应的回调函数； 等待RabbitMQ Broker回应关闭投递响应队列中的消息，消费者接收消息； 确认（ack，自动确认）接收到的消息； RabbitMQ 从队列中删除相应已经被确认的消息； 关闭信道 关闭连接 代码： 消费者： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Consumer &#123; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建连接 ConnectionFactory connectionFactory = new ConnectionFactory(); //主机地址：默认为localhost connectionFactory.setHost(\"192.168.0.8\"); //连接端口 connectionFactory.setPort(5672); //虚拟主机名称：默认为/ connectionFactory.setVirtualHost(\"/ligangit\"); //连接用户名：默认为guest connectionFactory.setUsername(\"ligangit\"); //连接密码：默认为guest connectionFactory.setPassword(\"ligangit\"); //创建连接 Connection connection = connectionFactory.newConnection(); //创建频道 Channel channel = connection.createChannel(); //创建队列，并设置消息处理 channel.queueDeclare(Producer.QUEUE_NAME, true, false, false, null); //监听消息 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; /** * consumerTag：消息标签，在 channel.basicConsume 的时候可以指定 * envelope：消息包内容，可从中获取消息id，消息routingkey，交换机，消息和重转标记（收到消息失败后是否需要重新发送） * properties：消息属性 * body：消息 */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //路由key System.out.println(\"路由key为：\"+envelope.getRoutingKey()); //交换机 System.out.println(\"交换机为：\"+envelope.getExchange()); //消息id System.out.println(\"消息id为：\"+envelope.getDeliveryTag()); //收到的消息 System.out.println(\"接收到的消息：\" + new String(body, \"UTF-8\")); System.out.println(\"\"); System.out.println(\"==============================================================\"); System.out.println(\"\"); &#125; &#125;; /** * 监听消息 * 参数一：队列名称 * 参数二：是否自动确认，设置为true表示消息接收到自动向mq回复接收到了，mq接收到回复消息后会删除消息；设置为false则需要手动确认 */ channel.basicConsume(Producer.QUEUE_NAME,true,consumer); //不关闭资源，应该一直监听消息// channel.close();// connection.close(); &#125;&#125; 消费者流转说明","categories":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/categories/RabbitMQ/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://ligangit.com/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","permalink":"http://ligangit.com/tags/中间件/"}]},{"title":"List集合排序","slug":"List集合排序","date":"2020-08-17T12:08:49.000Z","updated":"2020-08-17T13:53:10.197Z","comments":true,"path":"2020/08/17/List集合排序/","link":"","permalink":"http://ligangit.com/2020/08/17/List集合排序/","excerpt":"","text":"List集合排序直接使用Collections中的方法（主要是单属性）如对String、Integer类型等非引用类型排序。List&lt;String&gt;集合 升序 Collections.sort(list)1234567891011121314public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"abc\"); list.add(\"ecd\"); list.add(\"aaa\"); list.add(\"bef\"); list.add(\"cmc\"); list.add(\"cab\"); Collections.sort(list); //升序排序 for (String s : list) &#123; System.out.println(s); &#125;&#125; 降序 Collections.reverse(list)123456789101112131415161718public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"abc\"); list.add(\"ecd\"); list.add(\"aaa\"); list.add(\"bef\"); list.add(\"cmc\"); list.add(\"cab\"); Collections.sort(list); //升序排序 for (String s : list) &#123; System.out.println(s); &#125; Collections.reverse(list); //降序排序 for (String s : list) &#123; System.out.println(s); &#125;&#125; 结果 自定义排序规则（主要用于对象的排序）如根据用户的年龄排序，对List&lt;User&gt;集合进行排序 如果需要降序，值需要改变规则即可，但是使用的还是Collections.sort()方法 方式一：实现Comparator接口测试的list中Collections.sort()方法 Collections.sort(userList, new Comparator() {}) 12345678910111213141516171819202122232425public static void main(String[] args) &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(19,\"hello\")); userList.add(new User(40,\"hello2\")); userList.add(new User(20,\"hello3\")); userList.add(new User(11,\"hello4\")); userList.add(new User(19,\"hello5\")); userList.add(new User(30,\"hello6\")); Collections.sort(userList, new Comparator&lt;User&gt;() &#123; @Override public int compare(User o1, User o2) &#123; if (o1.getAge() &gt; o2.getAge()) &#123; return 1; &#125;else if (o1.getAge() &lt; o2.getAge())&#123; return -1; &#125;else &#123; return 0; &#125; &#125; &#125;); for (User user : userList) &#123; System.out.println(user); &#125;&#125; User对象只是JavaBean 12345678910111213141516171819202122232425262728293031323334class User &#123; int age; String name; public User(int age, String name) &#123; this.age = age; this.name = name; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"age=\" + age + \", name='\" + name + '\\'' + '&#125;'; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 结果： 方式二：实现Comparable接口测试数据正常排序 1234567891011121314public static void main(String[] args) &#123; List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(19,\"hello\")); userList.add(new User(40,\"hello2\")); userList.add(new User(20,\"hello3\")); userList.add(new User(11,\"hello4\")); userList.add(new User(19,\"hello5\")); userList.add(new User(30,\"hello6\")); Collections.sort(userList); for (User user : userList) &#123; System.out.println(user); &#125;&#125; User对象实现Comparable接口： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class User implements Comparable&lt;User&gt;&#123; int age; String name; public User(int age, String name) &#123; this.age = age; this.name = name; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"age=\" + age + \", name='\" + name + '\\'' + '&#125;'; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public int compareTo(User o) &#123; if (o.age &gt; age) &#123; return -1; &#125; else if (o.age &lt; age) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125; 结果：","categories":[{"name":"java","slug":"java","permalink":"http://ligangit.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"}]},{"title":"SpringBoot学习-缓存","slug":"SpringBoot学习-缓存","date":"2020-08-12T08:25:45.000Z","updated":"2020-08-12T11:00:40.835Z","comments":true,"path":"2020/08/12/SpringBoot学习-缓存/","link":"","permalink":"http://ligangit.com/2020/08/12/SpringBoot学习-缓存/","excerpt":"","text":"SpringBoot学习-缓存概念&amp;注解 名称 解释 Cache 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（cache）组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其进行缓存 @CacheEvict 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存。 与@Cacheable区别在于是否每次都调用方法，常用于更新 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 @CacheConfig 统一配置本类的缓存注解的属性 @Cacheable/@CachePut/@CacheEvict 主要的参数 名称 解释 value 缓存的名称，在 spring 配置文件中定义，必须指定至少一个 例如： @Cacheable(value=”mycache”) 或者 @Cacheable(value={”cache1”,”cache2”} key 缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写， 如果不指定，则缺省按照方法的所有参数进行组合 例如： @Cacheable(value=”testcache”,key=”#id”) condition 缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false， 只有为 true 才进行缓存/清除缓存 例如：@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”) unless 否定缓存。当条件结果为TRUE时，就不会缓存。 @Cacheable(value=”testcache”,unless=”#userName.length()&gt;2”) allEntries (@CacheEvict ) 是否清空所有缓存内容，缺省为 false，如果指定为 true， 则方法调用后将立即清空所有缓存 例如： @CachEvict(value=”testcache”,allEntries=true) beforeInvocation (@CacheEvict) 是否在方法执行前就清空，缺省为 false，如果指定为 true， 则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法 执行抛出异常，则不会清空缓存 例如： @CachEvict(value=”testcache”，beforeInvocation=true) SpEL上下文数据Spring Cache提供了一些供我们使用的SpEL上下文数据，下表直接摘自Spring官方文档： 名称 位置 描述 示例 methodName root对象 当前被调用的方法名 #root.methodname method root对象 当前被调用的方法 #root.method.name target root对象 当前被调用的目标对象实例 #root.target targetClass root对象 当前被调用的目标对象的类 #root.targetClass args root对象 当前被调用的方法的参数列表 #root.args[0] caches root对象 当前方法调用使用的缓存列表 #root.caches[0].name Argument Name 执行上下文 当前被调用的方法的参数，如findArtisan(Artisan artisan),可以通过#artsian.id获得参数 #artsian.id result 执行上下文 方法执行后的返回值（仅当方法执行后的判断有效，如 unless cacheEvict的beforeInvocation=false） #result 注意： 1.当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。 如 1@Cacheable(key = \"targetClass + methodName +#p0\") 2.使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。 如： 12@Cacheable(value=\"users\", key=\"#id\")@Cacheable(value=\"users\", key=\"#p0\") SpEL提供了多种运算符 类型 运算符 关系 &lt;，&gt;，&lt;=，&gt;=，==，!=，lt，gt，le，ge，eq，ne 算术 +，- ，* ，/，%，^ 逻辑 &amp;&amp;，||，!，and，or，not，between，instanceof 条件 ?: (ternary)，?: (elvis) 正则表达式 matches 其他类型 ?.，?[…]，![…]，^[…]，$[…] 使用缓存1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 2.在启动类开启缓存123456789@SpringBootApplication@EnableCaching//开启缓存public class SpringbootWebDataApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootWebDataApplication.class, args); &#125;&#125; 3.缓存@Cacheable @Cacheable注解会先查询是否已经有缓存，有会使用缓存，没有则会执行方法并缓存。 123456789101112131415161718192021/** * 将方法的运行结果进行缓存；以后再要相同的数据，直接从缓存中取，不再调用方法 * * CacheManager管理多个cache组件的，对缓存的进行真正CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字 * 几个属性： * cacheNames/value：指定缓存的名字 * key：缓存数据使用的key，可以用它来指定。默认使用方法参数的值 如 1-方法的返回值 * 编写SpEL，#id；参数id的值，等同于#a0、#p0、#root.args[0] * keyGenerator：key的生成器，可以自己指定key的生成器的组件id，key和keyGenerator二选一使用 * cacheManager：指定缓存管理器, cacheManager和cacheResolver二选一使用 * cacheResolver：指定缓存解析器， cacheManager和cacheResolver二选一使用 * condition：指定符合条件的情况下才缓存； * unless：否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断,如unless = \"#result == null\" * sync：是否使用异步模式 */@Cacheable(cacheNames = \"emp\",condition = \"#id&gt;0\",unless = \"#result == null\")public Employee gerEmpById(Integer id)&#123; System.out.println(\"查询\"+id+\"号员工\"); Employee employee = employeeMapper.gerEmpById(id); return employee;&#125;;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"}]},{"title":"SpringBoot学习-druid配置","slug":"SpringBoot学习-druid配置","date":"2020-08-07T03:01:14.000Z","updated":"2020-08-07T05:54:30.407Z","comments":true,"path":"2020/08/07/SpringBoot学习-druid配置/","link":"","permalink":"http://ligangit.com/2020/08/07/SpringBoot学习-druid配置/","excerpt":"","text":"SpringBoot学习-druid配置导入数据源12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.23&lt;/version&gt;&lt;/dependency&gt; 编写配置信息12345678910111213141516171819202122232425spring: datasource:# 数据源基本配置 username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/ssm_crud type: com.alibaba.druid.pool.DruidDataSource# 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 应用配置信息1234567891011121314151617181920212223242526272829303132333435@Configurationpublic class DruidConfig &#123; //让datasource属性配置生效 @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; //配置Druid的监控 //1、配置一个管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet() &#123; ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\", \"admin\"); initParams.put(\"loginPassword\", \"123456\"); initParams.put(\"allow\", \"\");//默认允许所有访问 initParams.put(\"deny\", \"192.168.1.11\"); servletRegistrationBean.setInitParameters(initParams); return servletRegistrationBean; &#125; //2、配置一个监控的filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new WebStatFilter()); Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\", \"*.js,*.css,/druid/*\"); filterRegistrationBean.setInitParameters(initParams); filterRegistrationBean.setUrlPatterns(Arrays.asList(\"/*\")); return filterRegistrationBean; &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"}]},{"title":"SpringBoot学习-JSP支持、War包","slug":"SpringBoot学习-JSP支持、War包","date":"2020-07-30T14:50:21.000Z","updated":"2020-08-07T05:54:25.020Z","comments":true,"path":"2020/07/30/SpringBoot学习-JSP支持、War包/","link":"","permalink":"http://ligangit.com/2020/07/30/SpringBoot学习-JSP支持、War包/","excerpt":"","text":"SpringBoot学习-JSP支持、War包说明SpringBoot通过外置Servlet容器到达对jsp的支持、war包部署 外置Servlet容器（jsp支持）外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构）（快捷创建时2、3步会自动配置好） 创建一个SpringBoot项目 ​ 选择打包方式为war包 ​ 其他步骤照常 创建成功后的目录结构 ​ 创建webapp目录（也可以将webapp目录改为其他名字） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、配置tomcat服务器 5）、启动服务器就可以使用； 测试JSP支持测试1）、编写JSP页面（注意路径，必须在webapp目录（或者之前创建项目时自己改的）下） 2）、JSP页面访问： http://localhost:8181/springboot_web2_war_exploded/pages/success.jsp 配置测试1）、控制层 12345678@Controllerpublic class HelloController &#123; @RequestMapping(\"/abc\") public String hello(Model model) &#123; model.addAttribute(\"msg\", \"你好\"); return \"success\"; &#125;&#125; 2）、配置文件application.properties设置 12spring.mvc.view.prefix=/pages/spring.mvc.view.suffix=.jsp 3）、请求访问： http://localhost:8181/springboot_web2_war_exploded/abc 使用外置Servlet容器后打war包部署打包静态资源在pom.xml文件的build中添加如下代码，将webapp添加到静态资源文件夹META-INF/resources下，将webapp中的内容打进war包，防止静态资源丢失 1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 添加这个就可以是webapp目录生效 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;!--注意此次必须要放在此目录下才能被访问到 --&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 测试请求访问： http://localhost:8181/springboot_web2-0.0.1-SNAPSHOT/abc","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"}]},{"title":"SpringBoot学习-servlet三大组件（Servlet、Filter、Listener）","slug":"SpringBoot学习-servlet三大组件（Servlet、Filter、Listener）","date":"2020-07-30T07:14:40.000Z","updated":"2020-07-30T09:51:15.229Z","comments":true,"path":"2020/07/30/SpringBoot学习-servlet三大组件（Servlet、Filter、Listener）/","link":"","permalink":"http://ligangit.com/2020/07/30/SpringBoot学习-servlet三大组件（Servlet、Filter、Listener）/","excerpt":"","text":"SpringBoot学习-servlet三大组件（Servlet、Filter、Listener）由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。 注册三大组件用以下方式： 注册Servlet：ServletRegistrationBean 自定义servlet 12345678910111213public class MyServlet extends HttpServlet &#123; //处理get请求 @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;// super.doGet(req, resp); resp.getWriter().write(\"Hello MyServlet\"); &#125; //处理post请求 @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); &#125;&#125; 注册Servlet 123456//注册Servlet@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(), \"/myServlet\"); return registrationBean;&#125; 注册Filter：FilterRegistrationBean 自定义Filter 1234567891011121314151617public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(\"MyFilter process...\"); filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 注册Filter 12345678//注册Filter@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(); filterRegistrationBean.setFilter(new MyFilter()); filterRegistrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return filterRegistrationBean;&#125; 注册Listener：ListenerRegistrationBean 自定义Listener 1234567891011public class MyListener implements ServletContextListener &#123; @Override public void contextInitialized(ServletContextEvent sce) &#123; System.out.println(\"contextInitialized........web应用启动\"); &#125; @Override public void contextDestroyed(ServletContextEvent sce) &#123; System.out.println(\"contextDestroyed.......当前web项目销毁\"); &#125;&#125; 注册Listener 123456//注册Listener@Beanpublic ServletListenerRegistrationBean&lt;MyListener&gt; myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; listenerRegistrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return listenerRegistrationBean;&#125; 原理SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器 DIspatcherServlet； DispatcherServletAutoConfiguration中： 默认拦截：/包括静态资源，但是不拦截jsp请求； /*会拦截jsp 可以通过spring.mvc.servlet.path来修改SpringMVC前端控制器默认拦截的请求路径 12345678910111213141516 @Bean( name = &#123;\"dispatcherServletRegistration\"&#125; ) @ConditionalOnBean( value = &#123;DispatcherServlet.class&#125;, name = &#123;\"dispatcherServlet\"&#125; ) public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet, WebMvcProperties webMvcProperties, ObjectProvider&lt;MultipartConfigElement&gt; multipartConfig) &#123; DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet, webMvcProperties.getServlet().getPath()); //默认拦截： / 所有请求；包静态资源，但是不拦截jsp请求； /*会拦截jsp//可以通过spring.mvc.servlet.path来修改SpringMVC前端控制器默认拦截的请求路径 registration.setName(\"dispatcherServlet\"); registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup()); multipartConfig.ifAvailable(registration::setMultipartConfig); return registration; &#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"}]},{"title":"SpringBoot学习-Servlet容器配置修改","slug":"SpringBoot学习-Servlet容器配置修改","date":"2020-07-30T06:46:51.000Z","updated":"2020-07-30T14:56:36.579Z","comments":true,"path":"2020/07/30/SpringBoot学习-Servlet容器配置修改/","link":"","permalink":"http://ligangit.com/2020/07/30/SpringBoot学习-Servlet容器配置修改/","excerpt":"","text":"SpringBoot学习-Servlet容器配置修改默认Servlet容器SpringBoot默认使用Tomcat作为嵌入式的Servlet容器； 定制和修改Servlet容器的相关配置修改和server有关的配置方式一：修改ServerProperties类中的属性，都是多服务器进行修改 12345@ConfigurationProperties( prefix = \"server\", ignoreUnknownFields = true)public class ServerProperties &#123; 示例： 123server.port=8081server.servlet.context-path=/springbootserver.tomcat.uri-encoding=UTF-8 方式二：编写一个WebServerFactoryCustomizer：web服务器的定制器；来修改Servlet容器的配置 123456789@Beanpublic WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer()&#123; return new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;() &#123; @Override public void customize(ConfigurableWebServerFactory factory) &#123; factory.setPort(8081); &#125; &#125;;&#125; SpringBoot替换其他的Servlet容器SpringBoot支持的三种Servlet容器默认支持：Tomcat、Jetty（长连接，如web聊天..）、Undertow（不支持jsp，非阻塞，并发性能好） Tomcat（默认使用）12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；--&gt;&lt;/dependency&gt; Jetty1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; Undertow1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 外置Servlet容器（jsp支持、war包）外置的Servlet容器：外面安装Tomcat—应用war包的方式打包； 步骤1）、必须创建一个war项目；（利用idea创建好目录结构）（快捷创建时2、3步会自动配置好） 创建一个SpringBoot项目 ​ 选择打包方式为war包 ​ 其他步骤照常 创建成功后的目录结构 ​ 创建webapp目录（也可以将webapp目录改为其他名字） 2）、将嵌入式的Tomcat指定为provided； 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 3）、必须编写一个SpringBootServletInitializer的子类，并调用configure方法 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //传入SpringBoot应用的主程序 return application.sources(SpringBoot04WebJspApplication.class); &#125;&#125; 4）、配置tomcat服务器 5）、启动服务器就可以使用； 测试JSP支持测试1）、编写JSP页面（注意路径，必须在webapp目录（或者之前创建项目时自己改的）下） 2）、JSP页面访问： http://localhost:8181/springboot_web2_war_exploded/pages/success.jsp 配置测试1）、控制层 12345678@Controllerpublic class HelloController &#123; @RequestMapping(\"/abc\") public String hello(Model model) &#123; model.addAttribute(\"msg\", \"你好\"); return \"success\"; &#125;&#125; 2）、配置文件application.properties设置 12spring.mvc.view.prefix=/pages/spring.mvc.view.suffix=.jsp 3）、请求访问： http://localhost:8181/springboot_web2_war_exploded/abc 打war包部署在pom.xml文件的build中添加如下代码，将webapp添加到静态资源文件夹META-INF/resources下，将webapp中的内容打进war包，防止静态资源丢失 1234567891011121314151617181920212223242526&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 添加这个就可以是webapp目录生效 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;!--注意此次必须要放在此目录下才能被访问到 --&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/*&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"服务器软件","slug":"服务器软件","permalink":"http://ligangit.com/tags/服务器软件/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"tomcat","slug":"tomcat","permalink":"http://ligangit.com/tags/tomcat/"}]},{"title":"SpringBoot学习-错误处理机制","slug":"SpringBoot学习-错误处理机制","date":"2020-07-30T02:29:12.000Z","updated":"2020-07-30T06:45:24.714Z","comments":true,"path":"2020/07/30/SpringBoot学习-错误处理机制/","link":"","permalink":"http://ligangit.com/2020/07/30/SpringBoot学习-错误处理机制/","excerpt":"","text":"SpringBoot学习-错误处理机制SpringBoot默认的错误处理机制默认效果： 浏览器，返回一个默认的错误页面 浏览器发送请求的请求头： 如果是其他客户端，默认响应一个json数据 请求头信息： 原理：可以参照ErrorMvcAutoConfiguration；错误处理的自动配置； 给容器中添加了一下组件： DefaultErrorAttributes 帮我们在页面共享信息 12345678910/** @deprecated */@Deprecatedpublic Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap(); errorAttributes.put(\"timestamp\", new Date()); this.addStatus(errorAttributes, webRequest); this.addErrorDetails(errorAttributes, webRequest, includeStackTrace); this.addPath(errorAttributes, webRequest); return errorAttributes;&#125; BasicErrorController 处理默认/error请求 12345678910111213141516171819202122232425@Controller@RequestMapping(&#123;\"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;\"&#125;)public class BasicErrorController extends AbstractErrorController &#123; @RequestMapping( produces = &#123;\"text/html\"&#125;//产生html类型的数据，浏览器发送的请求来到这个方法处理 ) public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = this.getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); //去哪个页面作为错误页面，包含页面地址和页面内容 ModelAndView modelAndView = this.resolveErrorView(request, response, status, model); return modelAndView != null ? modelAndView : new ModelAndView(\"error\", model); &#125; @RequestMapping//产生json数据,其他客户端发送的请求来到这个方法处理 public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; HttpStatus status = this.getStatus(request); if (status == HttpStatus.NO_CONTENT) &#123; return new ResponseEntity(status); &#125; else &#123; Map&lt;String, Object&gt; body = this.getErrorAttributes(request, this.getErrorAttributeOptions(request, MediaType.ALL)); return new ResponseEntity(body, status); &#125; &#125; ErrorPageCustomizer 系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则） 12@Value(\"$&#123;error.path:/error&#125;\")private String path = \"/error\"; DefaultErrorViewResolver 默认SpringBoot可以去找到一个页面？ error/404 123456789101112131415161718public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = this.resolve(String.valueOf(status.value()), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = this.resolve((String)SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView;&#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认SpringBoot可以去找到一个页面？ error/404 String errorViewName = \"error/\" + viewName; //模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); //模板引擎可用的情况下返回到errorViewName指定的视图地址 //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return provider != null ? new ModelAndView(errorViewName, model) : this.resolveResource(errorViewName, model);&#125; 步骤：​ 一旦系统出现4xx或者5xx之类的错误，ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被BasicErrorController处理； ​ 1）响应页面：去哪个页面是由DefaultErrorViewResolver解析得到的 12345678910111213protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123; //所有的ErrorViewResolver得到modelAndView Iterator var5 = this.errorViewResolvers.iterator(); ModelAndView modelAndView; do &#123; if (!var5.hasNext()) &#123; return null; &#125; ErrorViewResolver resolver = (ErrorViewResolver)var5.next(); modelAndView = resolver.resolveErrorView(request, status, model); &#125; while(modelAndView == null); return modelAndView;&#125; 如何定制错误响应如何定制错误的页面1、用模板引擎的情况下：error/状态码 精确匹配状态码（优先寻找） 将错误页面命名为 错误状态码.html 将html页面放在模板引擎文件夹里面的error文件夹下 发生此状态码的错误就会来到对应的页面 匹配同类型的错误 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误， 精确优先（优先寻找精确的 状态码.html ） 页面能获取的信息： timestamp：时间戳 status：状态码 error：错误提示 exception：异常对象 message：异常消息 errors：JSR303数据校验的错误都在这里 2、没有模板引擎（模板引擎找不到这个错误页面）：静态资源文件夹3、以上都没有错误页面，就是默认来到SpringBoot默认错误提示页面如何定制错误的json数据开启信息显示12server.error.include-exception=trueserver.error.include-message=always 1、自定义异常处理&amp;返回定制json数据 自定义异常 12345public class UserNotExistException extends RuntimeException&#123; public UserNotExistException() &#123; super(\"用户不存在\"); &#125;&#125; 自定义异常处理器 123456789101112@ControllerAdvicepublic class MyExceptionHandler &#123; //浏览器、其他客户端返回的都是json @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); return map; &#125;&#125; 这种模式没有自适应效果（浏览器返回页面，其他客户端返回json） 2、转发到/error进行自适应响应效果处理 修改自定义异常处理器 123456789101112131415@ExceptionHandler(UserNotExistException.class)public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); //转发到/error return \"forward:/error\"; &#125; 将我们的定制数据携带出去出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法） 方式一：完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中； 方式二：页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到； 默认使用容器中的DefaultErrorAttributes.getErrorAttributes()，进行数据处理； 自定义ErrorAttributes 1234567891011121314151617//给容器中加入我们自己定义的ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; //返回的map就是页面和json能获取的所有字段 @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map= super.getErrorAttributes(webRequest, includeStackTrace); map.put(\"author\", \"ligangit\"); //我们的异常处理器携带的请求数据 //0 表示从request域中获取数据 //1 表示从session域中获取数据 Map&lt;String, Object&gt; ext = (Map&lt;String, Object&gt;) webRequest.getAttribute(\"ext\", 0); map.put(\"ext\", ext); return map; &#125;&#125; 修改异常处理器 123456789101112131415161718192021@ControllerAdvicepublic class MyExceptionHandler &#123; //浏览器、其他客户端返回的都是json @ExceptionHandler(UserNotExistException.class) public String handleException(Exception e, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); //传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 /** * Integer statusCode = (Integer) request .getAttribute(\"javax.servlet.error.status_code\"); */ request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); //将我们自己定义的异常数据传递 request.setAttribute(\"ext\",map); //转发到/error return \"forward:/error\"; &#125;&#125; 最终效果 响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容 浏览器 其他客户端","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"异常处理","slug":"异常处理","permalink":"http://ligangit.com/tags/异常处理/"}]},{"title":"SpringBoot学习-国际化","slug":"SpringBoot学习-国际化","date":"2020-07-28T03:32:31.000Z","updated":"2020-07-28T06:55:33.358Z","comments":true,"path":"2020/07/28/SpringBoot学习-国际化/","link":"","permalink":"http://ligangit.com/2020/07/28/SpringBoot学习-国际化/","excerpt":"","text":"SpringBoot学习-国际化步骤第一步：编写国际化配置文件，抽取页面需要显示的国际化消息 第二步：SpringBoot自动配置好了管理国际化资源文件的组件； 我们的配置文件可以直接放在类路径下叫messages.properties； 我们也可以放在一个文件夹中，指定基础名： 12#指定国际化资源文件的基础名spring.messages.basename=i18n.login 第三步：页面取值去页面获取国际化的值； 注意：properties文件中的编码格式。 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"asserts/css/bootstrap.min.css\" th:href=\"@&#123;/webjars/bootstrap/4.5.0/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"asserts/css/signin.css\" th:href=\"@&#123;/asserts/css/signin.css&#125;\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\"&gt; &lt;img class=\"mb-4\" src=\"asserts/img/bootstrap-solid.svg\" th:src=\"@&#123;/asserts/img/bootstrap-solid.svg&#125;\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#&#123;login.tip&#125;\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#&#123;login.username&#125;\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.password&#125;\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#&#123;login.password&#125;\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#&#123;login.btn&#125;\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index.html(lan='zh_CN')&#125;\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index.html(lan='en_US')&#125;\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果根据浏览器语言设置的信息切换了国际化 原理国际化Locale（区域信息对象）：LocaleResolver（获取区域信息对象）： 默认的就是根据请求头带来的区域信息获取Locale进行国际化 第四步：点击链接切换国际化点击链接切换国际化 自己编写一个LocaleResolver 123456789101112131415161718192021/** * 可以在链接上携带区域信息 */public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String lan = request.getParameter(\"lan\"); Locale locale=Locale.getDefault(); if (!StringUtils.isEmpty(lan))&#123; String[] split = lan.split(\"_\"); locale=new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123; &#125;&#125; 并把他加载到容器中 1234@Beanpublic LocaleResolver localeResolver()&#123; return new MyLocaleResolver();&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"注解","slug":"注解","permalink":"http://ligangit.com/tags/注解/"}]},{"title":"SpringBoot学习-SpringMVC配置","slug":"SpringBoot学习-SpringMVC配置","date":"2020-07-27T12:43:15.000Z","updated":"2020-07-30T07:13:37.259Z","comments":true,"path":"2020/07/27/SpringBoot学习-SpringMVC配置/","link":"","permalink":"http://ligangit.com/2020/07/27/SpringBoot学习-SpringMVC配置/","excerpt":"","text":"SpringBoot学习-SpringMVC配置SpringMVC自动配置一：添加到容器（自动配置）SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component），如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（如ViewResolver），则将用户配置的和SpringBoot默认的组合起来。 二：扩展SpringMVCSpring5.0之前（WebMvcConfigurerAdapter过时）编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型，不能标注@EnableWebMvc； 既保留了所有的自动配置，也能用我们扩展的配置 123456789//使用WebMvcConfigurer可以扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123;// 浏览器发送 /ligangit 请求来到成功页面 registry.addViewController(\"/ligangit\").setViewName(\"success\"); &#125;&#125; Spring5.0之后 方法一：实现WebMvcConfigurer接口（推荐） 编写一个配置类（@Configuration），实现WebMvcConfigurer接口，不能标注@EnableWebMvc； 既保留了所有的自动配置，也能用我们扩展的配置 123456789//使用WebMvcConfigurer可以扩展SpringMVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123;// 浏览器发送 /ligangit 请求来到成功页面 registry.addViewController(\"/ligangit\").setViewName(\"success\"); &#125;&#125; 方法二：继承WebMvcConfigurationSupport类 编写一个配置类（@Configuration），是WebMvcConfigurationSupport类型，不能标注@EnableWebMvc； 既保留了所有的自动配置，也能用我们扩展的配置； 相当于覆盖了@EnableAutoConfiguration里的所有方法，每个方法都需要重写，比如，若不实现方法addResourceHandlers()，则会导致静态资源无法访问，实现的方法如下： 1234567891011121314151617181920//使用WebMvcConfigurer可以扩展SpringMVC的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurationSupport&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123;// 浏览器发送 /ligangit 请求来到成功页面 registry.addViewController(\"/ligangit\").setViewName(\"success\"); &#125;// 重写addResourceHandlers方法，若不实现方法addResourceHandlers()，则会导致静态资源无法访问 @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"/**\") .addResourceLocations(\"classpath:/META-INF/resources/\") .addResourceLocations(\"classpath:/resources/\") .addResourceLocations(\"classpath:/static/\") .addResourceLocations(\"classpath:/public/\"); super.addResourceHandlers(registry); &#125;&#125; 原理 WebMvcAutoConfiguration是SpringMVC的自动配置类 在做其他自动配置时会导入@Import({WebMvcAutoConfiguration.EnableWebMvcConfiguration.class}) EnableWebMvcConfiguration类继承了DelegatingWebMvcConfiguration类 1234@Configuration( proxyBeanMethods = false)public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123; DelegatingWebMvcConfiguration类中有个setConfigurers()方法，从容器中获取所有的WebMvcConfigurer 123456789101112131415161718@Configuration( proxyBeanMethods = false)public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite(); public DelegatingWebMvcConfiguration() &#123; &#125; @Autowired( required = false ) public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); &#125; &#125; DelegatingWebMvcConfiguration类中调用WebMvcConfigurerComposite类中的方法，实现获取的所有WebMvcConfigurer中的方法（即将WebMvcConfigurer中的方法都执行一遍） 将所有的WebMvcConfigurer相关配置都来一起调用； WebMvcConfigurerComposite类中的一个参考实现： 1234567public void addViewControllers(ViewControllerRegistry registry) &#123; Iterator var2 = this.delegates.iterator(); while(var2.hasNext()) &#123; WebMvcConfigurer delegate = (WebMvcConfigurer)var2.next(); delegate.addViewControllers(registry); &#125;&#125; 容器中所有的WebMvcConfigurer都会一起起作用 我们的配置类也会被调用 效果SpringMVC的自动配置和我们的扩展配置都会起作用。 三：全面接管SpringMVC（不推荐）实现SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配；所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc 12345678910//使用WebMvcConfigurer可以扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig implements WebMvcConfigurer&#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123;// 浏览器发送 /ligangit 请求来到成功页面 registry.addViewController(\"/ligangit\").setViewName(\"success\"); &#125;&#125; 原理为什么@EnableWebMvc自动配置就失效了？ @EnableWebMvc的核心:@Import({DelegatingWebMvcConfiguration.class}) 12345@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE&#125;)@Documented@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)public @interface EnableWebMvc &#123; DelegatingWebMvcConfiguration类： 1234@Configuration( proxyBeanMethods = false)public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123; 查看WebMvcAutoConfiguration类（SpringMVC自动配置类） 容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean({WebMvcConfigurationSupport.class}) 123456789101112@Configuration( proxyBeanMethods = false)@ConditionalOnWebApplication( type = Type.SERVLET)@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)//容器中没有这个组件的时候，这个自动配置类才生效@ConditionalOnMissingBean(&#123;WebMvcConfigurationSupport.class&#125;)@AutoConfigureOrder(-2147483638)@AutoConfigureAfter(&#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class, ValidationAutoConfiguration.class&#125;)public class WebMvcAutoConfiguration &#123; @EnableWebMvc将WebMvcConfigurationSupport组件导入进来 导入的WebMvcConfigurationSupport只是最基本的功能； 如何修改SpringBoot的默认配置 SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component），如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（如ViewResolver），则将用户配置的和SpringBoot默认的组合起来。 在SpringBoot中会有非常多的xxxConfiger帮助我们进行扩展配置。 在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://ligangit.com/tags/SpringMVC/"}]},{"title":"SpringBoot学习-模板引引擎_thymeleaf","slug":"SpringBoot学习-模板引引擎-thymeleaf","date":"2020-07-27T07:00:49.000Z","updated":"2020-07-29T03:21:10.299Z","comments":true,"path":"2020/07/27/SpringBoot学习-模板引引擎-thymeleaf/","link":"","permalink":"http://ligangit.com/2020/07/27/SpringBoot学习-模板引引擎-thymeleaf/","excerpt":"","text":"SpringBoot学习-模板引引擎之Thymeleaf引入Thymeleaf1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; Thymeleaf使用&amp;语法默认配置： 1234567891011@ConfigurationProperties( prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; 只需要把HTML页面放在classpath:/templates/，Thymeleaf就能自动渲染。 使用 导入thymeleaf的名称空间 1&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 使用thymeleaf的语法 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;成功！&lt;/h1&gt;&lt;!--th:text 将div里面的文本内容设置为--&gt;&lt;div th:text=\"$&#123;hello&#125;\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 语法th:任意html属性th:text改变当前元素里面的文本内容； th:任意html属性；来替换原生属性的值 表达式 Simple expressions:(表达式语法) Variable Expressions: ${…} 获取变量值：OGNL 1）、获取对象的属性、调用方法 2）、使用内置的基本对象 #ctx : the context object. #vars: the context variables. #locale : the context locale. #request : (only in Web Contexts) the HttpServletRequest object. #response : (only in Web Contexts) the HttpServletResponse object. #session : (only in Web Contexts) the HttpSession object. #servletContext : (only in Web Contexts) the ServletContext object. 3）、内置的工具对象 #execInfo : information about the template being processed. #messages : methods for obtaining externalized messages inside variables expressions, in the same way as theywould be obtained using #{…} syntax. #uris : methods for escaping parts of URLs/URIsPage 20 of 106 #conversions : methods for executing the configured conversion service (if any). #dates : methods for java.util.Date objects: formatting, component extraction, etc. #calendars : analogous to #dates , but for java.util.Calendar objects. #numbers : methods for formatting numeric objects. #strings : methods for String objects: contains, startsWith, prepending/appending, etc. #objects : methods for objects in general. #bools : methods for boolean evaluation. #arrays : methods for arrays. #lists : methods for lists. #sets : methods for sets. #maps : methods for maps. #aggregates : methods for creating aggregates on arrays or collections. #ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Selection Variable Expressions: *{…} 选择表达式：和${}在功能上是一样 1）、补充：配合 th:object=”${session.user}” 12345&lt;div th:object=\"$&#123;session.user&#125;\"&gt;&lt;p&gt;Name: &lt;span th:text=\"*&#123;firstName&#125;\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;Surname: &lt;span th:text=\"*&#123;lastName&#125;\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;Nationality: &lt;span th:text=\"*&#123;nationality&#125;\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; Message Expressions: #{…} 获取国际化内容 Link URL Expressions: @{…} 定义URL 1@&#123;/order/process(execId=$&#123;execId&#125;,execType='FAST')&#125; Fragment Expressions: ~{…} 片段引用表达式 1&lt;div th:insert=\"~&#123;commons :: main&#125;\"&gt;...&lt;/div&gt; Literals（字面量） Text literals: ‘one text’ , ‘Another one!’ ,… Number literals: 0 , 34 , 3.0 , 12.3 ,… Boolean literals: true , false Null literal: null Literal tokens: one , sometext , main ,… Text operations:（文本操作） String concatenation: + Literal substitutions: |The name is ${name}| Arithmetic operations:（数学运算） Binary operators: + , - , * , / , % Minus sign (unary operator): - Boolean operations:（布尔运算） Binary operators: and , or Boolean negation (unary operator): ! , not Comparisons and equality:（比较运算） Comparators: &gt; , &lt; , &gt;= , &lt;= ( gt , lt , ge , le ) Equality operators: == , != ( eq , ne ) Conditional operators:（条件运算（三元运算符）） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else)Default: (value) ?: (defaultvalue) Default: (value) ?: (defaultvalue) Special tokens:（特殊操作） Page 17 of 106No-Operation: _（不进行任何操作） 公共页面元素抽取使用方式 抽取公共片段 使用片段名： 123&lt;div th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 使用选择器： 123&lt;div id=\"copy-section\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入公共片段 使用选择器： 1&lt;div th:insert=\"~&#123;footer :: #copy-section&#125;\"&gt;&lt;/div&gt; 使用片段名： 1&lt;div th:insert=\"~&#123;footer :: copy&#125;\"&gt;&lt;/div&gt; 引入方式一： 1&lt;div th:insert=\"~&#123;footer :: copy&#125;\"&gt;&lt;/div&gt; 引入方式二：省略~{} 1&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt; 语法 ~{templatename::selector} ： 模板名::选择器 ~{templatename::fragmentname} ： 模板名:片段名 效果 insert的功能片段在div标签中 如果使用th:insert等属性进行引入，可以不用写~{}； 行内写法可以加上：[[~{}]]；[(~{})] 三种引入公共片段的th属性th:insert ：将公共片段整个插入到声明引入的元素中 th:replace ：将声明引入的元素替换为公共片段 th:include ：将被引入的内容包含进声明引入的元素中 公共片段 123&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt; 引入公共片段 123&lt;div th:insert=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt; 效果 12345678910111213&lt;div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;/div&gt;&lt;footer&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt;&amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段传递参数方式一：fragment使用形参接收参数 公共片段使用参数 123&lt;div th:fragment=\"frag (onevar,twovar)\"&gt;&lt;p th:text=\"$&#123;onevar&#125; + ' - ' + $&#123;twovar&#125;\"&gt;...&lt;/p&gt;&lt;/div&gt; 引入公共片段时传递参数 方式一：onevar接收第一个值value1，twovar接收第二个值value2 1&lt;div th:replace=\"::frag ($&#123;value1&#125;,$&#123;value2&#125;)\"&gt;...&lt;/div&gt; 方式二：形参名和传递的参数名相同，值传给对应的形参 这种传递参数是可以没有顺序的： 1&lt;div th:replace=\"::frag (onevar=$&#123;value1&#125;,twovar=$&#123;value2&#125;)\"&gt;...&lt;/div&gt; 等价于： 1&lt;div th:replace=\"::frag (twovar=$&#123;value2&#125;,onevar=$&#123;value1&#125;)\"&gt;...&lt;/div&gt; 方式二：fragment不使用变量名 公共片段使用参数 123&lt;div th:fragment=\"frag\"&gt;&lt;p th:text=\"$&#123;onevar&#125; + ' - ' + $&#123;twovar&#125;\"&gt;...&lt;/p&gt;&lt;/div&gt; 引入公共片段时传递参数 1&lt;div th:replace=\"::frag (onevar=$&#123;value1&#125;,twovar=$&#123;value2&#125;)\"&gt; 注意： 传递的参数和使用的时候调用的参数名必须一致 传递的参数名不能重复","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"thymeleaf","slug":"thymeleaf","permalink":"http://ligangit.com/tags/thymeleaf/"}]},{"title":"SpringBoot学习-静态资源映射","slug":"SpringBoot学习-静态资源映射","date":"2020-07-27T03:26:15.000Z","updated":"2020-07-27T07:00:43.070Z","comments":true,"path":"2020/07/27/SpringBoot学习-静态资源映射/","link":"","permalink":"http://ligangit.com/2020/07/27/SpringBoot学习-静态资源映射/","excerpt":"","text":"SpringBoot学习-静态资源映射映射规则 设置和静态资源有关的参数，如缓存时间等 12345@ConfigurationProperties( prefix = \"spring.resources\", ignoreUnknownFields = false)public class ResourceProperties &#123; 静态资源映射 12345678910111213141516171819202122232425 public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); &#125; else &#123; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;\"/webjars/**\"&#125;).addResourceLocations(new String[]&#123;\"classpath:/META-INF/resources/webjars/\"&#125;).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125; &#125;//配置欢迎页映射 @Bean public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider)); welcomePageHandlerMapping.setCorsConfigurations(this.getCorsConfigurations()); return welcomePageHandlerMapping; &#125; 映射方式一、/webjars/**所有/webjars/，都去classpath:/META-INF/resources/webjars/找资源 webjars：以jar包的方式引入静态资源 官网： https://www.webjars.org/ 示例： 引入依赖： 123456&lt;!--引入jquery-webjars--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt;&lt;/dependency&gt; 静态资源目录结构 资源请求路径 在访问的时候，只需要写webjars下面资源的名称即可 请求路径：http://localhost:8080/webjars/jquery/3.5.1/jquery.js 二、/**访问当前项目的任何资源/**访问当前项目的任何资源，都是在静态资源的文件夹找 12345&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;&quot;/&quot; 当前项目的根路径 http://localhost:8080/jquery4.js 去静态资源文件夹下找jquery4.js 三、index.html欢迎页欢迎页：静态资源文件夹下的所有index.html;被/映射；** http://localhost:8080 找index页面 四、**/favicon.ico图标所有的/**favicon.ico 都是在静态资源文件下找 注意： Spring Boot2.2.x版本及之后版本中，将默认的favicon.ico移除，同时也不再提供application.properties中的属性配置：spring.mvc.favicon.enabled 想设置图标只需要将图标文件 favicon.ico 放在静态资源文件夹下或者自己配置映射就可以了。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"webjars","slug":"webjars","permalink":"http://ligangit.com/tags/webjars/"}]},{"title":"SpringBoot学习-日志","slug":"SpringBoot学习-日志","date":"2020-07-25T07:53:32.000Z","updated":"2020-07-27T03:25:59.221Z","comments":true,"path":"2020/07/25/SpringBoot学习-日志/","link":"","permalink":"http://ligangit.com/2020/07/25/SpringBoot学习-日志/","excerpt":"","text":"SpringBoot学习-日志SLF4j使用1、如何在系统中使用SLF4j以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入slf4j的jar和logback的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 图示： 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件； 2、统一日志记录a（slf4j+logback）：Spring（commons-logging）、Hibernate（jboss-logging）、Mybatis、xxx a系统使用slf4j+logback,但是使用了Spring框架、Hibernate框架、Mybatis框架等，日志框架不一样，此时需要统一日志记录。 统一日志记录，即：使是别的框架和我一起统一使用slf4j进行输出？ 如何让系统中所有的日志都统一到slf4j： ==将系统中其他日志框架先排除出去；== ==用中间包替换原有的日志框架；== ==再导入slf4j其他的实现== SpringBoot日志关系 必备启动器starter 1234567&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; SpringBoot使用它来做日志功能： 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.3.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 底层依赖关系： 总结： SpringBoot底层使用slf4j+logback的方式进行日志记录； SpringBoot把其他的日志都替换成了slf4j； 如果我们要引入其他框架，一定要把这个框架的默认日志依赖移除掉 SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉 日志使用默认配置SpringBoot默认帮我们配置好了日志； 12345678910111213141516171819@SpringBootTestclass SpringbootDemo1ApplicationTests &#123; //日志记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test public void testLogging() &#123;// System.out.println(person); //日志的级别， // 由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别，日志就只会在这个级别及以后的高级别生效 logger.trace(\"这是trace日志...\"); logger.debug(\"这是debug日志...\"); //SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别； logger.info(\"这是info日志...\"); logger.warn(\"这是warn日志...\"); logger.error(\"这是error日志...\"); &#125;&#125; SpringBoot修改日志的默认配置 1234567891011121314logging.level.com.ligangit=tracelogging.file.clean-history-on-start=false#不指定路径在当前项目下生成sprngboot.log日志#可以指定完整的路径#logging.file.name=D:/springbootlog/sprngboot.log#在指定路径下生成spring.log日志logging.file.path=D:/springbootlog#在控制台输出的日志的格式#logging.pattern.console=#指定文件中日志输出的格式#logging.pattern.file= 指定配置给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了。 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties 建议使用带-spring.xml logback.xml：直接就被日志框架识别了 logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 1234&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; &lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;&lt;/springProfile&gt; 切换日志框架可以按照slf4j的日志适配图，进行相关的切换； slf4j+log4j的方式：123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-to-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 切换为log4j2： 把之前的spring-boot-starter-logging排除 添加spring-boot-starter-log4j2 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"日志","slug":"日志","permalink":"http://ligangit.com/tags/日志/"}]},{"title":"Redis-集群","slug":"Redis-集群","date":"2020-07-20T01:10:24.000Z","updated":"2020-07-20T03:48:26.449Z","comments":true,"path":"2020/07/20/Redis-集群/","link":"","permalink":"http://ligangit.com/2020/07/20/Redis-集群/","excerpt":"","text":"Redis-集群为什么需要集群Redis的主从复制解决了读写分离，但是 内存容量不够，redis如何进行扩容？ 并发写操作，redis如何分摊？ 什么是集群Redis集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N。 Redis集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中有一部分节点无效或者无法进行通讯，集群也可以继续处理命令请求。 使用步骤 安装ruby环境 制作6个实例 6379 6380 6381 6389 6390 6391 配置修改 cluster-enabled yes 打开集群模式 cluster-config-file nodes-6379.conf 设定节点配置文件 cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换 将6个节点合成一个集群 启动6个节点redis 组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常 以集群的方式进入客户端 redis-cli -c -p 端口号 通过 cluster nodes 命令查看集群信息 优缺点优势 实现扩容 分摊压力 无中心配置相对简单 不足 不支持多键操作（mset、mget） 不支持多键的redis事务，lua脚本不被支持 由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大 。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/categories/Redis/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"},{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://ligangit.com/tags/缓存/"}]},{"title":"Redis-五大数据类型","slug":"Redis-五大数据类型","date":"2020-07-17T13:21:04.000Z","updated":"2020-07-18T01:48:38.115Z","comments":true,"path":"2020/07/17/Redis-五大数据类型/","link":"","permalink":"http://ligangit.com/2020/07/17/Redis-五大数据类型/","excerpt":"","text":"Redis的五大数据类型Redis数据类型 key（键） keys * 查询当前库的所有键 exists &lt;key&gt; 判断某个键是否存在 type &lt;key&gt; 查看键的类型 del &lt;key&gt; 删除某个键 expire &lt;key&gt; &lt;seconds&gt; 为键值设置过期时间，单位秒 ttl &lt;key&gt; 查看还有多少秒过期，-1表示永不过期，-2表示已过期 dbsize 查看当前数据库的key的数量 flushdb 清空当前库 flushall 通杀全部库 String（字符串） 是Redis最基本的类型，一个key对应一个value； 是二进制安全的，即Redis的String可以包含任何数据，比如jpg图片或者序列化对象； 是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M。 get &lt;key&gt; 查询对应键值对 set &lt;key&gt; &lt;value&gt; 添加键值对 append &lt;key&gt; &lt;value&gt; 将给定的value追加到原值的末尾 strlen &lt;key&gt; 获取值的长度 setnx &lt;key&gt; &lt;value&gt; 只有在key不存在时设置key的值 incr &lt;key&gt; 将key中储存的数字值加1； 只能对数字值操作，如果为空，新增值为1 decr &lt;key&gt; 将key中储存的数字值减1； 只能对数字值操作，如果为空，新增值为-1 incrby/decrby &lt;key&gt; &lt;步长&gt; 将key中储存的数字值增减。自定义步长 mset &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt; … 同时设置一个或多个key-value对 mget &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt; … 同时获取一个或多个value msetnx &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt; … 同时设置一个或多个key-value对，当且仅当所有给定key都不存在，才会执行成功 getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt; 获取值的范围，类似java中的substring setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt; 用value覆写key所储存的字符串的值，从&lt;起始位置&gt;开始 setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt; 设置键值的同时，设置过期时间，单位秒 getset &lt;key&gt; &lt;value&gt; 以新换旧，设置了新值同时获取旧值 List（列表） 单键多值 Redis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或尾部（右边） 它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差 lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt; … 从 列表头部（左边）/ 列表尾部（右边）插入一个或多个值 lpop/rpop &lt;key&gt; 从 列表头部（左边）/ 列表尾部（右边）弹出一个值 如果弹出值后，列表中没有值了，那么键会自动删除 rpoplpush &lt;key1&gt; &lt;key2&gt; 从key1列表尾部（右边）弹出一个值， 并将该值添加到另一个key2列表并返回 lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; 按照索引下标获得元素（从列表头部（左边）向列表尾部（右边）） lindex &lt;key&gt; &lt;index&gt; 按照索引下标获的元素（从列表头部（左边）向列表尾部（右边）） llen &lt;key&gt; 获取列表长度 linsert &lt;key&gt; before/after &lt;value&gt; &lt;newvalue&gt; 在value的前面或后面插入newvalue lrem &lt;key&gt; &lt;count &gt; &lt;value&gt; 从列表头部（左边）删除count 个&lt;value&gt; （从列表头部（左边）向列表尾部（右边）） count &gt; 0 : 从表头开始向表尾搜索，移除与 VALUE 相等的元素，数量为 COUNT 。 count &lt; 0 : 从表尾开始向表头搜索，移除与 VALUE 相等的元素，数量为 COUNT 的绝对值。 count = 0 : 移除表中所有与 VALUE 相等的值。 返回值为被移除元素的数量。 列表不存在时返回 0 。 set（集合） set对外提供的功能与list类似，是一个列表的功能，特殊之处在于set可以自动去重，当需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的； set是String类型的无序、无重复集合，通过HashTable实现的，它的底层是一个value为null的hash表，所以添加、删除、查找的复杂度都是O(1)。 sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt; … 将一个或多个成员加入到集合key当中，已经存在于集合的成员将被忽略 smembers &lt;key&gt; 取出该集合的所有成员值 sismember &lt;key&gt; &lt;value&gt; 判断集合key是否存在value值，有则返回1，没有则返回0 scard &lt;key&gt; 获取该集合的成员个数 srem &lt;key&gt; &lt;value1&gt; &lt;value2&gt; … 删除集合中的一个或多个成员 spop &lt;key&gt; [count] 随机移除key 的一个或多个元素，移除后会返回移除的元素 srandmember &lt;key&gt; &lt;count&gt; 返回集合中一个或多个随机数 如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。 如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。 不会删除元素 smove &lt;key1&gt; &lt;key2&gt; &lt;value&gt; 将value元素从key1集合移动到key2集合 value元素会从key1集合中删除 sinter &lt;key1&gt; &lt;key2&gt; … 返回给定所有集合的交集 sunion &lt;key1&gt; &lt;key2&gt; … 返回给定所有集合的并集 sdiff &lt;key1&gt; &lt;key2&gt; … 返回给定所有集合的差集 hash（哈希） 是一个键值对集合 是一个String类型的field和value的映射表，Hash特别适合用于存储对象 类似Java里面的Map&lt;String,Object&gt; hset &lt;key&gt; &lt;field&gt; &lt;value&gt; 设置哈希表key中域filed的值为value hget &lt;key&gt; &lt;field&gt; 获取哈希表 key中域filed的值 hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt; … 同时将多个 field-value (域-值)对设置到哈希表key中 hexists &lt;key&gt; &lt;filed&gt; 查看哈希表key中，域filed是否存在 hkeys &lt;key&gt; 列出该哈希表key所有的域filed hvals &lt;key&gt; 列出该哈希表key所有的value值 hincrby &lt;key&gt; &lt;filed&gt; &lt;increment&gt; 为哈希表 key 中的指定字段的整数值加上增量increment hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt; 将哈希表key中的域field的值设置为value，当且仅当域field不存在 zset（sorted set：有序集合） 和set一样也是String类型元素的集合，且不允许重复的成员 不同的是每个元素都会关联一个double类型的分数 Redis通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数（score）却可以重复 zadd &lt;key&gt; &lt;score1&gt; &lt;member1&gt; &lt;score2&gt; &lt;member2&gt; … 向有序集合key添加一个或多个成员，或者更新已存在成员的分数 zrange &lt;key&gt; &lt;start&gt; &lt;stop&gt; [WITHSCORES] 获取有序集合key中，下标在start、stop之间的元素 带WITHSCORES，可以让分数score一起和值返回到结果集 zrangebyscore &lt;key&gt; &lt;min&gt; &lt;max&gt; [WITHSCORES] [limit ofseet count] 获取有序集合key中，所有score值介于min和max之间（包括等于min或max）的成员。有序集合成员按score值递增（从小到大）依次排序 zrevrangebyscore &lt;key&gt; &lt;max&gt; &lt;min&gt; [WITHSCORES] [limit ofseet count] 同zrangebyscore，但是排序方式是从大到小 zincrby &lt;key&gt; &lt;increment&gt; &lt;member&gt; 有序集合key中对指定成员member的分数score加上增量 increment zrem &lt;key&gt; &lt;member1&gt; &lt;member2&gt; … 移除有序集合中的一个或多个成员 zcount &lt;key&gt; &lt;min&gt; &lt;max&gt; 计算在有序集合key中指定区间分数min-max的成员数 zrank &lt;key&gt; &lt;member&gt; 返回有序集合key中指定成员member的索引 (排名)，从0开始","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/categories/Redis/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"},{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://ligangit.com/tags/缓存/"}]},{"title":"Redis-单线程+多路IO复用","slug":"Redis-单线程-多路IO复用","date":"2020-07-17T09:24:28.000Z","updated":"2020-07-17T13:20:42.597Z","comments":true,"path":"2020/07/17/Redis-单线程-多路IO复用/","link":"","permalink":"http://ligangit.com/2020/07/17/Redis-单线程-多路IO复用/","excerpt":"","text":"Redis的单线程+多路IO复用多路IO复用 多路IO复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行正真的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。 简单来说： 多路IO复用其实是在单个线程中通过记录跟踪每一个sock（I/O流） 的状态来管理多个I/O流 。 多路IO复用包括select，poll，epoll三种模式： select模式：一个一个的去询问请求的状态，直到有一个处于就绪状态，然后交给redis处理，否则继续询问下去，但是最多只能监视1024个请求； poll模式：和select模式一样，但是poll模式没有监视请求数量的限制； epoll模式：监视请求时，先为请求设置一个标识符，判断是否处于就绪状态，通过查看标识符，将处于就绪状态的请求交给redis处理； epoll性能比其他几者要好。 参考： https://blog.csdn.net/diweikang/article/details/90346020","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/categories/Redis/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"},{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://ligangit.com/tags/缓存/"}]},{"title":"Redis-Jedis_JedisPool","slug":"Redis-Jedis-JedisPool","date":"2020-07-17T06:40:48.000Z","updated":"2020-07-17T07:16:01.975Z","comments":true,"path":"2020/07/17/Redis-Jedis-JedisPool/","link":"","permalink":"http://ligangit.com/2020/07/17/Redis-Jedis-JedisPool/","excerpt":"","text":"Redis-Jedis之JedisPool方式一配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120public class RedisUtil &#123; //Redis服务器IP private static String ADDR = \"127.0.0.1\"; //Redis的端口号 private static int PORT = 6379; //访问密码// private static String AUTH = \"admin\"; //可用连接实例的最大数目，默认值为8； //如果赋值为-1，则表示不限制；如果pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。 private static int MAX_TOTAL = 100; //最小空闲连接数, 默认0 private static int MIN_IDLE=0; //控制一个pool最多有多少个状态为idle(空闲的)的jedis实例，默认值也是8。 //最大空闲连接数, 默认8个 private static int MAX_IDLE = 100; //获取连接时的最大等待毫秒数(如果设置为阻塞时BlockWhenExhausted),如果超时就抛异常, 小于零:阻塞不确定的时间, 默认-1 //等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时。如果超过等待时间，则直接抛出JedisConnectionException； private static int MAX_WAIT = -1; private static int TIMEOUT = 10000; //连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true private static boolean BLOCK_WHEN_EXHAUSTED = false; //设置的逐出策略类名, 默认DefaultEvictionPolicy(当连接超过最大空闲时间,或连接数超过最大空闲连接数) private static String EVICTION_POLICY_CLASSNAME=\"org.apache.commons.pool2.impl.DefaultEvictionPolicy\"; //是否启用pool的jmx管理功能, 默认true private static boolean JMX_ENABLED=true; //MBean ObjectName = new ObjectName(\"org.apache.commons.pool2:type=GenericObjectPool,name=\" + \"pool\" + i); 默认为\"pool\", JMX不熟,具体不知道是干啥的...默认就好. private static String JMX_NAME_PREFIX=\"pool\"; //是否启用后进先出, 默认true private static boolean LIFO=true; //逐出连接的最小空闲时间 默认1800000毫秒(30分钟)，现在设置为300分钟即5小时 private static long MIN_EVICTABLE_IDLE_TIME_MILLIS=18000000L; //对象空闲多久后逐出, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲数 时直接逐出,不再根据MinEvictableIdleTimeMillis判断 (默认逐出策略) private static long SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS=18000000L; //每次逐出检查时 逐出的最大数目 如果为负数就是 : 1/abs(n), 默认3 private static int NUM_TESTS_PER_EVICYION_RUN=3; //在borrow一个jedis实例时，是否提前进行validate操作；如果为true，则得到的jedis实例均是可用的； //在获取连接的时候检查有效性, 默认false private static boolean TEST_ON_BORROW = false; //在空闲时检查有效性, 默认false private static boolean TEST_WHILEIDLE=false; //逐出扫描的时间间隔(毫秒) 如果为负数,则不运行逐出线程, 默认-1 private static long TIME_BERWEEN_EVICTION_RUNS_MILLIS=-1; private static JedisPool jedisPool = null; /** * 初始化Redis连接池 */ static &#123; try &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setBlockWhenExhausted(BLOCK_WHEN_EXHAUSTED); config.setEvictionPolicyClassName(EVICTION_POLICY_CLASSNAME); config.setJmxEnabled(JMX_ENABLED); config.setJmxNamePrefix(JMX_NAME_PREFIX); config.setLifo(LIFO); config.setMaxIdle(MAX_IDLE); config.setMaxTotal(MAX_TOTAL); config.setMaxWaitMillis(MAX_WAIT); config.setMinEvictableIdleTimeMillis(MIN_EVICTABLE_IDLE_TIME_MILLIS); config.setMinIdle(MIN_IDLE); config.setNumTestsPerEvictionRun(NUM_TESTS_PER_EVICYION_RUN); config.setSoftMinEvictableIdleTimeMillis(SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS); config.setTestOnBorrow(TEST_ON_BORROW); config.setTestWhileIdle(TEST_WHILEIDLE); config.setTimeBetweenEvictionRunsMillis(TIME_BERWEEN_EVICTION_RUNS_MILLIS);// jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH); jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取Jedis实例 * @return */ public synchronized static Jedis getJedis() &#123; try &#123; if (jedisPool != null) &#123; Jedis resource = jedisPool.getResource(); return resource; &#125; else &#123; return null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 释放jedis资源 * @param jedis */ public static void close(final Jedis jedis) &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125;&#125; 调用 1234//获取Jedis对象Jedis jedis = RedisUtil.getJedis();//释放jedisRedisUtil.close(jedis); 方式二配置 1234567891011121314151617181920212223242526public class JedisPoolUtil &#123; private static volatile JedisPool jedisPool = null; private JedisPoolUtil()&#123; &#125; public static JedisPool getJedisPoolInstance()&#123; if (null==jedisPool)&#123; synchronized (JedisPoolUtil.class)&#123; if (null==jedisPool)&#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxTotal(1000); poolConfig.setMaxIdle(32); poolConfig.setMaxWaitMillis(100*1000); poolConfig.setTestOnBorrow(true); jedisPool=new JedisPool(poolConfig,\"127.0.0.1\",6379); &#125; &#125; &#125; return jedisPool; &#125; public static void release(JedisPool jedisPool, Jedis jedis)&#123; if (null!=jedis)&#123; jedis.close(); &#125; &#125;&#125; 调用 123456789101112public static void main(String[] args) &#123; JedisPool jedisPool = JedisPoolUtil.getJedisPoolInstance(); Jedis jedis = null; try &#123; jedis=jedisPool.getResource(); jedis.set(\"aa\", \"bb\"); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; JedisPoolUtil.release(jedisPool,jedis); &#125;&#125;","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/categories/Redis/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"},{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://ligangit.com/tags/缓存/"}]},{"title":"Redis-Jedis","slug":"Redis-Jedis","date":"2020-07-17T03:22:06.000Z","updated":"2020-07-18T01:15:23.393Z","comments":true,"path":"2020/07/17/Redis-Jedis/","link":"","permalink":"http://ligangit.com/2020/07/17/Redis-Jedis/","excerpt":"","text":"Redis-Jedis环境准备 创建一个maven项目 导入redis依赖 123456&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; 启动redis 测试联通使用jedis.ping()： 1234567/** * 测试联通 */public static void main(String[] args) &#123; Jedis jedis = new Jedis(\"127.0.0.1\", 6379); System.out.println(jedis.ping());&#125; 结果： 常用APIkey（键）123456789public static void main(String[] args) &#123; Jedis jedis = new Jedis(\"127.0.0.1\", 6379); jedis.set(\"k1\", \"v1\"); jedis.set(\"k2\", \"v2\"); jedis.set(\"k3\", \"v3\"); System.out.println(jedis.get(\"k2\")); Set&lt;String&gt; keys = jedis.keys(\"*\"); System.out.println(keys.size());&#125; String（字符串）Hash（哈希）List（列表）Set（集合）Zset（sorted set：有序集合）事务正常执行jedis.multi() 123456789101112 public static void main(String[] args) &#123; Jedis jedis = new Jedis(\"127.0.0.1\", 6379); //开启事务 Transaction transaction = jedis.multi(); //入队 transaction.set(\"k4\", \"v4\"); transaction.set(\"k5\", \"v5\"); //执行事务 transaction.exec(); //取消事务// transaction.discard(); &#125; 加锁（watch有问题）12345678910111213141516171819202122232425262728293031323334353637383940414243public class TestSW &#123; public boolean transMehtod()&#123; Jedis jedis = new Jedis(\"127.0.0.1\", 6379); int balance;//可用余额 int debt;//欠额 int amtToSubtract=10;//实刷额度 jedis.watch(\"balance\"); balance = Integer.parseInt(jedis.get(\"balance\")); if (balance &lt; amtToSubtract) &#123; jedis.unwatch(); System.out.println(\"失败\"); return false; &#125;else&#123; System.out.println(\"*****************transaction\"); Transaction transaction = jedis.multi(); transaction.decrBy(\"balance\", amtToSubtract); transaction.incrBy(\"debt\", amtToSubtract); transaction.exec(); balance = Integer.parseInt(jedis.get(\"balance\")); debt = Integer.parseInt(jedis.get(\"debt\")); System.out.println(\"********** :\"+balance); System.out.println(\"********** :\" + debt); return true; &#125; &#125; /** * watch命令就是一个标记键，如果标记了一个键，在提交事务前如果键被别人修改过，那事务就会失败， * 这种情况通常可以在程序中重新尝试一次 * 首先标记了键balance，然后检查余额是否足够，不足就取消标记，并不做扣减 * 足够的话，就启动事务进行更新操作 * 如果在此期间键banlace被其他人修改，那在提交事务（执行exec）时就会报错， * 程序中通常可以捕获这类错误再重新执行一次，直到成功 */ public static void main(String[] args) &#123; TestSW testSW = new TestSW(); boolean retValue = testSW.transMehtod(); System.out.println(\"main retValue.......:\"+retValue); &#125;&#125; 正常执行 主从复制12345678public static void main(String[] args) &#123; Jedis jedis_M = new Jedis(\"127.0.0.1\", 6379); Jedis jedis_S = new Jedis(\"127.0.0.1\", 6380); jedis_S.slaveof(\"127.0.0.1\", 6379); jedis_M.set(\"class\", \"1122\"); String result = jedis_S.get(\"class\"); System.out.println(result);&#125; 执行时内存过快，第一次可能得到null，这时需要重新执行一遍，才能得到正确的值 第二次执行之前将“class”设置为“1122vvv”，以便区分：","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/categories/Redis/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"},{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://ligangit.com/tags/缓存/"}]},{"title":"Redis-主从复制","slug":"Redis-主从复制","date":"2020-07-16T14:36:56.000Z","updated":"2020-07-19T15:23:36.273Z","comments":true,"path":"2020/07/16/Redis-主从复制/","link":"","permalink":"http://ligangit.com/2020/07/16/Redis-主从复制/","excerpt":"","text":"Redis-主从复制是什么Redis的复制（Master/Slave） 也就是我们所说的主从复制，主机数据更新后根据配置和策略，自动同步到备机的master/slave机制，Master以写为主，Slave以读为主。 主要作用： 读写分离，性能扩展 容灾恢复 使用步骤 配从（库）不配主（库） 从库配置：slaveof 主库IP 主库端口 每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件 Info replication 查看redis信息 配置之后，原先从库中的数据会被清空，然后再同步主库所有数据 修改配置文件细节操作 拷贝多个redis.conf文件 开启daemonize yes Pid文件名字pidfile 指定端口port log文件名字 dump.rdb名字dbfilenme appendonly 关掉或者名字 常用3招 一主二仆 init 一个Master两个Slave 日志查看 主从问题演示 薪火相传 上一个slave可以是下一个slave的master，slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master，可以有效减轻master的写压力，去中心化降低风险 中途变更转向：会清除之前的数据，重新建立拷贝最新的 slaveof 新主库IP 新主库端口 风险是一旦某个salve宕机，那么它的slave都没法备份 反客为主 slaveof no one 使当前数据库停止与其他数据库的同步，转成主数据库 需要注意的问题 Q： 切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制？比如从k4进来，那之前的k1、 k2、k3是否也可以复制？ A： 从头开始复制，不管什么时候给主服务器配置了一台从服务器，从服务器都要和主服务器数据保持一致。 Q： 从服务器是否可以写？set可否？ A： 不能。 Q： 主机shutdown之后情况如何？从机上位还是原地待命？ A： 如果没有配置哨兵模式，那么就是原地待命； 如果配置了哨兵模式，那么从机中有一台自动上位。 Q： 主机又回来后，主机新增记录，从机是否还能顺利复制？ A： 能，一定是主从复制，数据保持一致。 Q： 其中一台从机down后情况如何？依照原有它能根上大部队吗？ A： 不管什么时候，从服务器都要和主服务器数据保持一致。 复制原理 slave启动成功连接master后，会给master发送一个sync命令 master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，以完成一次完全同步 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中 增量复制：master继续将新的所有收集到的修改命令依次传给slave，完成同步 但是只要是重新连接master，一次完全同步（全量复制）将被自动执行 哨兵模式（sentinel）是什么反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从数据库转换为主库 使用步骤 调整结构，6379带着80、81，即调整为一主二仆模式 自定义的redis配置文件目录中，新建sentinel.conf文件，名字绝对不能错 配置哨兵，填写内容 sentinel monitor 被监控主机名字（自己起的名字） 127.0.0.1 6379 1 上面最后一个数字1，代表只有一个或一个以上的哨兵认为主服务器不可用的时候，主服务器才算不可用，才会进行 故障切换（failover）操作 启动哨兵 redis-sentinel D:/redismy/sentinel.conf 上面目录依照各自的实际情况配置，可能目录不同 windows启动：redis-server D:/redismy/sentinel.conf –sentinel 故障修复 原有的master挂了 投票新选 重新主从继续开工，info replication查看 问题：如果之前的master重启回来，会不会双master冲突？ 之前的master重启回来后会转换为slave，隶属于新的master。 一组sentinel能同时监控多个master复制的缺点 复制延时 由于所有的写操作都是先在Master上操作，然后同步更新到slave上，所以master同步到slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，slave机器数量的增加也会使这个问题更加严重。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/categories/Redis/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"},{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://ligangit.com/tags/缓存/"}]},{"title":"Redis-发布订阅","slug":"Redis-发布订阅","date":"2020-07-16T14:14:58.000Z","updated":"2020-07-18T12:01:44.497Z","comments":true,"path":"2020/07/16/Redis-发布订阅/","link":"","permalink":"http://ligangit.com/2020/07/16/Redis-发布订阅/","excerpt":"","text":"Redis-发布订阅是什么进程间的一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接收消息。 订阅/发布消息图 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： 发布订阅命令 PSUBSCRIBE pattern pattern …] 订阅一个或多个符合给定模式的频道。 PUBSUB subcommand [argument [argument …]] 查看订阅与发布系统状态。 PUBLISH channel message 将信息发送到指定的频道。 PUNSUBSCRIBE [pattern [pattern …]] 退订所有给定模式的频道。 SUBSCRIBE channel [channel …] 订阅给定的一个或多个频道的信息。 UNSUBSCRIBE [channel [channel …]] 指退订给定的频道。 案例先订阅后发布后才能收到消息； 可以一次性订阅多个，SUBSCRIBE c1 c2 c3 消息发布，PUBLISH c2 hello-redis 订阅多个，通配符，PSUBSCRIBE new\\ 收取消息，PUBLISH new1 redis2020","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/categories/Redis/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"},{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://ligangit.com/tags/缓存/"}]},{"title":"Redis-事务","slug":"Redis-事务","date":"2020-07-16T08:15:09.000Z","updated":"2020-07-18T13:45:08.785Z","comments":true,"path":"2020/07/16/Redis-事务/","link":"","permalink":"http://ligangit.com/2020/07/16/Redis-事务/","excerpt":"","text":"Redis-事务是什么Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序执行。事务在执行的过程中，不会被其他客户端发送来的命令请求打断。 Redis事务的主要作用就是串联多个命令防止别的命令插队。 可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其他命令插入，不许加塞 一个队列中，一次性、顺序性、排他性的执行一系列命令。 Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证： 批量操作在发送 EXEC 命令前被放入队列缓存。 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。 注意： ​ 如果命令入队操作有报错，那么整个事务都不会执行成功； ​ 如果命令入队操作没有报错，但是执行阶段，执行事务的某条语句有问题，这时，其他命令正常执行，只有有误的命令才会不成功。 ​ 就像是java程序，命令入队像编译操作，执行事务像运行程序，编译有问题，那么不会运行程序，编译成功后，有条语句int a=10/0，那么运行时会报错，但是程序依旧运行了。 ​ 即不保证原子性：redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。 ​ 因此：redis支持部分事务 3阶段一个事务从开始到执行会经历以下三个阶段： 开始事务 ：以multi开始一个事务 命令入队 ：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面 执行事务 ：由exec命令触发事务 常用命令 DISCARD 取消事务，放弃执行事务块内的所有命令。 EXEC 执行所有事务块内的命令。 MULTI 标记一个事务块的开始 。 UNWATCH 取消 WATCH 命令对所有 key 的监视。 WATCH key [key …] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 WATCH监控悲观锁悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。 乐观锁乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁使用于多读的应用类型，这样可以提高吞吐量。 乐观锁策略：提交版本必须大于记录当前版本才能执行更新。 WATCH和UNWATCHWATCH key [key…] 在执行multi（开始事务）之前，先执行watch key1 [key2]，可以监视一个（或多个）key，如果在事务执行之前这个（或这些）key被其他命令所改动，那么事务将被打断。 通过watch命令在事务执行之前监控了多个keys，倘若在watch之后有任何key的值发生了变化，exex命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。 UNWATCH 取消 WATCH 命令对所有 key 的监视。 3个特性 单独的隔离操作 事务中的所有命令都会序列化、按顺序执行。事务在执行的过程中，不会被其他客户端发送来的命令请求打断。 没有隔离级别的概念 队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题。 不保证原子性 redis同一个事务中，如果都所有命令入队成功，但是执行事务时有一条命令执行失败，事务中的其他命令任然会被执行，没有回滚。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/categories/Redis/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"},{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://ligangit.com/tags/缓存/"}]},{"title":"Redis-持久化之AOF","slug":"Redis-持久化之AOF","date":"2020-07-16T03:46:58.000Z","updated":"2020-07-18T16:01:43.390Z","comments":true,"path":"2020/07/16/Redis-持久化之AOF/","link":"","permalink":"http://ligangit.com/2020/07/16/Redis-持久化之AOF/","excerpt":"","text":"Redis-持久化之AOF（Append Only File）是什么以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。 备份文件信息 AOF保存的是appendonly.aof文件 保存路径： 默认在redis的安装目录下 config get dir 获取aof文件保存目录 获取备份文件： 先通过config get dir 查询aof文件目录 将*.aof的文件拷贝到别的地方 配置配置位置：APPEND ONLY MODE appendonly 是否打开AOF持久化 默认为no appendfilename 持久化后文件名称（备份文件名称） 默认为appendonly.aof appendfsync always：同步持久化 每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好 everysec：出厂默认推荐，异步操作，每秒记录 如果一秒内宕机，有数据丢失 no： 不主动进行同步，把同步时机交给操作系统，由操作系统自动调度刷磁盘 no-appendfsync-on-rewrite 重写时是否可以运用appendfsync，用默认no即可，保证数据安全性 auto-aof-rewrite-percentage 设置重写的基准值 当前aof文件触发Rewrite时必须大于等于上次Rewrite后aof文件大小的多少倍 auto-aof-rewrite-min-size 设置重写的基准值 当前aof文件触发Rewrite的最小文件大小 AOF启动、修复、恢复正常恢复 启动：appendonly设置为yes 修改默认的appendonly no，改为yes 将有数据的aof文件复制一份保存到对应目录（config get dir） 恢复：重启redis然后重新加载 异常恢复 启动：appendonly设置为yes 修改默认的appendonly no，改为yes 备份被写坏的aof文件 修复：redis-check-aof –fix appendonly.aof进行恢复 恢复：重启redis然后重新加载 Rewrite（重写机制）是什么AOF采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集，可以使用命令bgrewriteaof 重写原理AOF文件持续增长而过大时，会fork出一条新进程来将文件重写（也是先写临时文件最后再rename），遍历新进程的内存中的数据，每条记录有一条set语句。重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。 触发机制 重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定redis需要满足一定条件才会进行重写。 系统载入时或者上一次重写完毕是，Redis会记录此时aof文件的大小，设为base_size，如果Redis的aof当前大小&gt;=base_size+base_size*100%(默认)且当前大小&gt;=64mb(默认)的情况下，Redis会对aof文件进行重写。 Redis会记录上一次重写时的aof大小，默认配置是当aof文件大小是上次rewrite后大小的一倍且文件大于64M时触发 AOF的优缺点优势 备份机制更稳健，丢失数据概率更低 每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差，但数据完整性比较好 每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失 不同步：appendfsync no 从不同步 可读的日志文件，通过操作aof文件，可以处理误操作（虽然rdb也可以，但是rdb不容易读） 劣势 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同 每次读写都同步的话，有一定的性能压力(每修改同步：appendfsync always) 存在个别BUG，造成恢复不成功 同时开启两种持久化方式在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据。 因为在通常情况下AOF文件保存的数据集要不RDB文件保存的数据集要完整。 RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。 那要不要只使用AOF呢？ 作者建议不要， 因为RDB更适合用于备份数据库（AOF在不断变化不好备份）， 快速重启，而且不会有AOF可能潜在的BUG，留一个作为万一的手段。 总结AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。 Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。 aof文件是一个只进行追加的日志文件 redis可以在aof文件体积变得过大时，自动地在后台对aof进行重写 aof文件有序地保存了对数据库执行的所有写入操作，这些写入操作以redis协议的格式保存，因此aof文件的内容非常容易被人读懂，对文件分析也很轻松 对于相同的数据集来说，aof文件的体积通常要大于rdb文件的体积 根据所使用的fsync策略，aof的速度可能会慢于rdb","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/categories/Redis/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"},{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://ligangit.com/tags/缓存/"}]},{"title":"Redis-持久化之RDB","slug":"Redis-持久化之RDB","date":"2020-07-15T09:45:09.000Z","updated":"2020-07-18T15:36:49.140Z","comments":true,"path":"2020/07/15/Redis-持久化之RDB/","link":"","permalink":"http://ligangit.com/2020/07/15/Redis-持久化之RDB/","excerpt":"","text":"Redis-持久化之RDB（Redis DataBase）是什么RDB（Redis DataBase） 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。 Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。 如果需要进行大规模数据的恢复，且对数据恢复的完整性不是很敏感，那么RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。 Forkfork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。 备份文件信息 Rdb默认保存的是dump.rdb文件 保存路径： 默认在redis的安装目录下 config get dir 获取rdb文件保存目录 获取备份文件： 先通过config get dir 查询rdb文件目录 将*.rdb的文件拷贝到别的地方 配置配置位置：SNAPSHOTTING save save 秒钟 写操作次数 示例： 是1分钟内改了1万次 或5分钟内改了10次 或15分钟内改了1次 123save 60 10000 save 300 10 save 900 1 stop-writes-on-bgsave-error 备份出现错误时停止写入redis 如果配置成no，表示你不在乎数据不一致或者有其他的手段发现和控制 rdbcompression 对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭功能。 rdbchecksum 在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。 dbfilename 快照存储名称（备份文件名称） 默认为dump.rdb dir 目录（默认是执行redis启动命令时所在的目录），也是rdb文件保存目录 config get dir 获取目录 如何触发RDB快照（备份）触发RDB快照的方式 触发配置文件中默认的快照配置，自动保存 123save 900 1save 300 10save 60 10000 手动保存快照：命令save或者是bgsave Save：save时只管保存，其他不管，全部阻塞。 BGSAVE：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。 可以通过lastsave命令获取最后一次成功执行快照的时间。 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。 执行shutdown命令（正常关闭redis），也会产生dump.rdb文件，里面有数据。 备份（保存）策略（save） 方式一：save 秒钟 写操作次数 是1分钟内改了1万次 save 60 10000 或5分钟内改了10次 save 300 10 或15分钟内改了1次 save 900 1 方式二：禁用自动备份（立即备份） 如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。 停止备份动态所有停止RDB保存规则的方法：redis-cli config set save “” 如何恢复正常恢复 将备份文件（dump.rdb）移动到redis安装目录并启动服务即可 冷拷贝后重新使用，可以cp dump.rdb dump_new.rdb config get dir获取目录 异常恢复 将被写坏的文件（dump.rdb）移动到redis安装目录 备份被写坏的文件（dump.rdb） 修复：redis-check-dump –fix进行恢复 恢复：重启redis然后重新加载 RDB优缺点优势 适合大规模的数据恢复 对数据完整性和一致性要求不高 劣势 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改； Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。 同时开启两种持久化方式在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据。 因为在通常情况下AOF文件保存的数据集要不RDB文件保存的数据集要完整。 RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。 那要不要只使用AOF呢？ 作者建议不要， 因为RDB更适合用于备份数据库（AOF在不断变化不好备份）， 快速重启，而且不会有AOF可能潜在的BUG，留一个作为万一的手段。 总结RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。 RDB是一个非常紧凑的文件； RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能； 与AOF相比，在恢复大的数据集的时候，RDB方式会更快一些。 数据丢失风险大 RDB需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候，fork的过程是非常耗时的，可能会导致redis在一些毫秒级不能响应客户端请求。","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/categories/Redis/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"},{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://ligangit.com/tags/缓存/"}]},{"title":"Redis学习","slug":"Redis学习","date":"2020-07-14T06:59:03.000Z","updated":"2020-07-17T15:39:10.565Z","comments":true,"path":"2020/07/14/Redis学习/","link":"","permalink":"http://ligangit.com/2020/07/14/Redis学习/","excerpt":"","text":"Redis学习笔记什么是RedisREmote DIctionary Server（远程字典服务器） 是一个高性能的（key/value）分布式内存数据库，基于内存运行并支持持久化的NoSQL数据库。 特点： 支持数据的持久化 支持key-value、list、set、zset、hash等数据结构的存储 支持数据备份，即master-salve模式的数据备份 能干什么 内存存储和持久化：redis支持异步将内存中数据写到硬盘上，同时不影响继续服务。 取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面 模拟类似与HttpSession这种需要设定过期时间的功能 发布、订阅消息系统 定时器、计数器 其他 单进程 默认16个数据库，类似数组下标从零开始，初始默认使用零号库 select命令切换数据库 dbsize查看当前数据库的key的数量 flushdb：清空当前库 flushall：清空全部库 统一密码管理：16个库都是同样密码，要么都OK要么一个也连接不上 redis索引都是从零开始 默认端口是6379 常用五大数据类型 String（字符串） 是Redis最基本的类型，一个key对应一个value； 是二进制安全的，即Redis的String可以包含任何数据，比如jpg图片或者序列化对象； 是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M。 Hash（哈希，蕾西java里的Map） 是一个键值对集合 是一个String类型的field和value的映射表，Hash特别适合用于存储对象 类似Java里面的Map&lt;String,Object&gt; List（列表） 是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或尾部（右边） 底层实际是一个链表 Set（集合） 是String类型的无序、无重复集合，它是通过HashTable实现的 Zset（sorted set：有序集合） 和set一样也是String类型元素的集合，且不允许重复的成员 不同的是每个元素都会关联一个double类型的分数 Redis通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数（score）却可以重复 Redis常见数据类型操作命令 http://redisdoc.com/ 应用场景 配合关系型数据库做高速缓存 高频次，热门访问的数据，降低数据库IO 分布式架构，做session共享 由于其拥有持久化能力，利用其多样的数据结构存储特定的数据 最新N个数据（通过List实现按自然时间排序的数据） 排行榜，Top N（利用zset（有序集合）） 时效性的数据，比如手机验证码（Expire 过期） 计数器、秒杀（原子性，自增方法incr、decr） 去除大量数据中的重复数据（利用set集合） 构建队列（利用list列表） 发布订阅消息系统（pub/sub模式） windows使用cmd启动Rediswidows启动 打开cmd，进入redis目录，其中配置文件为 redis.windows.conf ，执行如下命令 redis-server redis.windows.conf 如果配置文件在其他目录下，配置文件所在路径：D:/reidsmy/redis6379.conf，执行如下命令 redis-server D:/reidsmy/redis6379.conf 进入redis命令行 再打开一个cmd，进入redis目录，执行如下命令 redis-cli.exe -h 127.0.0.1 -p 6379 或执行 redis-cli -p 6379 Linux启动Redis启动 备份redis.conf：拷贝一份redis.conf到其他目录，如移动到 /myredis/redis.conf 修改redis.conf文件，将里面的daemonize no 改成 yes，让服务在后台启动 启动命令：执行 redis-server /myredis/redis.conf 打开客户端：redis-cli 多个端口可以： redis-cli -p 6379 单个端口还可以：redis-cli 或 redis-cli -p 6379 *显示中文：redis-cli –raw 或 redis-cli -p 6379 –raw * 测试验证：ping 关闭服务器 单实例关闭： redis-cli shutdown 也可以进入终端后关闭 多实例关闭： 指定端口关闭：redis-cli -p 6379 shutdown 只关闭客户端和客户端 直接在客户端输入exit 使用Ctrl+C快捷键 Redis目录结构 redis-benchmark 性能测试工具（服务启动起来后执行） redis-check-aof 修复有问题的aof文件 redis-check-dump 修复有问题的dump.rdb文件 redis-sentinel redis集群使用（哨兵） redis-server redis服务器启动命令 redis-cli redis客户端，操作入口","categories":[{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/categories/Redis/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"},{"name":"Redis","slug":"Redis","permalink":"http://ligangit.com/tags/Redis/"},{"name":"缓存","slug":"缓存","permalink":"http://ligangit.com/tags/缓存/"}]},{"title":"NoSQL学习","slug":"NoSQL学习","date":"2020-07-14T01:47:03.000Z","updated":"2020-07-17T09:26:55.662Z","comments":true,"path":"2020/07/14/NoSQL学习/","link":"","permalink":"http://ligangit.com/2020/07/14/NoSQL学习/","excerpt":"","text":"NoSQL学习为什么用NoSQL如今我们可以通过第三方平台可以很容易的访问和抓取数据。用户个人信息，社交网站，地理位置，用户生成的数据和用户操作日志已经成倍的增加，我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了，NoSQL数据库的发展却能很好的处理这些大的数据。在云计算、大数据分析、数据量级的飞速暴增，传统的SQL数据库难以支撑目前的业务，所以需要使用NoSQL数据库。 是什么NoSQL(NoSQL=Not Only SQL)，即”不仅仅是SQL“，泛指非关系型数据库，例如谷歌或Facebook每天为他们的用户收集万亿比特的数据，这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 特性易扩展NoSQL数据库种类繁多，但是有一个共同的特点都是去掉关系型数据库的关系型特性。 数据之间无关系，这样就非常容易扩展，也无形之间，在架构的层面上带来了可扩展的能力。 大数据量高性能NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。 这得益于它的无关系性，数据库的结构简单。 多样灵活的数据模型NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系型数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直是一个噩梦。 传统RDBMS VS NoSQLRDBMS 高度组织化结构化数据 结构化查询语句（SQL） 数据和关系都存储在单独的表中 数据操纵语言，数据定义语言 严格的一致性 基础事务 NoSQL 代表着不仅仅是SQL 没有声明性查询语言 没有预定义的模式 键 - 值对存储，列存储，文档存储，图形数据库 最终一致性，而非ACID属性 非结构化和不可预知的数据 CAP定理 高性能，高可用性和可伸缩性 3V+3高 大数据时代的3V 海量Volume 多样Variety 实时Velocity 互联网需求的3高 高并发 高可用 高性能 NoSQL数据模型 传统关系型数据库： ER图（1:1/1:N/N:M，主外键等） NoSQL：聚合模型 KV键值对 Bson 列族 图形 BSON是一种类json的一种二进制形式的存储格式，简称Binary JSON,它和JSON一样，支持内嵌的文档对象和数组对象 NoSQL数据库的四大分类 KV键值：redis 文档型数据库（bson格式比较多）：MongoDB 列存储数据库：HBase、Cassandra、分布式文件系统 图关系数据库：Neo4J、InfoGrid 分布式数据库中CAP原理+BASE CAP C：Consistency（强一致性） A：Availability（可用性） P：Partition tolerance（分区容错性） CAP的3进2 一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。 在分布式存储系统中，分区容忍性是我们必须需要实现的，所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点 BASE 基本可用（Basically Available） 软状态（Soft state） 最终一致（Eventually consistent） 常用NoSQL数据库 Memcached 很早出现的NoSQL数据库 数据存在内存中，一般不持久化 支持简单的key-value模式 一般是作为缓存数据库辅助持久化的数据库 使用多线程+锁 Redis 几乎覆盖了Memcached的绝大部分功能 数据都在内存中，支持持久化，主要用作备份恢复 支持key-value模式，还支持list、set、hash、zset等 一般是作为缓存数据库辅助持久化的数据库 使用单线程+多路IO复用 Mongdb 高性能、开源、模式自由（schema free）的文档型数据库 数据都在内存中，如果内存不足，Mongdb是一个环形队列，支持先进先出，最先进来的数据先被覆盖 虽然是key-value模式，但是对value（尤其是json）提供把不常用的数据保存到硬盘，有丰富的查询功能 支持二进制数据及大型对象 可以根据数据的特点替代RDBMS，成为独立的数据库。或者配合RDBMS HBase 是Hadoop项目中的数据库。用于需要对大量的数据进行随机、实时的读写操作的场景中。 HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可以处理有数百万列元素的数据表 Cassandra 一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集（数据量通常达到PB级别） 最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程 Neo4j 主要应用：社会关系，公共交通网络，地图及网络拓扑 应用场景适用场景 对数据高并发的读写 海量数据的读写 对数据高可扩展性的 不适用场景 需要事务支持 基于sql的结构化查询存储，处理复杂的关系，需要即席查询（条件查询） 用不着sql的和用了sql也不行的情况，请考虑NoSQL","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://ligangit.com/tags/NoSQL/"}]},{"title":"SSM三大框架整合","slug":"SSM三大框架整合","date":"2020-07-11T16:07:06.000Z","updated":"2020-07-13T15:02:09.659Z","comments":true,"path":"2020/07/12/SSM三大框架整合/","link":"","permalink":"http://ligangit.com/2020/07/12/SSM三大框架整合/","excerpt":"","text":"SSM三大框架整合 Spring+SpringMVC+MyBatis ，利用Spring整合SpringMVC和MyBatis 。 1. 创建数据库和表结构SQL语句 2. 创建maven工程引入坐标依赖 创建ssm_parent父工程（打包方式选择pom，必须的） 创建ssm_web子模块（打包方式是war包） 创建ssm_service子模块（打包方式是jar包） 创建ssm_dao子模块（打包方式是jar包） 创建ssm_domain子模块（打包方式是jar包） web依赖于service，service依赖于dao，dao依赖于domain 在ssm_parent的pom.xml文件中引入坐标依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3. 创建对应的目录结构 4. 配置Spring编写Spring配置文件applicationContext.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--开启注解扫描 希望处理service和dao，但是controller不需要Spring框架去处理--&gt; &lt;context:component-scan base-package=\"com.ligangit\"&gt; &lt;!--配置controller不扫描--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; 将AccountServiceImpl.java添加到容器，测试 12345678910111213@Service(value = \"accountService\")public class AccountServiceImpl implements AccountService &#123; @Override public List&lt;Account&gt; findAll() &#123; System.out.println(\"service层，查询所有账户。。。\"); return null; &#125; @Override public void saveAccount(Account account) &#123; System.out.println(\"service层，保存账户信息。。。\"); &#125;&#125; 测试 1234567891011// 测试Spring框架 @Test public void testSpring1()&#123; // 加载配置文件 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:applicationContext.xml\"); // 获取对象 AccountService accountService = (AccountService) applicationContext.getBean(\"accountService\"); // 调用方法 accountService.findAll(); &#125; 5. 配置SpringMVC 在web.xml中配置前端控制器DispatcherServlet 1234567891011121314151617&lt;!--配置前端控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--设置配置文件路径--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--设置项目启动时DispatcherServlet加载一次--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!--表示任意请求都会经过servlet--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 在web.xml中配置过滤器解决中文乱码 12345678910111213&lt;!--配置解决中文乱码的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 编写Springmvc的配置文件springmvc.xml 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=\"com.ligangit\"/&gt; &lt;!--视图解析器--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--配置文件解析器 id值必须是multipartResolver --&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--设置上传文件最大10M，即10*1024*1024=10485760--&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt; &lt;/bean&gt; &lt;!--前端控制器，哪些静态资源不拦截--&gt; &lt;mvc:resources mapping=\"/js/**\" location=\"/js/\"&gt;&lt;/mvc:resources&gt; &lt;mvc:resources mapping=\"/css/**\" location=\"/css/\"&gt;&lt;/mvc:resources&gt; &lt;!--开启SpringMVC框架注解支持--&gt; &lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;&lt;/beans&gt; 测试SpringMVC的框架是否搭建成功 编写index.jsp和list.jsp，编写超链接 1&lt;a href=\"account/findAll\"&gt;测试SpringMVC&lt;/a&gt; 创建AccountController类，编写方法，进行测试 123456789@Controller@RequestMapping(\"/account\")public class AccountController &#123; @RequestMapping(\"/findAll\") public String findAll()&#123; System.out.println(\"Controller查询所有账户...\"); return \"list\"; &#125;&#125; 6. Spring整合SpringMVC框架 目的：在Controller中能成功的调用Service对象中的方法。 在项目启动的时候，就去加载Spring的配置文件applicationContext.xml，在web.xml中配置ContextLoaderListener监听器（该监听器只能加载WEB-INF目录下的applicationContext.xml配置文件） 123456789&lt;!--配置Spring的监听器 默认只加载WEB-INF目录下的applicationContext.xml配置文件--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--设置配置文件的路径--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 7. 配置Mybatis 编写dao层的SQL 12345678public interface AccountDao &#123;// 查询所有账户 @Select(\"select * from account\") public List&lt;Account&gt; findAll();// 保存账户信息 @Insert(\"insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)\") public void saveAccount(Account account);&#125; 在web项目中编写MyBatis配置文件mybatis-config.xml，characterEncoding设置编码格式 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD SQL Map Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default=\"mysql\"&gt; &lt;environment id=\"mysql\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///ssm?characterEncoding=utf8\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射配置文件--&gt; &lt;mappers&gt; &lt;!--&lt;mapper class=\"com.ligangit.dao.AccountDao\"/&gt;--&gt; &lt;package name=\"com.ligangit.dao\"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 测试 注意：添加、修改、删除操作需要提交事务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 测试查询 */@Testpublic void testMybatis() throws IOException &#123; //加载配置文件 InputStream inputStream = Resources.getResourceAsStream(\"mybatis/mybatis-config.xml\");// 创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession();// 获取到代理对象 AccountDao accountDao = sqlSession.getMapper(AccountDao.class); //查询所有数据 List&lt;Account&gt; accountList = accountDao.findAll(); for (Account account:accountList)&#123; System.out.println(account); &#125; //关闭资源 sqlSession.close(); inputStream.close();&#125;/** * 测试保存 */@Testpublic void testMybatis2() throws IOException &#123; Account account=new Account(); account.setName(\"小白\"); account.setMoney(400d); //加载配置文件 InputStream inputStream = Resources.getResourceAsStream(\"mybatis/mybatis-config.xml\"); // 创建SqlSessionFactory对象 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //创建SqlSession对象 SqlSession sqlSession = sqlSessionFactory.openSession(); // 获取到代理对象 AccountDao accountDao = sqlSession.getMapper(AccountDao.class); //保存 accountDao.saveAccount(account); //提交事务 sqlSession.commit(); //关闭资源 sqlSession.close(); inputStream.close();&#125; 结果 8. Spring整合Mybatis框架在Spring配置文件applicationContext.xml中配置Mybatis 12345678910111213141516&lt;!--Spring整合Mybatis框架--&gt;&lt;!--配置连接池--&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm?characterEncoding=utf8\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置SqlSessionFactory工厂--&gt;&lt;bean id=\"sessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--配置AccountDao接口所在包--&gt;&lt;bean id=\"mapperScannerConfigurer\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.ligangit.dao\"/&gt;&lt;/bean&gt; 将dao注入容器 12@Repositorypublic interface AccountDao &#123; service层调用dao 123456789101112131415@Service(value = \"accountService\")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public List&lt;Account&gt; findAll() &#123; System.out.println(\"service层，查询所有账户。。。\"); return accountDao.findAll(); &#125; @Override public void saveAccount(Account account) &#123; System.out.println(\"service层，保存账户信息。。。\"); accountDao.saveAccount(account); &#125;&#125; MyBatis配置文件mybatis-config.xml可以删除了 9. Spring整合Mybatis框架配置事务配置Spring框架声明式事务管理,用于添加、修改、删除操作提交。 在Spring配置文件applicationContext.xml中配置声明式事务管理。 12345678910111213141516&lt;!--配置Spring框架声明式事务管理,用于添加、修改、删除操作提交--&gt;&lt;!--配置事务管理器--&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--配置事务通知--&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"find*\" read-only=\"true\"/&gt; &lt;tx:method name=\"*\" isolation=\"DEFAULT\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--配置AOP增强--&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut=\"execution(* com.ligangit.service.impl.*ServiceImpl.*(..))\"/&gt;&lt;/aop:config&gt; 测试： ​ jsp页面： 12345678&lt;a href=\"account/findAll\"&gt;测试SpringMVC&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;form action=\"account/saveAccount\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"name\" /&gt;&lt;/br&gt; 金额：&lt;input type=\"text\" name=\"money\" /&gt;&lt;/br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; ​ 控制器代码： 1234567891011121314151617181920212223242526272829@Controller@RequestMapping(\"/account\")public class AccountController &#123; @Autowired AccountService accountService; /** * 查询所有账户 */ @RequestMapping(\"/findAll\") public String findAll(Model model)&#123; System.out.println(\"Controller查询所有账户...\"); // 调用service的方法 List&lt;Account&gt; accountList = accountService.findAll(); model.addAttribute(\"list\", accountList); return \"list\"; &#125; /** * 保存账户 */ @RequestMapping(\"/saveAccount\") public void saveAccount(Account account, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; System.out.println(\"Controller保存账户...\"); // 调用service的方法 accountService.saveAccount(account); response.sendRedirect(request.getContextPath()+\"/account/findAll\"); return; &#125;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://ligangit.com/tags/SpringMVC/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://ligangit.com/tags/MyBatis/"}]},{"title":"SpringMVC-拦截器","slug":"SpringMVC-拦截器","date":"2020-07-11T14:56:27.000Z","updated":"2020-07-11T16:04:58.898Z","comments":true,"path":"2020/07/11/SpringMVC-拦截器/","link":"","permalink":"http://ligangit.com/2020/07/11/SpringMVC-拦截器/","excerpt":"","text":"SpringMVC中的拦截器和Servlet中的过滤器什么是过滤器过滤器是一个程序，它先于与之相关的servlet或JSP页面运行在服务器上。过滤器可附加到一个或多个servlet或JSP页面上，并且可以检查进入这些资源的请求信息。 什么是拦截器SpringMVC中的处理器拦截器类似过滤器Filter，用于对处理器进行预处理和后处理。 用户可以自定义一些拦截器来实现特定的功能。自定义拦截器，必须实现HandlerInterceptor接口。 它也是AOP思想的具体应用。 谈到拦截器，还有一个词大家应该知道——拦截器链（Interceptor Chain，在Struts2中称为拦截器栈 Interceptor Stack）。拦截器链就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 过滤器和拦截器的区别 过滤器是Servlet规范中的一部分，任何java web工程都可以使用。 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能用。 过滤器在url-pattern中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只会拦截访问的控制器方法，如果访问的是jsp、html、css、image或者js是不会进行拦截的。 拦截器是基于java的反射机制的，而过滤器是基于函数回调。 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次 。 拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。 使用自定义拦截器 编写拦截器类，实现HandlerInterceptor接口 123456789101112131415161718192021222324252627282930313233/** * 自定义拦截器 */public class MyInterceptor implements HandlerInterceptor &#123; /** * 预处理：Controller方法执行之前 * return true 放行，执行下一个拦截器，如果没有，执行Controller中的方法 * return false 不放行 可以使用request、response设置跳转页面、内容 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"MyInterceptor执行了。。。前\"); //request.getRequestDispatcher(\"/response.jsp\").forward(request,response); return true; &#125; /** * 后处理：Controller方法执行之后，success.jsp执行之前 * 可以使用request、response设置跳转页面、内容 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"MyInterceptor执行了。。。后\");// request.getRequestDispatcher(\"/response.jsp\").forward(request,response); &#125; /** * 最后处理：success.jsp执行之后，该方法会执行 * 不可以使用request、response设置跳转页面、内容 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"MyInterceptor执行了。。。最后\"); &#125;&#125; 配置拦截器 在springmvc.xml文件中配置拦截器 123456789101112&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--配置拦截器--&gt; &lt;mvc:interceptor&gt; &lt;!--要拦截的具体方法--&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!--不要拦截的具体方法--&gt; &lt;!--&lt;mvc:exclude-mapping path=\"\"/&gt;--&gt; &lt;!--配置拦截器对象--&gt; &lt;bean class=\"com.ligangit.interceptor.MyInterceptor\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; jsp页面代码 index.jsp 1&lt;br&gt;&lt;%--SpringMVC的拦截器--%&gt;&lt;a href=\"user/testInterceptor\"&gt;SpringMVC的拦截器&lt;/a&gt; success.jsp 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;执行成功！！！！&lt;/h3&gt;&lt;% System.out.println(\"success.jsp执行了。。。。。\"); %&gt;&lt;/body&gt;&lt;/html&gt; 控制器代码 12345678/** * SpringMVC的拦截器 */@RequestMapping(value = \"testInterceptor\")public String testInterceptor()&#123; System.out.println(\"testInterceptor方法执行了。。。\"); return \"success\";&#125; 结果 配置多个拦截器 编写多个拦截器类，实现HandlerInterceptor接口 配置拦截器 在springmvc.xml文件中配置拦截器 123456789101112131415161718192021&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--配置拦截器--&gt; &lt;mvc:interceptor&gt; &lt;!--要拦截的具体方法--&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!--不要拦截的具体方法--&gt; &lt;!--&lt;mvc:exclude-mapping path=\"\"/&gt;--&gt; &lt;!--配置拦截器对象--&gt; &lt;bean class=\"com.ligangit.interceptor.MyInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;!--配置第二个拦截器--&gt; &lt;mvc:interceptor&gt; &lt;!--要拦截的具体方法--&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!--不要拦截的具体方法--&gt; &lt;!--&lt;mvc:exclude-mapping path=\"\"/&gt;--&gt; &lt;!--配置拦截器对象--&gt; &lt;bean class=\"com.ligangit.interceptor.MyInterceptor2\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 结果 hello","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://ligangit.com/tags/SpringMVC/"}]},{"title":"SpringMVC-异常处理","slug":"SpringMVC-异常处理","date":"2020-07-10T01:09:32.000Z","updated":"2020-07-30T02:30:51.616Z","comments":true,"path":"2020/07/10/SpringMVC-异常处理/","link":"","permalink":"http://ligangit.com/2020/07/10/SpringMVC-异常处理/","excerpt":"","text":"SpringMVC的异常处理思路Controller调用service，service调用dao，异常都是向上抛的，最终有DispatcherServlet找异常处理器进行异常的处理。 SpringMVC的异常处理 自定义异常类 1234567891011121314151617/** * 自定义异常类 */public class SysException extends Exception&#123; //存储异常信息的 private String message; @Override public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125; public SysException(String message) &#123; this.message = message; &#125;&#125; 自定义异常处理器 1234567891011121314151617181920212223/** * 自定义异常处理器 */public class SysExceptionResolver implements HandlerExceptionResolver &#123; /** * 处理异常逻辑 */ @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) &#123; // 获取到异常对象 SysException sysException = null; if (e instanceof SysException)&#123; sysException=(SysException)e; &#125;else&#123; sysException = new SysException(\"系统正在维护...\"); &#125; //创建ModelAndView对象 ModelAndView view = new ModelAndView(); view.addObject(\"errorMsg\", sysException.getMessage()); view.setViewName(\"error\"); return view; &#125;&#125; 配置异常处理器（跳转到提示页面） 在springmvc.xml中配置 12&lt;!--配置异常处理器--&gt;&lt;bean id=\"sysExceptionResolver\" class=\"com.ligangit.exception.SysExceptionResolver\"&gt;&lt;/bean&gt; 控制器代码 注意抛出异常 123456789101112131415@RequestMapping(value = \"testException\")public String testException() throws SysException&#123; System.out.println(\"testException方法执行了。。。\"); // try...catch捕获异常 try &#123; //模拟异常 int a=10/0; &#125; catch (Exception e) &#123; //打印异常信息 e.printStackTrace(); // 抛出自定义异常信息 throw new SysException(\"查询所有用户出现错误。。。\"); &#125; return \"success\";&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://ligangit.com/tags/SpringMVC/"},{"name":"异常处理","slug":"异常处理","permalink":"http://ligangit.com/tags/异常处理/"}]},{"title":"SpringMVC-文件上传","slug":"SpringMVC-文件上传","date":"2020-07-06T06:44:50.000Z","updated":"2020-07-09T16:00:52.300Z","comments":true,"path":"2020/07/06/SpringMVC-文件上传/","link":"","permalink":"http://ligangit.com/2020/07/06/SpringMVC-文件上传/","excerpt":"","text":"SpringMVC-文件上传传统方式上传必要前提 form表单的enctype取值必须是multipart/form-data； enctype：是表单请求正文类型； 默认值是application/x-www-form-urlencoded。 method属性取值必须是post 提供一个文件选择域&lt;input type=”file” /&gt; 原理当form表单的enctype取值不是默认值后，request.getParameter()将失效。 enctype=”application/x-www-form-urlencoded”时，form表单的正文内容是： ​ key=value&amp;key=value&amp;key=value enctype=”multipart/form-data”时，请求正文内容就变成： 每一部分都是MIME类型描述的正文 借助第三方组件实现文件上传使用Commons-fileupload组件实现文件上传，需要导入该组件的jar包：commons-fileupload和commons-io。commons-io不属于文件上传组件的开发jar文件，但commons-fileupload组件从1.1版本开始，它工作时需要commons-io包的支持。 代码jsp页面代码： 123456&lt;%--传统方式文件上传--%&gt;&lt;form action=\"user/fileupload1\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件：&lt;input type=\"file\" name=\"upload\"/&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;/form&gt; 控制器代码： 12345678910111213141516171819202122232425262728293031323334353637/** * 文件上传 */@RequestMapping(value = \"fileupload1\")public String fileupload1(HttpServletRequest request) throws Exception &#123; System.out.println(\"文件上传。。。\");// 使用fileupload组件完成文件上传// 上传位置 String realPath = request.getSession().getServletContext().getRealPath(\"/uploads\");// 判断，该路径是否存在File file = new File(realPath);if (!file.exists())&#123; // 创建文件夹 file.mkdirs();&#125;// 解析request对象，获取文件上传项DiskFileItemFactory factory= new DiskFileItemFactory();ServletFileUpload upload = new ServletFileUpload(factory);// 解析request List&lt;FileItem&gt; fileItems = upload.parseRequest(request);// 遍历for (FileItem item : fileItems) &#123; //进行判断，当前item想是否是上传文件项 if(item.isFormField())&#123; //说明普通表单项 &#125;else&#123; // 说明上传文件项 // 获取上传文件的名称 String filename = item.getName(); //完成文件上传 item.write(new File(realPath,filename)); //删除临时文件 item.delete(); &#125;&#125; return \"success\";&#125; 上传结果 SpringMVC方式上传SpringMVC提供了MultipartFile对象，该对象表示上传的文件，要求变量名必须和表单file标签的name属性名称相同。 需要配置文件解析器 配置文件解析器 springmvc.xml配置： 12345&lt;!--配置文件解析器 id值必须是multipartResolver --&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--设置上传文件最大10M，即10*1024*1024=10485760--&gt; &lt;property name=\"maxUploadSize\" value=\"10485760\"/&gt;&lt;/bean&gt; jsp页面代码： 1234567&lt;h3&gt;SpringMVC方式文件上传&lt;/h3&gt;&lt;%--SpringMVC方式文件上传--%&gt;&lt;form action=\"user/fileupload2\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件：&lt;input type=\"file\" name=\"upload\"/&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;/form&gt; 控制器代码： 12345678910111213141516171819202122/** * SpringMVC方式文件上传 */@RequestMapping(value = \"fileupload2\")public String fileupload2(HttpServletRequest request, MultipartFile upload) throws Exception &#123; System.out.println(\"SpringMVC方式文件上传。。。\"); // 上传位置 String realPath = request.getSession().getServletContext().getRealPath(\"/uploads\"); // 判断，该路径是否存在 File file = new File(realPath); if (!file.exists())&#123; // 创建文件夹 file.mkdirs(); &#125; // 获取上传文件的名称 String filename =upload.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename=uuid+\"_\"+filename; //完成文件上传 upload.transferTo(new File(realPath,filename)); return \"success\";&#125; SpringMVC跨服务器方式上传搭建图片服务器： ​ 创建一个新的javaweb工程，使用tomcat启动就可以。 导入开发需要的jar包： 12345678910&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt; jsp页眉代码： 1234567&lt;h3&gt;SpringMVC跨服务器方式文件上传&lt;/h3&gt;&lt;%--SpringMVC跨服务器方式文件上传--%&gt;&lt;form action=\"user/fileupload3\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件：&lt;input type=\"file\" name=\"upload\"/&gt; &lt;br&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;/form&gt; 控制器代码： 12345678910111213141516171819202122/** * SpringMVC跨服务器方式文件上传 */@RequestMapping(value = \"fileupload3\")public String fileupload3(MultipartFile upload) throws Exception &#123; System.out.println(\"SpringMVC跨服务器方式文件上传。。。\"); // 定义上传文件服务器路径 String realPath = \"http://localhost:9090/fileupload_demo_war_exploded/uploads/\"; // 获取上传文件的名称 String filename =upload.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replace(\"-\", \"\"); filename=uuid+\"_\"+filename; //完成文件上传 跨服务器上传 //创建客户端对象 Client client = Client.create();// 和图片服务器进行连接 WebResource webResource = client.resource(realPath + filename); //上传文件 webResource.put(upload.getBytes()); return \"success\";&#125; 可能出现的问题： 关于跨服务器上传报500错误的，并且出现ClientHandlerException等等异常的。 1、先在tomcat文件下conf下的web.xml中添加 1234&lt;init-param&gt;&lt;param-name&gt;readonly&lt;/param-name&gt;&lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt; 修改前： 12345678910111213&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 修改后： 1234567891011121314151617 &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt;&lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 2.在fileupload Module（图片服务器）中，Target的uploads文件夹不能在idea中直接创建，需要打开存储目录下创建uploads文件夹","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://ligangit.com/tags/SpringMVC/"}]},{"title":"SpringMVC-响应数据和结果视图","slug":"SpringMVC-响应数据和结果视图","date":"2020-07-01T15:32:05.000Z","updated":"2020-07-04T16:30:07.833Z","comments":true,"path":"2020/07/01/SpringMVC-响应数据和结果视图/","link":"","permalink":"http://ligangit.com/2020/07/01/SpringMVC-响应数据和结果视图/","excerpt":"","text":"SpringMVC-响应数据和结果视图返回值-Stringjsp页面代码： 1&lt;a href=\"user/testString\"&gt;返回String&lt;/a&gt; jsp成功页面： 123&lt;h3&gt;执行成功！！！！&lt;/h3&gt;$&#123;user.uname&#125;$&#123;user.age&#125; 控制器代码： 123456789101112@RequestMapping(value = \"testString\")public String testString(Model model)&#123;System.out.println(\"testString方法执行了。。。\");// 模拟从数据库查询书User对象User user = new User();user.setUname(\"美美\");user.setAge(18);user.setDate(new Date());// model对象model.addAttribute(\"user\", user);return \"success\";&#125; 结果： 返回值-void默认访问地址默认访问页面 ：”/项目名”+”springmvc.xml视图解析器中配置的前缀”+””访问路径”+”springmvc.xml视图解析器中配置的后缀” 如： ​ 项目名称为：springmvc_demo_war_exploded ​ springmvc视图解析器配置：前缀/WEB-INF/pages/ 后缀：.jsp 12345&lt;!--视图解析器--&gt;&lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; ​ 请求访问地址：user/testVoid 1&lt;a href=\"user/testVoid\"&gt;testVoid&lt;/a&gt; *故默认访问页面为：springmvc_demo_war_exploded/WEB-INF/pages/user/testVoid.jsp * 示例代码： jsp页面代码： 1&lt;a href=\"user/testVoid\"&gt;testVoid&lt;/a&gt; 控制器代码： 1234567/** * void */@RequestMapping(value = \"testVoid\")public void testVoid(Model model)&#123; System.out.println(\"testVoid。。。\");&#125; 使用request跳转页面（请求转发）1234567891011/** * void * 请求转发一次请求，不用编写项目的名称 */@RequestMapping(value = \"testVoid\")public void testVoid(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"testVoid。。。\"); //编写请求转发程序 request.getRequestDispatcher(\"/WEB-INF/pages/success.jsp\").forward(request,response); return;&#125; 使用response跳转页面（重定向）注意：跳转路径需要加项目名称。 1234567891011/** * void * 重定向 */@RequestMapping(value = \"testVoid\")public void testVoid(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"testVoid。。。\"); //重定向 response.sendRedirect(request.getContextPath()+\"/index.jsp\"); return;&#125; 使用response响应输出流1234567891011121314/** * void * 直接运行,输出 */@RequestMapping(value = \"testVoid\")public void testVoid(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"testVoid。。。\"); // 设置中文编码，解决中文乱码 response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=UTF-8\"); //直接运行响应 response.getWriter().print(\"你好\"); return;&#125; 返回值-ModelAndView对象ModelAndView对象是Spring提供的一个对象，可以用来调整具体的JSP视图 控制器代码： 123456789101112131415161718/** * 返回值-ModelAndView */@RequestMapping(value = \"testModelAndView\")public ModelAndView testModelAndView() &#123; ModelAndView mv = new ModelAndView(); System.out.println(\"testModelAndView。。。\"); // 模拟从数据库查询书User对象 User user = new User(); user.setUname(\"美美\"); user.setAge(18); user.setDate(new Date()); //把user对象存储到mv对象中，也会把user对象存入request对象 mv.addObject(\"user\",user); //跳转到哪个页面 mv.setViewName(\"success\"); return mv;&#125; 使用Forward或Redirect进行页面跳转方式一：利用requset和response利用requset和response设置forward和redirect 示例：如上面的返回值void中的示例 请求转发： 1234567891011/** * void * 请求转发一次请求，不用编写项目的名称 */@RequestMapping(value = \"testVoid\")public void testVoid(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"testVoid。。。\"); //编写请求转发程序 request.getRequestDispatcher(\"/WEB-INF/pages/success.jsp\").forward(request,response); return;&#125; 重定向：（跳转路径需要加项目名称） 1234567891011/** * void * 重定向 */@RequestMapping(value = \"testVoid\")public void testVoid(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(\"testVoid。。。\"); //重定向 response.sendRedirect(request.getContextPath()+\"/index.jsp\"); return;&#125; 方式二：直接使用关键字forward和redirect请求转发（forward）： 注意：返回值类型为String。 123456789/** * 使用关键字的方式进行转发或者重定向 */@RequestMapping(value = \"testForwardOrRedirect\")public String testForwardOrRedirect()&#123; System.out.println(\"testForwardOrRedirect方法执行了。。。\"); //重定向 return \"redirect:/index.jsp\";&#125; 重定向（redirect）： 注意：返回值类型为String，跳转路径不需要加项目名称。 123456789/** * 使用关键字的方式进行转发或者重定向 */@RequestMapping(value = \"testForwardOrRedirect\")public String testForwardOrRedirect()&#123; System.out.println(\"testForwardOrRedirect方法执行了。。。\"); //重定向 return \"redirect:/index.jsp\";&#125; 过滤静态资源在SpringMVC配置文件springmvcxml配置前端控制器，设置资源过滤 12&lt;!--前端控制器，哪些静态资源不拦截--&gt;&lt;mvc:resources mapping=\"js/\" location=\"js/**\"&gt;&lt;/mvc:resources&gt; 响应json数据利用ajax jsp页面代码：（引入的jquery文件） 123456789101112131415161718192021222324252627282930&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"js/jquery-1.8.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; //页面加载，绑定点击事件 $(function()&#123; $(\"#btn\").click(function () &#123; // alert(\"hello btn\"); //发送ajax请求 $.ajax(&#123; url:\"user/testAjax\", contentType:\"application/json;charset=UTF-8\", data:'&#123;\"uname\":\"张三\",\"age\":27&#125;', dataType:\"json\", type:\"post\", success:function (data) &#123; //data为服务器端响应额json数据，进行解析 alert(\"hello btn\"); &#125; &#125;); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id=\"btn\"&gt;发送ajax请求&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 引入依赖：（将json格式数据封装成Javabean（实体对象）） 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.10.2&lt;/version&gt;&lt;/dependency&gt; 控制器代码： 12345678@RequestMapping(value = \"testAjax\")public @ResponseBody User testAjax(@RequestBody User user)&#123; System.out.println(\"testAjax方法执行了。。。\"); //客户端发送ajax请求，传的是json字符串，后端把json字符串封装到user对象中 System.out.println(user); user.setUname(\"李四\"); return user;&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://ligangit.com/tags/SpringMVC/"}]},{"title":"SpringMVC-常用注解","slug":"SpringMVC-常用注解","date":"2020-06-30T14:52:16.000Z","updated":"2020-07-01T15:51:21.311Z","comments":true,"path":"2020/06/30/SpringMVC-常用注解/","link":"","permalink":"http://ligangit.com/2020/06/30/SpringMVC-常用注解/","excerpt":"","text":"SpringMVC-常用注解RequestParam使用说明 作用： 把请求中指定名称的参数给控制器中的形参赋值。 属性： value：请求参数中的名称； name：请求参数中的名称；和value一样； required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。 使用示例jsp页面代码： 12&lt;%--常用注解RequestParam--%&gt;&lt;a href=\"anno/testRequestParam?name=你好\"&gt;RequestParam&lt;/a&gt; 控制器代码： 1234567// RequestParam注解示例@RequestMapping(value = \"/testRequestParam\")public String testRequestParam(@RequestParam(value = \"name\") String username)&#123; System.out.println(\"执行了。。。。。\"); System.out.println(username); return \"success\";&#125; RequestBody使用说明 作用： 用于获取请求体内容。直接使用得到的是 key=value&amp;key=value…结构的数据。get请求方式不适用。 属性： required：是否必须有请求体。默认值是：true。当值为true时，get请求方式会报错。如果取值为false，get请求得到的是null。 使用示例jsp页面代码： 123456&lt;%--常用注解RequestBody--%&gt;&lt;form action=\"anno/testRequestBody\" method=\"post\"&gt; 用户姓名：&lt;input type=\"text\" name=\"username\" /&gt;&lt;/br&gt; 用户年龄：&lt;input type=\"text\" name=\"age\" /&gt;&lt;/br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 控制器代码： 1234567// RequestBody注解示例@RequestMapping(value = \"/testRequestBody\")public String testRequestBody(@RequestBody String body)&#123; System.out.println(\"执行了。。。。。\"); System.out.println(body); return \"success\";&#125; 结果： ​ PathVariable使用说明 作用： 用于绑定url中的占位符。例如：请求url中 /delete/{id}，这个{id}就是占位符。url支持占位符是Spring3.0之后加入的，是SpringMVC支持Rest风格URL的一个重要标志。 属性： value：用于指定url中占位符名称； required：是否必须提供占位符。 使用示例jsp页面代码： 12&lt;%--常用注解PathVariable--%&gt;&lt;a href=\"anno/testPathVariable/10\"&gt;PathVariable&lt;/a&gt; 控制器代码： 1234567// PathVariable注解示例@RequestMapping(value = \"/testPathVariable/&#123;sid&#125;\")public String testPathVariable(@PathVariable(name = \"sid\") String id)&#123; System.out.println(\"执行了。。。。。\"); System.out.println(id); return \"success\";&#125; 结果： ​ Restful风格 优点：结构清晰、符合标准、易于理解、扩展方便，所以挣得越来越多网站采用。 RequestHeader使用说明 作用： 用于获取请求消息头。 属性： value：提供消息头名称； required：是否必须有此消息头。 备注：在实际开发中一般不怎么用。 使用示例jsp页面代码： 12&lt;%--常用注解RequestHeader--%&gt;&lt;a href=\"anno/testRequestHeader\"&gt;RequestHeader&lt;/a&gt; 控制器代码： 1234567// PathVariable注解示例 获取@RequestMapping(value = \"/testRequestHeader\")public String testRequestHeader(@RequestHeader(value = \"Accept\") String header)&#123; System.out.println(\"执行了。。。。。\"); System.out.println(header); return \"success\";&#125; CookieValue使用说明 作用： 用于把指定cookie名称的值传入控制器方法参数。 属性： value：指定cookie名称； required：是否必须有此cookie。 使用示例jsp页面代码： 12&lt;%--常用注解CookieValue--%&gt;&lt;a href=\"anno/testCookieValue\"&gt;CookieValue&lt;/a&gt; 控制器代码： 1234567// CookieValue注解示例 获取cookie的值@RequestMapping(value = \"/testCookieValue\")public String testCookieValue(@CookieValue(value = \"JSESSIONID\") String cookieValue)&#123; System.out.println(\"执行了。。。。。\"); System.out.println(cookieValue); return \"success\";&#125; ModelAttribute使用说明 作用： 该注解是SpringMVC4.3版本以后新加入的。它可以修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有返回值的方法。 出现在参数上，获取指定的数据给参数赋值。 属性： value：用于获取数据的key。key可以是POJO的属性名称，也可以是map结构的key。 应用场景： 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 使用示例出现在方法上jsp页面代码： 123456&lt;%--常用注解ModelAttribute--%&gt;&lt;form action=\"anno/testModelAttribute\" method=\"post\"&gt; 用户姓名：&lt;input type=\"text\" name=\"uname\" /&gt;&lt;/br&gt; 用户年龄：&lt;input type=\"text\" name=\"age\" /&gt;&lt;/br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 控制器代码： 12345678910111213141516171819202122232425/** * ModelAttribute注解示例 * 如果参数user记为parUser中有部分数据没有提交，如date，正常会输出date属性值为null * 但是showUser()方法使用了@ModelAttribute注解，返回了user对象记为backUser * 这时，parUser中的date值会使用backUser中的date值， * 即将backUser有的属性但是parUser没有的属性添加到parUser */@RequestMapping(value = \"/testModelAttribute\")public String testModelAttribute(User user)&#123; System.out.println(\"testModelAttribute执行了。。。。。\"); System.out.println(user); return \"success\";&#125;//此方法会先执行 作用在方法上（有返回值）@ModelAttributepublic User showUser(String uname)&#123;System.out.println(\"showUser方法执行了。。。\");// 通过用户查询数据库（模拟）User user = new User();user.setUname(uname);user.setAge(19);user.setDate(new Date());return user;&#125; 说明： 如果参数user记为parUser中有部分数据没有提交，如date，正常会输出date属性值为null； 但是showUser()方法使用了@ModelAttribute注解，返回了user对象记为backUser； 这时，parUser中的date值会使用backUser中的date值； 即将backUser有的属性但是parUser没有的属性添加到parUser。 结果： ​ 提交表单anno/testModelAttribute，得到结果showUser先执行： 出现在参数上控制器代码： 12345678910111213141516171819202122232425/** * ModelAttribute注解示例 * 如果参数user记为parUser中有部分数据没有提交，如date，正常会输出date属性值为null * 但是showUser()方法使用了@ModelAttribute注解，并且将user对象保存在key为\"hello\"的map对象中 * 在此方法的参数前加了@ModelAttribute注解，将key为\"hello\"的map对象取出来，得到showUser()方法中保存的user对象记为backUser * 这时，parUser中的date值会使用backUser中的date值， * 即将backUser有的属性但是parUser没有的属性添加到parUser */@RequestMapping(value = \"/testModelAttribute\")public String testModelAttribute(@ModelAttribute(value = \"hello\") User user)&#123; System.out.println(\"testModelAttribute执行了。。。。。\"); System.out.println(user); return \"success\";&#125;//此方法会先执行 作用在方法上（没有返回值）@ModelAttributepublic void showUser(String uname, Map&lt;String,User&gt; map)&#123; System.out.println(\"showUser方法执行了。。。\"); // 通过用户查询数据库（模拟） User user = new User(); user.setUname(uname); user.setAge(19); user.setDate(new Date()); map.put(\"hello\", user);&#125; 说明： 如果参数user记为parUser中有部分数据没有提交，如date，正常会输出date属性值为null； 但是showUser()方法使用了@ModelAttribute注解，并且将user对象保存在key为”hello”的map对象中； 在此方法的参数前加了@ModelAttribute注解，将key为”hello”的map对象取出来，得到showUser()方法中保存的user对象记为backUser； 这时，parUser中的date值会使用backUser中的date值， 即将backUser有的属性但是parUser没有的属性添加到parUser。 结果： ​ 提交表单anno/testModelAttribute，得到结果showUser先执行： SessionAttributes使用说明 作用： 用于多次执行控制器方法间的参数共享。 属性： value：用于指定存入的属性名称； type：用于指定存入的属性类型。 使用示例jsp页面代码： 12345678&lt;%--常用注解SessionAttributes--%&gt;&lt;a href=\"anno/testSessionAttributes\"&gt;数据存入SessionAttributes&lt;/a&gt;&lt;br&gt;&lt;a href=\"anno/getSessionAttributes\"&gt;使用Model从SessionAttributes取出数据&lt;/a&gt;&lt;br&gt;&lt;a href=\"anno/getSessionAttributes2\"&gt;使用ModelMap从SessionAttributes取出数据&lt;/a&gt;&lt;br&gt;&lt;a href=\"anno/delSessionAttributes\"&gt;清除SessionAttributes数据&lt;/a&gt; 控制器代码：@SessionAttributes作用在类上面 1234567891011121314151617181920212223242526272829303132333435363738@Controller@RequestMapping(value = \"/anno\")@SessionAttributes(value = &#123;\"msg\"&#125;) //把msg=美美存入到session域中public class AnnoController &#123; // SessionAttributes注解示例 存入数据 @RequestMapping(value = \"/testSessionAttributes\") public String testSessionAttributes(Model model)&#123; System.out.println(\"testSessionAttributes执行了。。。。。\"); //底层会存储到request域对象中 model.addAttribute(\"msg\",\"美美\"); return \"success\"; &#125; //使用Model从SessionAttributes中取出数据 @RequestMapping(value = \"/getSessionAttributes\") public String getSessionAttributes(Model model)&#123; System.out.println(\"getSessionAttributes执行了。。。。。\"); //底层会存储到request域对象中 String msg = (String) model.getAttribute(\"msg\"); System.out.println(msg); return \"success\"; &#125; //使用ModelMap从SessionAttributes中取出数据 @RequestMapping(value = \"/getSessionAttributes2\") public String getSessionAttributes2(ModelMap modelMap)&#123; System.out.println(\"getSessionAttributes执行了。。。。。\"); //底层会存储到request域对象中 String msg = (String) modelMap.getAttribute(\"msg\"); System.out.println(msg); return \"success\"; &#125; //清除SessionAttributes中的数据 @RequestMapping(value = \"/delSessionAttributes\") public String delSessionAttributes(SessionStatus status)&#123; System.out.println(\"delSessionAttributes执行了。。。。。\"); status.setComplete(); return \"success\"; &#125;&#125; 结果： ​ 先执行”anno/testSessionAttributes”； ​ 然后执行”anno/getSessionAttributes”； ​ 然后执行”anno/getSessionAttributes2”； ​ 然后执行”anno/delSessionAttributes”； ​ 最后执行”anno/getSessionAttributes”。","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://ligangit.com/tags/SpringMVC/"}]},{"title":"SpringMVC-请求参数的绑定","slug":"SpringMVC-请求参数的绑定","date":"2020-06-29T14:20:45.000Z","updated":"2020-06-30T14:46:29.835Z","comments":true,"path":"2020/06/29/SpringMVC-请求参数的绑定/","link":"","permalink":"http://ligangit.com/2020/06/29/SpringMVC-请求参数的绑定/","excerpt":"","text":"SpringMVC-请求参数的绑定请求参数的绑定说明绑定机制 表单提交的数据都是k=v格式的 username=haha&amp;password=123 SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的 要求：提交表单的name和参数的名称是相同的 示例： ​ 请求URL：hello?username=hehe&amp;pssword=123 ​ 后台代码： 123456@RequestMapping(value = \"/hello\")public String sayHello(String username,String password)&#123;System.out.println(\"Hello SpringMVC\");System.out.println(username+\"::::\"+password); return \"success\";&#125; ​ 注意：参数名username和password必须和URL传递的参数名一样，不然接收不到参数 支持的数据类型 基本数据类型和字符串类型 实体类型（JavaBean） 集合数据类型（List、map集合等） 基本数据类型和字符串类型 提交表单的name和参数的名称是相同的 区分大小写 jsp页面代码:注意form表单中的name属性值 12345&lt;form action=\"hello\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\" /&gt;&lt;/br&gt; 密码：&lt;input type=\"text\" name=\"password\" /&gt;&lt;/br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 后台代码：注意方法的参数名 123456@RequestMapping(value = \"/hello\")public String sayHello(String username,String password)&#123;System.out.println(\"Hello SpringMVC\");System.out.println(username+\"::::\"+password); return \"success\";&#125; 实体类型（JavaBean） 提交的表单的name和JavaBean中的属性名称需要一致 如果一个JavaBean类中包含其他引用类型，那么表单的name属性需要编写成：对象.属性，例如：user.uname 示例： ​ jsp页面代码：注意form表单中的name属性值 12345678&lt;form action=\"saveAccount\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\" /&gt;&lt;/br&gt; 密码：&lt;input type=\"text\" name=\"password\" /&gt;&lt;/br&gt; 金额：&lt;input type=\"text\" name=\"money\" /&gt;&lt;/br&gt; 用户姓名：&lt;input type=\"text\" name=\"user.uname\" /&gt;&lt;/br&gt; 用户年龄：&lt;input type=\"text\" name=\"user.age\" /&gt;&lt;/br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; ​ 后台控制类代码：注意方法的参数名 123456789/** * 请求参数绑定把数据封装到JavaBean的类中 */@RequestMapping(value = \"/saveAccount\")public String saveAccount(Account account)&#123; System.out.println(\"Hello SpringMVC\"); System.out.println(account); return \"success\";&#125; ​ 后台实体代码： ​ Account类：注意类的属性名 123456public class Account implements Serializable &#123; private String username; private String password; private Double money; private User user; ...还有get、set、toString方法 ​ User类：注意类的属性名 1234public class User implements Serializable &#123; private String uname; private int age; ...还有get、set、toString方法 ​ 结果： 集合数据类型与实体类型（JavaBean）基本一致 List封装，使用：list名称[list中序号].list保存对象的属性，参照示例，如：userList[0].uname： ​ userMap[‘one’].uname：userMap是Account类中Map&lt;String,User&gt;的属性名，uname是Account类中Map对象存储的实体User的属性，one表示userMap存储的User对象对应的key。 Map封装，使用：map名称[map保存对象对应的key].map保存对象的属性，参照示例，如：userMap[‘one’].age： ​ userMap[‘one’].uname：userMap是Account类中Map&lt;String,User&gt;的属性名，uname是Account类中Map对象存储的实体User的属性，one表示userMap存储的User对象对应的key。 示例： jsp页面代码:注意form表单中的name属性值 123456789101112&lt;form action=\"saveAccount\" method=\"post\"&gt; 姓名：&lt;input type=\"text\" name=\"username\" /&gt;&lt;/br&gt; 密码：&lt;input type=\"text\" name=\"password\" /&gt;&lt;/br&gt; 金额：&lt;input type=\"text\" name=\"money\" /&gt;&lt;/br&gt; 用户1姓名：&lt;input type=\"text\" name=\"userList[0].uname\" /&gt;&lt;/br&gt; 用户1年龄：&lt;input type=\"text\" name=\"userList[0].age\" /&gt;&lt;/br&gt; 用户2姓名：&lt;input type=\"text\" name=\"userList[1].uname\" /&gt;&lt;/br&gt; 用户2年龄：&lt;input type=\"text\" name=\"userList[1].age\" /&gt;&lt;/br&gt; 用户3姓名：&lt;input type=\"text\" name=\"userMap['one'].uname\" /&gt;&lt;/br&gt; 用户3年龄：&lt;input type=\"text\" name=\"userMap['one'].age\" /&gt;&lt;/br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 后台控制类代码：注意方法的参数名 123456@RequestMapping(value = \"/saveAccount\")public String saveAccount(Account account)&#123; System.out.println(\"Hello SpringMVC\"); System.out.println(account); return \"success\";&#125; 后台实体代码： ​ Account类： 12345678public class Account implements Serializable &#123; private String username; private String password; private Double money; private User user; private List&lt;User&gt; userList; private Map&lt;String,User&gt; userMap; ...还有get、set、toString方法 ​ User类： 1234public class User implements Serializable &#123; private String uname; private int age; ...还有get、set、toString方法 jsp页面输入： 结果： 自定义类型转换器 第一步：定义一个类，实现Converter接口，该接口有两个泛型。 1234567891011121314151617181920/** * 将字符串转换为日期 */public class StringToDate implements Converter&lt;String, Date&gt; &#123;// String s 传进来的字符串 @Override public Date convert(String s) &#123; if (s == null) &#123; throw new RuntimeException(\"请您传入数据！\"); &#125; DateFormat dateFormat = new SimpleDateFormat(\"yyyy-mm-dd\"); // 把字符串转换日期 try &#123; return dateFormat.parse(s); &#125; catch (ParseException e) &#123; e.printStackTrace(); throw new RuntimeException(\"数据类型转换出现错误！\"); &#125; &#125;&#125; 第二步：注册自定义类型转换器，在springmvc配置文件中编写配置 12345678&lt;!--配置自定义类型转换器--&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;bean class=\"com.ligangit.util.StringToDate\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 第三步：让自定义类型转换器生效conversion-service 12&lt;!--开启SpringMVC框架注解支持--&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt; 获取Servlet原生的API只需要在控制器的方法参数定义HttpServletRequest和HttpServletResponse对象。 1234567891011// 原生的ServletAPI@RequestMapping(value = \"/testServlet\")public String testServlet(HttpServletRequest request, HttpServletResponse response)&#123; System.out.println(\"Hello SpringMVC\"); System.out.println(request); HttpSession session = request.getSession(); System.out.println(session); ServletContext servletContext = session.getServletContext(); System.out.println(servletContext); return \"success\";&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://ligangit.com/tags/SpringMVC/"}]},{"title":"SpringMVC学习","slug":"SpringMVC学习","date":"2020-06-27T06:38:08.000Z","updated":"2020-06-29T15:03:38.147Z","comments":true,"path":"2020/06/27/SpringMVC学习/","link":"","permalink":"http://ligangit.com/2020/06/27/SpringMVC学习/","excerpt":"","text":"SpringMVC学习SpringMVC是什么SpringMVC是一种基于Java的实现MV设计模式的请求驱动类型的轻量级Web框架。 SpringMVC和Struts2对比共同点： 都是表现层框架，都是基于MVC模型编写的； 底层都离不开原始ServletAIP； 处理请求的机制都是一个核心控制器。 区别： SpringMVC的入口是Servlet，而Struts2是Filter； SpringMVC是基于方法设计的，而Struts2是基于类，Struts2每次执行都会创建一个动作类，所以SpringMVC会稍微比Struts2快些； SpringMVC使用更加简洁，开发效率SpringMVC更高，同时还支持JSR303，处理Ajax的请求更方便； Struts2的OGNL表达式使页面的开发效率相对比SpringMVC更高些，但执行效率并没有比JSTL提升，尤其是Struts2的表单标签，远没有html执行效率高。 SpringMVC执行流程代码web.xml 1234567891011121314151617&lt;!--配置前端控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--设置配置文件路径--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--设置项目启动时DispatcherServlet加载一次--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!--表示任意请求都会经过servlet--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; springmvc.xml 123456789&lt;!--开启注解扫描--&gt;&lt;context:component-scan base-package=\"com.ligangit\"/&gt;&lt;!--视图解析器--&gt;&lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt;&lt;!--开启SpringMVC框架注解支持--&gt;&lt;mvc:annotation-driven/&gt; HelloController.java 12345678@Controllerpublic class HelloController &#123; @RequestMapping(path = \"/hello\") public String sayHello()&#123; System.out.println(\"Hello SpringMVC\"); return \"success\"; &#125;&#125; index.jsp 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Hello World!&lt;/h3&gt; &lt;a href=\"hello\"&gt;入门程序&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; success.jsp 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;入门成功！&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 启动服务器，加载一些配置文件 DispatcherServlet对象创建 springmvc.xml被加载 HelloController创建成对象 发送请求，后台处理请求 客户端发送Request请求（hello） 前端控制器查找方法，并执行，将返回结果传给视图解析器（InternalResourceViewResolver） 视图解析器根据传递过来的值获取seccess.jsp，返回视图给前端控制器 前端控制器将视图响应给客户端 RequestMapping注解出现位置 类上面： 123@Controller@RequestMapping(path = \"/user\")public class HelloController &#123; 方法上面： 12345@RequestMapping(path = \"/hello\")public String sayHello()&#123;System.out.println(\"Hello SpringMVC\"); return \"success\";&#125; 作用用于建立请求URL和处理请求方法之间的对应关系。 属性 path:用于指定请求的URL。 value:用于指定请求的URL。它和path属性的作用是一样的。 method：用于指定请求的方式。 params：用于指定限制请求参数条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样。 例如： ​ parms={“accountName”}，表示请求参数必须有accountName； ​ params=(“money!100”)，表示请求参数中money不能是100。 headers：用于指定限制请求消息头的条件。 注意：以上四个属性只要出现2个或以上时，他们的关系是与的关系。 示例： 1@RequestMapping(value = \"/hello\", method = &#123;RequestMethod.POST, RequestMethod.GET&#125;, produces = \"text/html;charset=UTF-8\") 配置过滤器解决中文乱码在web.xml中配置过滤器，将编码格式encoding初始化为UTF-8。 12345678910111213&lt;!--配置解决中文乱码的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://ligangit.com/tags/SpringMVC/"}]},{"title":"Spring-事务操作","slug":"Spring-事务操作","date":"2020-06-26T15:54:47.000Z","updated":"2020-06-26T16:04:39.406Z","comments":true,"path":"2020/06/26/Spring-事务操作/","link":"","permalink":"http://ligangit.com/2020/06/26/Spring-事务操作/","excerpt":"","text":"Spring的事务事务的概念什么是事务 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败 典型场景：银行转账 lucy转账100元给mary lucy少100，mary多100 事务四个特性（ACID） 原子性：要么都成功，要么都失败 一致性：操作之前和操作之后总量不变 隔离性：多事务操作时，事务之间不会产生影响 持久性： 该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"}]},{"title":"Spring-JdbcTemplate","slug":"Spring-JdbcTemplate","date":"2020-06-26T11:48:18.000Z","updated":"2020-06-26T15:54:07.006Z","comments":true,"path":"2020/06/26/Spring-JdbcTemplate/","link":"","permalink":"http://ligangit.com/2020/06/26/Spring-JdbcTemplate/","excerpt":"","text":"Spring的JdbcTemplateJdbcTemplate的概念Spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库操作。 准备工作 引入相关的jar包 在Spring配置文件配置数据库连接池 12345678&lt;!-- 数据库连接池 --&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///user_db\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt;&lt;/bean&gt; 配置JdbcTemplate对象，注入DataSource 12345&lt;!--JdbcTemplate对象--&gt;&lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;!--注入DataSource--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; 创建service类，创建dao类，在dao注入jdbcTemplate对象 配置文件 12&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=\"com.ligangit.spring5\"/&gt; service 123456@Servicepublic class BookService &#123; //注入dao @Autowired private BookDao bookDao;&#125; dao 1234567@Repositorypublic class BookDaoImpl implements BookDao&#123; //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate;&#125; JdbcTemplate操作数据库添加 对应数据库创建实体类 1234public class Book &#123; private String bookId; private String bookName; private String bstatus; 编写service和dao 在dao进行数据库添加操作 调用JdbcTemplate对象里面的update方法实现添加操作 update方法有两个参数： 第一个参数：sql语句 第二个参数：可变参数，设置sql语句值 dao代码： 1234567891011121314151617@Repositorypublic class BookDaoImpl implements BookDao&#123; //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; //添加的方法 @Override public void add(Book book) &#123; //1 创建sql语句 String sql = \"INSERT INTO t_book VALUES(?,?,?)\"; //2 调用方法实现 Object[] args = &#123;book.getBookId(), book.getBookName(), book.getBstatus()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(update); &#125;&#125; 测试类 12345678910@Testpublic void testJdbcTemplate()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); BookService bookService = context.getBean(\"bookService\", BookService.class); Book book = new Book(); book.setBookId(\"1\"); book.setBookName(\"java\"); book.setBstatus(\"a\"); bookService.addBook(book);&#125; 修改和删除1234567891011121314151617181920//修改的方法@Overridepublic void updateBook(Book book) &#123; //1 创建sql语句 String sql = \"UPDATE t_book SET bookname=?,bstatus=? WHERE book_id=?\"; //2 调用方法实现 Object[] args = &#123; book.getBookName(), book.getBstatus(),book.getBookId()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(update);&#125;//删除的方法@Overridepublic void deleteBook(String id) &#123; //1 创建sql语句 String sql = \"DELETE FROM t_book WHERE book_id=?\"; //2 调用方法实现 int update = jdbcTemplate.update(sql, id); System.out.println(update);&#125; 查询查询返回某个值如：查询表里面有多少条记录 使用queryForObject方法 1queryForObject(String var1, Class&lt;T&gt; var2) queryForObject方法有两个参数 第一个参数：sql语句 第二个参数：返回类型class 代码 1234567//查询返回某个值@Overridepublic int selectCount() &#123; String sql = \"SELECT COUNT(*) FROM t_book\"; Integer count = jdbcTemplate.queryForObject(sql, Integer.class); return count;&#125; 查询返回对象如：查询图书详情 使用queryForObject方法 1queryForObject(String var1, RowMapper&lt;T&gt; var2, @Nullable Object... var3) queryForObject方法有三个参数 第一个参数：sql语句 第二个参数：RowMapper，是接口，返回不同类型数据，使用这个接口里面实现类完成数据封装 第三个参数：sql语句值 代码 1234567//查询返回对象@Overridepublic Book findBookInfo(String id) &#123; String sql = \"SELECT * FROM t_book WHERE book_id=?\"; Book book = jdbcTemplate.queryForObject(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class), id); return book;&#125; 查询返回集合如：查询图书列表分页… 使用query方法 1query(String var1, RowMapper&lt;T&gt; var2, @Nullable Object... var3) queryForObject方法有三个参数 第一个参数：sql语句 第二个参数：RowMapper，是接口，返回不同类型数据，使用这个接口里面实现类完成数据封装 第三个参数：sql语句值 代码 1234567//查询返回集合@Overridepublic List&lt;Book&gt; findAllBook() &#123; String sql = \"SELECT * FROM t_book\"; List&lt;Book&gt; bookList = jdbcTemplate.query(sql,new BeanPropertyRowMapper&lt;Book&gt;(Book.class)); return bookList;&#125; 批量添加使用batchUpdate方法 1batchUpdate(String var1, List&lt;Object[]&gt; var2) batchUpdate方法有两个参数 第一个参数：sql语句 第二个参数：List集合，添加多条记录数据 代码 123456789//批量添加@Overridepublic void batchAddBook(List&lt;Object[]&gt; batchArgs) &#123; //1 创建sql语句 String sql = \"INSERT INTO t_book VALUES(?,?,?)\"; //2 调用方法实现 int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));&#125; 测试 123456789//批量添加List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();Object[] o1 = &#123;\"5\", \"C语言\", \"a\"&#125;;Object[] o2 = &#123;\"6\", \"Python\", \"b\"&#125;;Object[] o3 = &#123;\"7\", \"Mysql\", \"c\"&#125;;batchArgs.add(o1);batchArgs.add(o2);batchArgs.add(o3);bookService.batchAdd(batchArgs); 批量修改使用batchUpdate方法 1batchUpdate(String var1, List&lt;Object[]&gt; var2) batchUpdate方法有两个参数 第一个参数：sql语句 第二个参数：List集合，添加多条记录数据 代码 1234567//批量修改@Overridepublic void batchUpdateBook(List&lt;Object[]&gt; batchArgs) &#123; String sql = \"UPDATE t_book SET bookname=?,bstatus=? WHERE book_id=?\"; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));&#125; 测试 123456789//批量修改List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();Object[] o1 = &#123; \"C语言001\", \"a5\",\"5\"&#125;;Object[] o2 = &#123; \"Python002\", \"b6\",\"6\",&#125;;Object[] o3 = &#123; \"Mysql005\", \"c7\",\"7\",&#125;;batchArgs.add(o1);batchArgs.add(o2);batchArgs.add(o3);bookService.batchUpdate(batchArgs); 批量删除使用batchUpdate方法 1batchUpdate(String var1, List&lt;Object[]&gt; var2) batchUpdate方法有两个参数 第一个参数：sql语句 第二个参数：List集合，添加多条记录数据 代码 1234567//批量删除@Overridepublic void batchDeleteBook(List&lt;Object[]&gt; batchArgs) &#123; String sql = \"DELETE FROM t_book WHERE book_id=?\"; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints));&#125; 测试 1234567//批量删除List&lt;Object[]&gt; batchArgs = new ArrayList&lt;&gt;();Object[] o1 = &#123;\"5\"&#125;;Object[] o2 = &#123;\"6\",&#125;;batchArgs.add(o1);batchArgs.add(o2);bookService.batchDelete(batchArgs);","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"}]},{"title":"Spring-AOP","slug":"Spring-AOP","date":"2020-06-26T06:26:48.000Z","updated":"2020-06-26T11:25:19.998Z","comments":true,"path":"2020/06/26/Spring-AOP/","link":"","permalink":"http://ligangit.com/2020/06/26/Spring-AOP/","excerpt":"","text":"Spring的AOPAOP的概念面向切面编程。 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 通俗描述：不通过修改源代码，在主干功能里面添加新功能。 使用登录例子说明AOP： AOP底层原理AOP底层使用动态代理 有两种情况动态代理 有接口情况，使用JDK动态代理 创建接口实现类代理对象，通过代理对象增强类的方法 没有接口情况，使用CGLIB动态代理 创建子类的代理对象，通过代理对象增强类的方法 JDK动态代理 使用JDK动态代理，使用Proxy类里面的方法创建代理对象 调用newProxyInstance方法 1newProxyInstance(ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h) 方法有三个参数： ​ 第一个参数：类加载器 ​ 第二个参数：增强方法所在的类，这个类实现的接口，支持多个接口 ​ 第三个参数：实现这个接口InvocationHandler，创建代理对象，写增强部分 编写JDK动态代理代码 第一步：创建接口，定义方法 12345public interface UserDao &#123; public int add(int a, int b); public String update(String id);&#125; 第二步：创建接口实现类，实现方法 1234567891011public class UserDaoImpl implements UserDao&#123; @Override public int add(int a, int b) &#123; return a+b; &#125; @Override public String update(String id) &#123; return id; &#125;&#125; 第三步：使用Proxy类创建接口代理对象 1234567891011121314151617181920212223242526272829303132public class JDKProxy &#123; public static void main(String[] args) &#123; //创建接口实现类代理对象 Class[] interfaces = &#123;UserDao.class&#125;; UserDaoImpl userDao=new UserDaoImpl(); UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); int result = dao.add(1, 2); System.out.println(result); &#125;&#125;//创建代理对象代码class UserDaoProxy implements InvocationHandler&#123; //1、把创建谁的代理对象，把谁传递过来 //有参构造传递 private Object obj; public UserDaoProxy(Object obj)&#123; this.obj=obj; &#125; //增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //方法之前 System.out.println(\"方法之前执行...\"+method.getName()+\"::::传递的参数:::\"+ Arrays.toString(args)); //被增强的方法执行 Object res = method.invoke(obj, args); //方法之后 System.out.println(\"方法之后执行...\"+obj); return res; &#125;&#125; AOP操作术语 连接点 类里面哪些方法可以被增强，这些方法称为连接点 切入点 实际被真正增强的方法，称为切入点 通知（增强） 实际增强的逻辑部分称为通知（增强） 类型有： 前置通知 后置通知 环绕通知 异常通知 最终通知 切面 是动作，把通知应用到切入点的过程 实现AOP准备工作 Spring框架一般都是基于AspectJ实现AOP操作 AspectJ不是Spring组成部分，独立AOP框架，一般把AspectJ和Spring框架一起使用，进行AOP操作 基于AspectJ实现AOP操作 基于xml配置文件实现 基于注解方式实现（使用） 在项目工程里面引入AOP相关依赖 切入点表达式 切入点表达式的作用：知道对哪个类里面的哪个方法进行增强 语法结构：execution([权限修饰符][返回类型][类全路径][方法名称]([参数列表])) 返回类型可以省略 示例1：对com.ligangit.spring5.UserDao类里面的add进行增强 execution(* com.ligangit.spring5.UserDao.add(..)) 示例2：对com.ligangit.spring5.UserDao类里面的所有的方法进行增强 execution(* com.ligangit.spring5.UserDao.*(..)) 示例3：对com.ligangit.spring5包里面所有类，类里面所有方法进行增强 execution(* com.ligangit.spring5.*.*(..)) AspectJ注解方式实现AOP实现AOP 创建类，在类里面定义方法 123456//被增强的类public class User &#123; public void add()&#123; System.out.println(\"add......\"); &#125;&#125; 创建增强类（编写增强逻辑） 在增强类里面，创建方法，让不同方法代表不同通知类型 1234567//增强的类public class UserProxy &#123; //前置通知 public void before()&#123; System.out.println(\"before......\"); &#125;&#125; 进行通知的配置 在Spring配置文件中，开启注解扫描 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=\"com.ligangit.spring5.aopano\"&gt;&lt;/context:component-scan&gt; 使用注解创建User和UserProxy对象 123//被增强的类@Componentpublic class User &#123; 123//增强的类@Componentpublic class UserProxy &#123; 在增强类上面添加注解@Aspect 1234//增强的类@Component@Aspect //生成代理对象public class UserProxy &#123; 在Spring配置文件中，开启生成代理对象 12&lt;!--开启AspectJ生成代理对象--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 配置不同类型的通知 在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置 注意：@AfterReturning有异常时不执行，@After不管有没有异常都执行，@Around环绕后代码有异常时不执行 12345678910111213141516171819202122232425262728293031323334//增强的类@Component@Aspect //生成代理对象public class UserProxy &#123; //前置通知 //@Before注解表示作为前置通知 @Before(value = \"execution(* com.ligangit.spring5.aopano.User.add(..))\") public void before()&#123; System.out.println(\"before......\"); &#125; //后置通知（返回通知）(有异常不执行) @AfterReturning(value = \"execution(* com.ligangit.spring5.aopano.User.add(..))\") public void afterReturning()&#123; System.out.println(\"afterReturning......\"); &#125; //最终通知 @After(value = \"execution(* com.ligangit.spring5.aopano.User.add(..))\") public void after()&#123; System.out.println(\"after......\"); &#125; //异常通知 @AfterThrowing(value = \"execution(* com.ligangit.spring5.aopano.User.add(..))\") public void afterThrowing()&#123; System.out.println(\"afterThrowing......\"); &#125; //环绕通知 @Around(value = \"execution(* com.ligangit.spring5.aopano.User.add(..))\") public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(\"环绕之前......\"); //被增强的方法执行 proceedingJoinPoint.proceed(); System.out.println(\"环绕之后......\"); &#125;&#125; 测试结果 正常执行结果 异常执行结果 相同的切入点抽取1234567891011//相同切入点抽取@Pointcut(value = \"execution(* com.ligangit.spring5.aopano.User.add(..))\")public void pointDemo()&#123; &#125;//前置通知//@Before注解表示作为前置通知@Before(value = \"pointDemo()\")public void before()&#123; System.out.println(\"before......\");&#125; 优先级设置有多个增强类对同一个方法进行增强，设置增强优先级 在增强类上面添加注解@Order(数字类型值)，数字类型值越小，优先级越高 1234@Component@Aspect //生成代理对象@Order(1)public class PersonProxy &#123; 完全使用注解开发创建配置类，不需要创建xml配置文件 12345@Configuration@ComponentScan(basePackages = &#123;\"com.ligangit.spring5\"&#125;)@EnableAspectJAutoProxy(proxyTargetClass = true) //开启AspectJ生成代理对象public class AopConfig &#123;&#125; AspectJ配置文件方式实现AOP 创建两个类，增强类和被增强类，创建方法 在Spring配置文件中创建两个类对象 123&lt;!--创建对象--&gt;&lt;bean id=\"book\" class=\"com.ligangit.spring5.aopxml.Book\"&gt;&lt;/bean&gt;&lt;bean id=\"bookProxy\" class=\"com.ligangit.spring5.aopxml.BookProxy\"&gt;&lt;/bean&gt; 在Spring配置文件中配置切入点 12345678910&lt;!--配置aop增强--&gt;&lt;aop:config&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=\"p\" expression=\"execution(* com.ligangit.spring5.aopxml.Book.buy(..))\"/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref=\"bookProxy\"&gt; &lt;!--增强作用在具体的方法上--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"p\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"}]},{"title":"Spring-Bean的作用域和生命周期","slug":"Spring-Bean的作用域和生命周期","date":"2020-06-25T14:30:56.000Z","updated":"2020-06-25T14:51:17.924Z","comments":true,"path":"2020/06/25/Spring-Bean的作用域和生命周期/","link":"","permalink":"http://ligangit.com/2020/06/25/Spring-Bean的作用域和生命周期/","excerpt":"","text":"Spring-Bean的作用域和生命周期bean的作用域概念：Spring 2.5之前的Bean 的作用域只有两种 Springleton：单例Bean Prototype ： 原型Bean Spring 2.5 之后Bean的作用域有一下五种 作用域 描述 singleton (单例) 使用该属性定义Bean时，IOC容器仅创建一个Bean实例，IOC容器每次返回的是同一个Bean实例。在整个spring ioc 容器中只能创建一个Bean实例 prototype (原型) 使用该属性定义Bean时，IOC容器可以创建多个Bean实例，每次返回的都是一个新的实例。 每次调用都会创建一个bean request (请求) 该属性仅对HTTP请求产生作用，使用该属性定义Bean时，每次HTTP请求都会创建一个新的Bean，适用于WebApplicationContext环境。 session (会话) 该属性仅用于HTTP Session，同一个Session共享一个Bean实例。不同Session使用不同的实例。 global-session (全局) 该属性仅用于HTTP Session，同session作用域不同的是，所有的Session共享一个Bean实例。 在Spring里面，默认情况下，bean是单实例对象 如何设置bean的作用域 在Spring配置文件bean标签里面有属性（scope）用于设置单实例还是多实例 scope属性值 默认值，singleton，表示单实例对象 prototype，表示多实例对象 123&lt;bean id=\"book\" class=\"com.ligangit.spring5.collectionType.Book\" scope=\"prototype\"&gt; &lt;property name=\"list\" ref=\"bookList\"&gt;&lt;/property&gt;&lt;/bean&gt; 1234567891011 @Test public void testCollection2()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean2.xml\"); Book book1 = context.getBean(\"book\", Book.class); Book book2 = context.getBean(\"book\", Book.class);// book.test(); System.out.println(book1); System.out.println(book2); &#125; 测试结果中两个Book对象的地址不相同，说明是两个不同的对象 singleton和prototype的区别 第一：singleton是单实例，prototype是多实例 第二：设置scope值是singleton时候，加载Spring配置文件时就会创建单实例对象；设置scope值是prototype时候，不是在加载Spring配置文件时就会创建对象，在调用getBean方法的时候创建多实例对象。 singleton是在执行如下代码的时候，就会创建单实例对象； 1ApplicationContext context = new ClassPathXmlApplicationContext(\"bean2.xml\"); prototype是在执行如下代码的时候，才会创建多实例对象，每次创建的都是新的对象。 1Book book1 = context.getBean(\"book\", Book.class); scope值是request的时候，创建的对象会放入带request中；scope值是session的时候，创建的对象会放入带session中。 bean的生命周期bean的生命周期 通过构造器创建bean实例（无参构造） 为bean的属性设置值和对其他bean引用（调用set方法） 调用bean的初始化的方法（需要进行配置初始化的方法） bean可以使用了（对象获取到了） 当容器关闭时候，调用bean的销毁方法（需要进行配置销毁的方法） 演示bean的生命周期 实例类 12345678910111213141516171819public class Orders &#123; //无参构造 public Orders()&#123; System.out.println(\"第一步 执行无参构造创建bean示例\"); &#125; private String oname; public void setOname(String oname) &#123; this.oname = oname; System.out.println(\"第二步 调用set方法设置属性值\"); &#125; //创建执行的初始化的方法 public void initMethod()&#123; System.out.println(\"第三步 执行初始化的方法\"); &#125; //创建执行的销毁的方法 public void destroyMethod()&#123; System.out.println(\"第五步 执行销毁的方法\"); &#125;&#125; Spring配置文件配置 123&lt;bean id=\"orders\" class=\"com.ligangit.spring5.bean.Orders\" init-method=\"initMethod\" destroy-method=\"destroyMethod\"&gt; &lt;property name=\"oname\" value=\"手机\"&gt;&lt;/property&gt;&lt;/bean&gt; 测试代码 123456789@Testpublic void testBean4()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean4.xml\"); Orders orders = context.getBean(\"orders\", Orders.class); System.out.println(\"第四步 获取创建bean实例对象\"); System.out.println(orders); //手动让bean实例销毁 ((ClassPathXmlApplicationContext) context).close();&#125; 测试结果 加上bean的后置处理器后，生命周期有七步 通过构造器创建bean实例（无参构造） 为bean的属性设置值和对其他bean引用（调用set方法） 把bean的实例传递给bean后置处理器的方法postProcessBeforeInitialization 调用bean的初始化的方法（需要进行配置初始化的方法） 把bean的实例传递给bean后置处理器的方法postProcessAfterInitialization bean可以使用了（对象获取到了） 当容器关闭时候，调用bean的销毁方法（需要进行配置销毁的方法） 演示添加后置处理器效果 创建类，实现接口BeanPostProcessor，创建后置处理器 12345678910111213public class MyBeanPost implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"在初始化之前执行的方法\"); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"在初始化之后执行的方法\"); return bean; &#125;&#125; 在Spring配置文件中配置后置处理器 配置后置处理器后，会给此配置文件中所有的bean实例添加后置处理器 123456&lt;bean id=\"orders\" class=\"com.ligangit.spring5.bean.Orders\" init-method=\"initMethod\" destroy-method=\"destroyMethod\"&gt; &lt;property name=\"oname\" value=\"手机\"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!--配置后置处理器（会给此配置文件中所有的bean实例添加后置处理器）--&gt;&lt;bean id=\"myBeanPost\" class=\"com.ligangit.spring5.bean.MyBeanPost\"&gt;&lt;/bean&gt; 继续之前的生命周期测试代码，得到结果","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"}]},{"title":"RPC框架学习笔记","slug":"RPC框架学习笔记","date":"2020-06-25T12:20:10.000Z","updated":"2020-07-14T07:59:43.091Z","comments":true,"path":"2020/06/25/RPC框架学习笔记/","link":"","permalink":"http://ligangit.com/2020/06/25/RPC框架学习笔记/","excerpt":"","text":"RPC框架学习基本概念让你像是在做本地调用一样调用远程服务器上的方法 隐藏了底层通信细节 是一个请求响应模型 在形式上像调用本地方法一样调用远程方法 RPC结构","categories":[],"tags":[]},{"title":"Spring-Bean管理","slug":"Spring-Bean管理","date":"2020-06-24T13:50:23.000Z","updated":"2020-06-26T06:25:00.789Z","comments":true,"path":"2020/06/24/Spring-Bean管理/","link":"","permalink":"http://ligangit.com/2020/06/24/Spring-Bean管理/","excerpt":"","text":"Spring中IOC的Bean管理什么是Bean管理Bean管理指的是两个操作 Spring创建对象 Spring注入属性 Bean管理操作的两种实现方式 基于xml配置文件方式实现 基于注解方式实现 基于xml方式实现创建对象12&lt;!--配置User对象创建--&gt;&lt;bean id=\"user\" class=\"com.ligangit.spring5.User\"&gt;&lt;/bean&gt; 在Spring配置文件中，使用bean标签，标签里面添加对应属性，就可以实现对象创建 bean标签常用属性 id属性：唯一标识 class属性：类全路径（包类路径） 创建对象的时候，默认也是执行无参构造方法完成对象创建 ​ 示例：添加有参构造函数，运行测试代码，会报错，提示没有无参构造函数。 1234567891011public class User &#123; private String userName; public User(String userName) &#123; this.userName = userName; &#125; public void add()&#123; System.out.println(\"add..........\"); &#125;&#125; 12345678910111213public class TestSpring5 &#123; @Test public void testAdd()&#123; //1、加载Spring配置文件 ApplicationContext context=new ClassPathXmlApplicationContext(\"bean1.xml\"); //2、获取配置文件创建的对象 User user = context.getBean(\"user\", User.class); System.out.println(user); user.add(); &#125;&#125; ​ 运行结果报错： 注入属性概念DI：依赖注入，就是注入属性。（先创建对象，然后注入属性） 第一种方式：使用set方法注入 创建类，定义属性和对应的set方法 123456789101112public class Book &#123; //创建属性 private String bname; private String bauthor; //创建属性对应的set方法 public void setBname(String bname) &#123; this.bname = bname; &#125; public void setBauthor(String bauthor) &#123; this.bauthor = bauthor; &#125;&#125; 在Spring配置文件配置对象创建，配置属性注入 123456789&lt;!-- set方法注入属性--&gt;&lt;bean id=\"book\" class=\"com.ligangit.spring5.Book\"&gt; &lt;!--使用property完成属性注入 name：类里面属性名称 value：向属性注入的值 --&gt; &lt;property name=\"bname\" value=\"Java核心技术\"&gt;&lt;/property&gt; &lt;property name=\"bauthor\" value=\"霍斯特曼\"&gt;&lt;/property&gt;&lt;/bean&gt; 测试 12345678910@Test public void testBook1()&#123; //1、加载Spring配置文件 ApplicationContext context=new ClassPathXmlApplicationContext(\"bean1.xml\"); //2、获取配置文件创建的对象 Book book = context.getBean(\"book\", Book.class); System.out.println(book); book.tsetDemo(); &#125; 结果 第二种方式：使用有参构造注入 创建类，定义属性，创建属性对应有参构造方法 123456789101112/** * 使用有参构造注入 */public class Orders &#123; private String oname; private String oaddress; public Orders(String oname, String oaddress) &#123; this.oname = oname; this.oaddress = oaddress; &#125;&#125; 在Spring配置文件中进行配置 123456789&lt;!--有参构造注入属性--&gt;&lt;bean id=\"orders\" class=\"com.ligangit.spring5.Orders\"&gt; &lt;!--使用名称--&gt; &lt;constructor-arg name=\"oname\" value=\"联想笔记本\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"oaddress\" value=\"China\"&gt;&lt;/constructor-arg&gt; &lt;!--使用索引 0 第一个参数 1 第二个参数--&gt; &lt;!--&lt;constructor-arg index=\"0\" value=\"联想笔记本\"&gt;&lt;/constructor-arg&gt;--&gt; &lt;!--&lt;constructor-arg index=\"1\" value=\"China\"&gt;&lt;/constructor-arg&gt;--&gt;&lt;/bean&gt; 测试 12345678910@Testpublic void testOrders()&#123; //1、加载Spring配置文件 ApplicationContext context=new ClassPathXmlApplicationContext(\"bean1.xml\"); //2、获取配置文件创建的对象 Orders orders = context.getBean(\"orders\", Orders.class); System.out.println(orders); orders.testOrders();&#125; 结果 p名称空间注入使用p名称空间注入，可以简化基于xml配置方式，还是使用set方式注入。 添加p名称空间添加到配置文件中 xmlns:p=”http://www.springframework.org/schema/p&quot; 1234&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; 进行属性注入，在bean标签里面进行操作 1234&lt;!-- set方法注入属性--&gt;&lt;bean id=\"book\" class=\"com.ligangit.spring5.Book\" p:bname=\"Java核心技术\" p:bauthor=\"霍斯特曼\"&gt; &lt;/bean&gt; 其他类型属性字面量 null值 123456&lt;bean id=\"book\" class=\"com.ligangit.spring5.Book\"&gt; &lt;!--null值--&gt; &lt;property name=\"address\" &gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; &lt;/bean&gt; 属性值包含特殊符号 方式一：对特殊符号进行转义，如将 “&lt;” 转义为“&amp;lt;” 12345&lt;!--属性值包含特殊符号 1 把&lt;&gt;进行转义 &amp;lt; &amp;gt; 2 把特殊符号内容写到CDATA --&gt; &lt;property name=\"address\" value=\" &amp;lt;南京&amp;gt;\"&gt;&lt;/property&gt; 方式二：把特殊符号内容写到CDATA 12345678&lt;!--属性值包含特殊符号 1 把&lt;&gt;进行转义 &amp;lt; &amp;gt; 2 把特殊符号内容写到CDATA--&gt;&lt;!--&lt;property name=\"address\" value=\" &amp;lt;南京&amp;gt;\"&gt;&lt;/property&gt;--&gt;&lt;property name=\"address\"&gt; &lt;value&gt;&lt;![CDATA[&lt;南京&gt;]]&gt;&lt;/value&gt;&lt;/property&gt; 注入属性-外部bean 创建两个类service类和dao类 在service调用dao里面的方法 在Spring配置文件中进行配置 1234567891011121314151617public class UserService &#123; //创建UserDao类型属性，生成set方法 private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void add()&#123; System.out.println(\"service add...........\"); //原始方式： 创建UserDao对象 // UserDao userDao=new UserDaoImpl(); // userDao.update(); userDao.update(); &#125;&#125; 123456789&lt;!--1 service和dao对象创建--&gt;&lt;bean id=\"userService\" class=\"com.ligangit.spring5.service.UserService\"&gt; &lt;!--注入userDao对象 name属性值：类里面属性名称 ref属性：创建userDao对象bean标签id值 --&gt; &lt;property name=\"userDao\" ref=\"userDaoImpl\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"userDaoImpl\" class=\"com.ligangit.spring5.dao.UserDaoImpl\"&gt;&lt;/bean&gt; 测试 123456789@Testpublic void testAdd()&#123; //1、加载Spring配置文件 ApplicationContext context=new ClassPathXmlApplicationContext(\"bean2.xml\"); //2、获取配置文件创建的对象 UserService userService = context.getBean(\"userService\", UserService.class); userService.add();&#125; 结果 注入属性-内部bean 一对多关系：部门和员工 在实体之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示 部门类 1234567891011121314151617/** * 部门类 */public class Dept &#123; private String dname; public void setDname(String dname) &#123; this.dname = dname; &#125; @Override public String toString() &#123; return \"Dept&#123;\" + \"dname='\" + dname + '\\'' + '&#125;'; &#125;&#125; 员工类 12345678910111213141516171819202122232425/** * 员工类 */public class Emp &#123; private String ename; private String gender; //员工属于某一个部门，使用对象表示 private Dept dept; public void setEname(String ename) &#123; this.ename = ename; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public void setDept(Dept dept) &#123; this.dept = dept; &#125; public void add()&#123; System.out.println(ename+\":::\"+gender+\"::::\"+dept.toString()); &#125;&#125; 在spring配置文件中进行配置（也可以使用外部bean的形式） 方式一：内部bean 123456789101112&lt;!--内部bean--&gt; &lt;bean id=\"emp\" class=\"com.ligangit.spring5.bean.Emp\"&gt; &lt;!--先设置两个普通的属性--&gt; &lt;property name=\"ename\" value=\"Tom\"&gt;&lt;/property&gt; &lt;property name=\"gender\" value=\"男\"&gt;&lt;/property&gt; &lt;!--对象类型属性--&gt; &lt;property name=\"dept\"&gt; &lt;bean id=\"dept\" class=\"com.ligangit.spring5.bean.Dept\"&gt; &lt;property name=\"dname\" value=\"安保部\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 方式二：使用外部bean实现内部bean 1234567891011&lt;!--内部bean 使用外部bean实现--&gt;&lt;bean id=\"emp\" class=\"com.ligangit.spring5.bean.Emp\"&gt; &lt;!--先设置两个普通的属性--&gt; &lt;property name=\"ename\" value=\"Tom\"&gt;&lt;/property&gt; &lt;property name=\"gender\" value=\"男\"&gt;&lt;/property&gt; &lt;!--对象类型属性--&gt; &lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"dept\" class=\"com.ligangit.spring5.bean.Dept\"&gt; &lt;property name=\"dname\" value=\"安保部\"&gt;&lt;/property&gt;&lt;/bean&gt; 测试 123456789@Testpublic void testBean3()&#123; //1、加载Spring配置文件 ApplicationContext context=new ClassPathXmlApplicationContext(\"bean3.xml\"); //2、获取配置文件创建的对象 Emp emp = context.getBean(\"emp\", Emp.class); emp.add();&#125; 结果 注入属性-级联赋值 第一种方法：就是使用外部bean 在创建emp对象的时候，把dept通过外部bean的方式引入，同时把dname进行赋值。 1234567891011&lt;!--级联赋值--&gt;&lt;bean id=\"emp\" class=\"com.ligangit.spring5.bean.Emp\"&gt; &lt;!--先设置两个普通的属性--&gt; &lt;property name=\"ename\" value=\"Lucy\"&gt;&lt;/property&gt; &lt;property name=\"gender\" value=\"女\"&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"dept\" class=\"com.ligangit.spring5.bean.Dept\"&gt; &lt;property name=\"dname\" value=\"财务部\"&gt;&lt;/property&gt;&lt;/bean&gt; 第二种方法： 第一步：给员工类中的dept属性添加get方法，如果不添加就不能emp对象就不能获取到detp对象。 //生成detp的get方法 public Dept getDept() { return dept; } 员工类完整代码 123456789101112131415161718192021222324252627282930/** * 员工类 */public class Emp &#123; private String ename; private String gender; //员工属于某一个部门，使用对象表示 private Dept dept; //生成detp的get方法 public Dept getDept() &#123; return dept; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public void setDept(Dept dept) &#123; this.dept = dept; &#125; public void add()&#123; System.out.println(ename+\":::\"+gender+\"::::\"+dept.toString()); &#125;&#125; 第二步：Spring配置文件进行配置 123456789101112&lt;!--级联赋值--&gt; &lt;bean id=\"emp\" class=\"com.ligangit.spring5.bean.Emp\"&gt; &lt;!--先设置两个普通的属性--&gt; &lt;property name=\"ename\" value=\"Lucy\"&gt;&lt;/property&gt; &lt;property name=\"gender\" value=\"女\"&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt; &lt;property name=\"dept.dname\" value=\"研发部\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dept\" class=\"com.ligangit.spring5.bean.Dept\"&gt; &lt;property name=\"dname\" value=\"财务部\"&gt;&lt;/property&gt; &lt;/bean&gt; 测试 123456789@Testpublic void testBean4()&#123; //1、加载Spring配置文件 ApplicationContext context=new ClassPathXmlApplicationContext(\"bean4.xml\"); //2、获取配置文件创建的对象 Emp emp = context.getBean(\"emp\", Emp.class); emp.add();&#125; 结果 注入属性-集合属性 注入数组类型属性、List集合类型属性、Map集合类型属性、Set集合类型属性 创建类，定义数组、list、map、set类型属性，生成对应set方法 12345678910111213141516171819202122public class Stu &#123; //1、数组类型属性 private String[] courses; //2、List集合类型属性 private List&lt;String&gt; list; //3、Map集合类型属性 private Map&lt;String ,String&gt; maps; //4、set集合类型属性 private Set&lt;String&gt; sets; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125; public void setMaps(Map&lt;String, String&gt; maps) &#123; this.maps = maps; &#125; public void setSets(Set&lt;String&gt; sets) &#123; this.sets = sets; &#125;&#125; 在Spring配置文件进行配置 12345678910111213141516171819202122232425262728293031&lt;!--集合类型属性注入--&gt;&lt;bean id=\"stu\" class=\"com.ligangit.spring5.collectionType.Stu\"&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=\"courses\"&gt; &lt;array&gt; &lt;value&gt;java课程&lt;/value&gt; &lt;value&gt;数据库课程&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--List类型属性注入--&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;小张&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Map类型属性注入--&gt; &lt;property name=\"maps\"&gt; &lt;map&gt; &lt;entry key=\"JAVA\" value=\"java\"&gt;&lt;/entry&gt; &lt;entry key=\"PYTHON\" value=\"python\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--Set类型属性注入--&gt; &lt;property name=\"sets\"&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;Redis&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 测试结果 在集合里面设置对象类型值 学生类学多门课程 12345678//学生所学多门课程private List&lt;Course&gt; courseList;public void setCourses(String[] courses) &#123; this.courses = courses;&#125;public void setCourseList(List&lt;Course&gt; courseList) &#123; this.courseList = courseList;&#125; 课程类 123456789/** * 课程类 */public class Course &#123; private String cname; //课程名称 public void setCname(String cname) &#123; this.cname = cname; &#125;&#125; 在Spring配置文件进行配置 第一步：创建多个course对象 1234567&lt;!--创建多个course对象--&gt;&lt;bean id=\"course1\" class=\"com.ligangit.spring5.collectionType.Course\"&gt; &lt;property name=\"cname\" value=\"Spring5框架\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"course2\" class=\"com.ligangit.spring5.collectionType.Course\"&gt; &lt;property name=\"cname\" value=\"MyBatis框架\"&gt;&lt;/property&gt;&lt;/bean&gt; 第二步：list集合中引用对象 1234567&lt;!--注入list集合类型，值是对象--&gt; &lt;property name=\"courseList\"&gt; &lt;list&gt; &lt;ref bean=\"course1\"&gt;&lt;/ref&gt; &lt;ref bean=\"course2\"&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; 完整bean配置代码 把集合注入部分提取出来 第一步：在Spring配置文件中引入名称空间util 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"&gt; 第二步：使用util标签完成list集合注入提取 1234567891011&lt;!--1、提取List集合类型属性注入--&gt;&lt;util:list id=\"bookList\"&gt; &lt;value&gt;Java核心技术&lt;/value&gt; &lt;value&gt;Java编程思想&lt;/value&gt; &lt;value&gt;Spring实战&lt;/value&gt;&lt;/util:list&gt; &lt;!--2、提取List集合类型属性注入使用--&gt;&lt;bean id=\"book\" class=\"com.ligangit.spring5.collectionType.Book\"&gt; &lt;property name=\"list\" ref=\"bookList\"&gt;&lt;/property&gt;&lt;/bean&gt; 工厂bean（FactoryBean）Spring有两种类型bean，一种普通bean（比如我们自己创建的bean），另外一种工厂bean（FactoryBean） 普通bean：在配置文件中定义bean类型就是返回类型 工厂bean：在配置文件定义bean类型可以和返回类型不一样 第一步：创建类，让这个类作为工厂bean，实现接口FactoryBean 第二步：实现接口里面的方法，在实现的方法中定义返回的bean类型 类 1234567891011121314151617181920public class MyBean implements FactoryBean&lt;Course&gt;&#123; //定义返回bean @Override public Course getObject() throws Exception &#123; Course course = new Course(); course.setCname(\"abc\"); return course; &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return null; &#125; @Override public boolean isSingleton() &#123; return false; &#125;&#125; Spring配置文件配置 12&lt;bean id=\"myBean\" class=\"com.ligangit.spring5.factoryBean.MyBean\"&gt;&lt;/bean&gt; 测试代码 123456@Testpublic void test3()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean3.xml\"); Course course = context.getBean(\"myBean\", Course.class); System.out.println(course);&#125; 测试结果 自动装配什么是自动装配根据指定装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入。 演示自动装配的过程 根据属性名称自动注入：byName 12345678910&lt;!--实现自动装配 bean标签属性autowire，配置自动装配 autowire属性常用两个值： byName 根据属性名称注入 注入值bean的id和类属性名称一样 byType根据属性类型注入 注意多个相同类型会报错--&gt;&lt;bean id=\"emp\" class=\"com.ligangit.spring5.autowire.Emp\" autowire=\"byName\"&gt; &lt;!--&lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=\"dept\" class=\"com.ligangit.spring5.autowire.Dept\"&gt;&lt;/bean&gt; 根据属性类型自动注入：byType 12345678910&lt;!--实现自动装配 bean标签属性autowire，配置自动装配 autowire属性常用两个值： byName 根据属性名称注入 注入值bean的id和类属性名称一样 byType根据属性类型注入 注意多个相同类型会报错--&gt;&lt;bean id=\"emp\" class=\"com.ligangit.spring5.autowire.Emp\" autowire=\"byType\"&gt; &lt;!--&lt;property name=\"dept\" ref=\"dept\"&gt;&lt;/property&gt;--&gt;&lt;/bean&gt;&lt;bean id=\"dept\" class=\"com.ligangit.spring5.autowire.Dept\"&gt;&lt;/bean&gt; 外部属性文件直接配置数据库信息 配置德鲁伊（druid）连接池 引入德鲁伊连接池依赖jar包 Spring配置文件配置 1234567&lt;!--直接配置连接池--&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/study\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt;&lt;/bean&gt; 引入外部属性文件配置数据库连接池 创建外部属性文件，properties格式文件，数据库信息 jdbc.properties文件内容 1234prop.driverClass=com.mysql.jdbc.Driverprop.url=jdbc:mysql://localhost:3306/studyprop.username=rootprop.password=123456 把外部properties属性文件引入到Spring配置文件中 第一步：引入context名称空间 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; 第二步：在Spring配置文件使用标签引入外部属性文件 123456789&lt;!--引入外部属性文件--&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;!--配置连接池--&gt;&lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;prop.driverClass&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;prop.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;prop.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;prop.password&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt; 基于注解方式实现什么是注解 注解是代码特殊标记，格式：@注解名称(属性名称=属性值,属性名称=属性值…) 使用注解，注解作用在类上面，方法上面，属性上面 使用注解目的：简化xml配置 Spring针对Bean管理中创建对象提供注解 @Componet 创建普通组件 @Service 一般应用于业务逻辑层、service层 @Controller 一般应用于web层 @Repository 一般应用于dao层、持久层上 以上四个注解功能是一样的，都可以用来创建bean实例 基于注解方式实现对象创建 第一步：引入依赖spring-aop-5.2.6.RELEASE.jar 第二步：开启组件扫描 先引入名称空间context 配置标签 12345&lt;!--开启组件扫描 1 如果扫描多个包，多个包用逗号隔开 2 扫描包的上层目录--&gt;&lt;context:component-scan base-package=\"com.ligangit.spring5.dao,com.ligangit.spring5.service\"&gt;&lt;/context:component-scan&gt; 第三步：创建类，在类上面添加创建对象注解 123456789//在注解里面value属性值可以省略不写，//默认值是类名称，首字母小写//UserService -- userService@Component(value = \"userService\") // &lt;bean id=\"userService\" class=\"..\"/&gt;public class UserService &#123; public void add()&#123; System.out.println(\"service add......\"); &#125;&#125; 开启组件扫描细节配置use-default-filters context:include-filter context:exclude-filter 1234567891011121314151617&lt;!--示例1 只扫描com.ligangit中的Controller注解 use-default-filters=\"false\" 表示现在不使用filter，自己配置filter context:include-filter 设置扫描哪些内容--&gt;&lt;context:component-scan base-package=\"com.ligangit\" use-default-filters=\"false\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;&lt;/context:component-scan&gt;&lt;!--示例2 除了Controller注解，com.ligangit中其他注解都扫描 下面配置扫描包所有内容 context:exclude-filter 设置哪些内容不扫描--&gt;&lt;context:component-scan base-package=\"com.ligangit\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;&lt;/context:component-scan&gt; 注入属性 @Autowired：根据属性类型进行自动装配（Spring中的注解） ​ 注意：如果有UserDao有多个实现类，如UserDaoImpl1，UserDaoImpl2，这时@Autowired不知道找哪个实现类。 第一步：把service和dao对象创建，在service和dao类添加创建对象的注解 第二步：在service注入dao对象，在service类添加dao类型属性，在属性上面使用注解 service类代码 定义dao类属性，不需要添加set方法，添加注入属性注解 1234567891011121314@Servicepublic class UserService &#123; //定义dao类属性 //不需要添加set方法 //添加注入属性注解 @Autowired private UserDao userDao; public void add()&#123; System.out.println(\"service add......\"); userDao.add(); &#125;&#125; @Qualifier：根据属性名称进行注入（Spring中的注解） 这个@Qualifier注解的使用，和上面@Autowired一起使用。 123456//定义dao类属性//不需要添加set方法//添加注入属性注解@Autowired //根据类型进行注入@Qualifier(value = \"userDaoImpl\") //根据名称进行注入private UserDao userDao; @Resource：可以根据类型注入，可以根据名称注入（java扩展包中的注解） 123// @Resource //根据类型进行注入 @Resource(name = \"userDaoImpl1\") //根据名称进行注入 private UserDao userDao; @Value：注入普通类型属性 12@Value(value = \"abc\")private String name; 完全注解开发 创建配置类，替代xml配置文件 1234@Configuration //作为配置类，替代xml配置文件@ComponentScan(basePackages = &#123;\"com.ligangit\"&#125;)public class SpringConfig &#123;&#125; 编写测试类 12345678@Testpublic void testService2()&#123; //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(\"userService\", UserService.class); System.out.println(userService); userService.add();&#125;","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"}]},{"title":"Spring-IOC","slug":"Spring-IOC","date":"2020-06-24T09:25:04.000Z","updated":"2020-06-24T09:58:35.430Z","comments":true,"path":"2020/06/24/Spring-IOC/","link":"","permalink":"http://ligangit.com/2020/06/24/Spring-IOC/","excerpt":"","text":"Spring的IOCIOC的概念 概念： Inversion of Control ，控制反转，把对象创建和对象之间的调用过程，交给Spring进行管理。 之前我们创建对象是使用User user = new User(); 这样的形式，是我们主动创建的，但是使用IOC之后，我们不再创建对象，而是由Spring来创建，我们直接使用User对象就可以了，如下示例： 12345//1、加载Spring配置文件 ApplicationContext context=new ClassPathXmlApplicationContext(\"bean1.xml\"); //2、获取配置文件创建的对象 User user = context.getBean(\"user\", User.class); 目的： 降低耦合度 IOC底层原理​ 利用XML解析、工厂模式、反射实现。 ​ 第一步： ​ xml配置文件，配置创建的对象。 1&lt;bean id=\"dao\" class=\"com.ligangit.UserDao\"&gt;&lt;/bean&gt; ​ 第二步： ​ 在UserService类中调用UserDao类，创建工厂类。 1234567class UserDaoFactory&#123; public static UserDao getDao()&#123; String classValue = \"com.ligangit.UserDao\"; //1、xml解析,得到class属性值 Class clazz = Class.forName(classValue); //2、通过反射创建对象 return (UserDao)clazz.newInstance(); &#125;&#125; ​ 在UserService中使用 1UserDao dat = UserDaoFactory.getDao(); IOC容器实现方式：（两个接口） BeanFactory：IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用，加载配置文件的时候不创建对象，在获取对象（使用）才去创建，比较费时，但是省内存 ApplicatonContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员使用，加载配置文件的时候创建对象，可以在服务器启动的时候完成所有需要对象的创建，让耗时耗资源的操作，都交给服务器去做，所以这个接口比BeanFactory更好。 ​","categories":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://ligangit.com/tags/Spring/"}]},{"title":"Oracle之ROWNUM分页","slug":"Oracle之ROWNUM分页","date":"2020-06-23T08:54:53.000Z","updated":"2020-06-24T01:17:22.716Z","comments":true,"path":"2020/06/23/Oracle之ROWNUM分页/","link":"","permalink":"http://ligangit.com/2020/06/23/Oracle之ROWNUM分页/","excerpt":"","text":"​ 今天碰到一个分页BUG，记录一下 Oracle之ROWNUM分页使用ROWNUM进行分页查询rownum关键字： ​ oracle对外提供的自动给查询结果编号的关键字，与每行的数据没有关系。 注意： ​ rownum关键字只能做&lt; &lt;=的判断，不能进行&gt; &gt;=的判断 SQL1: 123456789select *FROM (select tmp_tb.*,ROWNUM row_id FROM (select ID, TO_CHAR(RDRQ ,&apos;YYYY-MM-DD&apos;) RDRQ FROM RED_LIST WHERE 1=1 ORDER BY RDRQ DESC NULLS LAst ) tmp_tb WHERE ROWNUM&lt;=30)WHERE row_id&gt;0; SQL2: 123456789select *FROM (select tmp_tb.*,ROWNUM row_id FROM (select ID, TO_CHAR(RDRQ ,&apos;YYYY-MM-DD&apos;) RDRQ FROM RED_LIST WHERE 1=1 ORDER BY RDRQ DESC NULLS LAst ) tmp_tb WHERE ROWNUM&lt;=10)WHERE row_id&gt;0; 比较两条SQL的执行结果： ​ A4F1BD9FDF580D66E050020A0B033FAF ​ A4F1BD9FDF010D66E050020A0B033FAF 原因： ​ 使用ORDER BY 的时候，排序结果不唯一，导致最终的数据排序不稳定，我们分页截取的部分数据会重复显示。 ​ 即当RDRQ相同的值具有几百条时，这时，我们查出来的数据是随机的，不是固定顺序的，此时我们取出来的分页数据是不固定的。 解决方法： ​ 可以在ORDER BY 最后增加PK列或ROWID；即使有重复值，也可以根据索引进行区分。 解决方法如下（两个条件必须同时满足）： 1.sql语句中需要有排序条件。 2.排序条件如果没有唯一性，那么必须在后边跟上一个唯一性的条件，比如主键。 改进后SQL: ​ 注意：ORDER BY RDRQ DESC,ROWID NULLS LAst ​ NULLS LAst 表示RDRQ 为空值的时候排在最后面 123456789select *FROM (select tmp_tb.*,ROWNUM row_id FROM (select ID, TO_CHAR(RDRQ ,&apos;YYYY-MM-DD&apos;) RDRQ FROM RED_LIST WHERE 1=1 ORDER BY RDRQ DESC NULLS LAst,ROWID ) tmp_tb WHERE ROWNUM&lt;=30)WHERE row_id&gt;0; NULLS LAst 表示空值排在最后面 NULLS first 表示空值排在最前面","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"},{"name":"oracle","slug":"oracle","permalink":"http://ligangit.com/tags/oracle/"}]},{"title":"Mysql注意事项（三）","slug":"Mysql注意事项（三）","date":"2020-06-12T13:15:25.000Z","updated":"2020-06-12T14:10:43.199Z","comments":true,"path":"2020/06/12/Mysql注意事项（三）/","link":"","permalink":"http://ligangit.com/2020/06/12/Mysql注意事项（三）/","excerpt":"","text":"最近回顾了一下MySQL，发现了一些MySQL需要注意的事项，同时也作为学习笔记，记录下来。 Mysql注意事项（三）15、INSERT（插入数据）方法一​ 使用基本的INSERT语法，指定表名和被插入到新行中的值。 ​ 示例： 12345678910INSERT INTO customersVALUES(NULL, &apos;Pep E. LaPew&apos;, &apos;10 Main Street&apos;, &apos;Logs Angeles&apos;, &apos;CA&apos;, &apos;90046&apos;, &apos;USA&apos;, NULL, NULL); ​ 注意： ​ 虽然这种语法很简单，但并不安全，应该尽量避免使用。上面示例的SQL语句高度依赖于表中列的定义次序，并且还依赖于其次序容易获得的信息。即使可得到这种次序信息，也不能保证下一次表结构变动后各个列保持完全相同的次序。 方法二​ 总是使用列的列表。 12345678910111213141516INSERT INTO customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email)VALUES(&apos;Pep E. LaPew&apos;, &apos;10 Main Street&apos;, &apos;Logs Angeles&apos;, &apos;CA&apos;, &apos;90046&apos;, &apos;USA&apos;, NULL, NULL); ​ 使用列的列表能是SQL代码继续发挥作用，即使表结构发生了变化。 插入多个行​ 方式一：执行多条INSERT语句 1234567891011121314151617181920212223242526INSERT INTO customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)VALUES(&apos;Pep E. LaPew&apos;, &apos;10 Main Street&apos;, &apos;Logs Angeles&apos;, &apos;CA&apos;, &apos;90046&apos;, &apos;USA&apos; ); INSERT INTO customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)VALUES(&apos;M. Martian&apos;, &apos;42 Galaxy Way&apos;, &apos;New York&apos;, &apos;NY&apos;, &apos;11213&apos;, &apos;USA&apos; ); ​ 方式二：单条INSERT语句处理多个插入 ​ 可以提高INSERT的性能，因为MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句快。 12345678910111213141516171819INSERT INTO customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)VALUES(&apos;Pep E. LaPew&apos;, &apos;10 Main Street&apos;, &apos;Logs Angeles&apos;, &apos;CA&apos;, &apos;90046&apos;, &apos;USA&apos; ),(&apos;M. Martian&apos;, &apos;42 Galaxy Way&apos;, &apos;New York&apos;, &apos;NY&apos;, &apos;11213&apos;, &apos;USA&apos; ); 插入检索出的数据12345678910111213141516171819INSERT INTO customers(cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country)SELECT cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_countryFROM custnew; ​ 注意：INSERT SELECT中的列名 ​ 不一定要求列名匹配。事实上，MySQL甚至不关心SELECT返回的列名。它使用的是列的位置，因此SELECT中的第一列（不管其列名）将用来填充表列中指定的第一个列，第二列将用来填充表列中指定的第二个列，如此等等。 16、UPDATE（更新数据）​ 不要省略WHERE子句 ​ 不使用WHERE子句，就会更新表中的所有行。 ​ 示例： 123UPDATE customersSET cust_email= &apos;123@qq.com&apos;WHERE cust_id=10007; ​ 在UPDATE语句中使用子查询 12345UPDATE custnew SET cust_email= (SELECT cust_email FROM customers WHERE cust_id=10004) WHERE cust_id=10107; ​ 删除某列的值 ​ 可以将需要删除的列设置为NULL（假如表定义允许NULL值）。 123UPDATE customersSET cust_email= NULLWHERE cust_id=10005; DELETE（删除数据）不要省略WHERE子句​ 不使用WHERE子句，就会删除表中的所有行。 ​ DELETE不需要列名或通配符。DELETE删除整行而不是删除列。 删除表的内容而不是表​ DELETE语句从表中删除行，甚至是删除表中所有行，但是，DELETE不删除表本身。 更快的删除​ 如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句。它完成相同的工作，但速度更快（TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据）。 ​ 示例：custnew是表名称 1TRUNCATE custnew;","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://ligangit.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"}]},{"title":"Mysql注意事项（二）","slug":"Mysql注意事项（二）","date":"2020-06-11T13:43:09.000Z","updated":"2020-07-18T16:05:17.022Z","comments":true,"path":"2020/06/11/Mysql注意事项（二）/","link":"","permalink":"http://ligangit.com/2020/06/11/Mysql注意事项（二）/","excerpt":"","text":"最近回顾了一下MySQL，发现了一些MySQL需要注意的事项，同时也作为学习笔记，记录下来。 Mysql注意事项（二）9、分组数据GROUP BY规定： GROUP BY子句可以包含任意数目的列 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总 GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名 除聚集函数外，SELECT语句中的每个列都必须在GROUP BY子句中给出 如果分组中具有NULL值，则NULL将作为一个分组返回。如果有多行NULL值，它们将分为一组 GROUP BY 子句必须出现在WHERE子句之后，ORDER BY子句之前 使用ROLLUP ​ 使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别的值，即聚合函数结果的总数。 ​ 示例1： 123select vend_id,sum(prod_price) as num_prodsfrom productsgroup by vend_id WITH ROLLUP; ​ 结果1： ​ 示例2： 123select vend_id,count(*) as num_prodsfrom productsgroup by vend_id WITH ROLLUP; ​ 结果2： HAVING（过滤分组）​ HAVING基于完整的分组进行过滤，WHERE过滤指定的是行而不是分组。 ​ WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤 分组和排序 ORDER BY GROUP BY 排序产生的输出 分组行。但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列或表达式列，而且必须使用每个选择表达式 不一定需要 如果与聚集函数一起使用（或表达式），则必须使用 ​ 不要忘记ORDER BY ​ 一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。 10、SELECT子句及其顺序（非常重要）从上到下，依次执行 子句 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 11、子查询​ 子查询：嵌套在其他查询中的查询。 子查询总是从内向外查询。 列必须匹配 在WHERE子句中使用子查询，应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。 子查询和性能 使用子查询并不总是执行这种类型的数据检索的最有效的方法。 12、JOIN（联结）​ 联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。 ​ 维护引用完整性 指示MySQL只允许在products表的供应商ID列中出现合法值（即出现在vendors表中的供应商）。这就是维护引用完整性。通过在表的定义中指定主键和外键来实现。 ​ 完全限定列名 在引用的列可能出现二义性时，必须使用完全限定列名（用一个点分隔的表名和列名）。 ​ 不要忘了WHERE子句 应该保证所有联结都有WHERE子句，否则MySQL将返回比想象的数据多得多的数据。 ​ 性能考虑 MySQL运行在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表，联结的表越多，性能下降越厉害。 INNER JOIN（内部联结）​ 基于两个表中间的相等测试的联结，称为等值联结，也称为内部联结。 示例： 123SELECT vend_name,prod_name,prod_priceFROM vendors INNER JOIN productsON vendors.vend_id = products.vend_id; 自联结​ 示例： ​ 使用子查询： 12345SELECT prod_id,prod_nameFROM productsWHERE vend_id = (SELECT vend_id FROM products WHERE prod_id = &apos;DTNTR&apos;) ​ 使用自联结： 1234SELECT p1.prod_id,p1.prod_nameFROM products AS p1,products AS p2WHERE p1.vend_id = p2.vend_idAND p2.prod_id = &apos;DTNTR&apos;; ​ 用自联结而不用子查询 ​ 自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的。但有时候处理联结远比处理子查询快得多。应该试一下两种方法，以确定哪一种的性更好。 外部联结（OUTER JOIN）​ 联结包含了那些在相关表中没有关联行的行，这种类型的联结称为外部联结。 ​ 使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表，RIGHT指出的是OUTER JOIN右边的表，二LEFT指出的是OUTER JOIN左边的表。 ​ 示例：LEFT OUTER JOIN（左联结） 123SELECT customers.cust_id,orders.order_numFROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_id; ​ 结果： ​ 示例：RIGHT OUTER JOIN（右联结） 123SELECT customers.cust_id,orders.order_numFROM customers RIGHT OUTER JOIN ordersON customers.cust_id = orders.cust_id; ​ 结果： 使用带聚集函数的联结示例： 123456SELECT customers.cust_name,customers.cust_id,COUNT(orders.order_num) AS num_ordFROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_idGROUP BY customers.cust_id; 结果： 13、UNOIN（组合查询）​ 执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回，这些组合查询通常称为并（union）或复合查询（compound query）。 ​ 示例： 1234567SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;= 5UNIONSELECT vend_id,prod_id, prod_priceFROM productsWHERE vend_id IN (1001,1002); ​ 结果： ​ UNION规则 UNOIN必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔。 UNION中的每个查询必须包含相同的列、表达式或聚集函数 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型。 ​ ​ 包含或取消重复的行 ​ UNION从查询结果集中自动去除了重复的行。 ​ 如果想返回所有的行（不去除重复的行），可以使用UNION ALL而不是UNION ​ 对组合查询结果排序 ​ 在使用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。 ​ 示例： 12345678SELECT vend_id,prod_id,prod_priceFROM productsWHERE prod_price &lt;= 5UNIONSELECT vend_id,prod_id, prod_priceFROM productsWHERE vend_id IN (1001,1002)ORDER BY vend_id,prod_price; ​ 结果： 14、全文本搜索​ 并非所有引擎都支持全文本搜索。 ​ 为进行全文本搜索，必须索引被搜索的列。 ​ 在索引之后，SELECT可与Match()和Against()一起使用以实际执行搜索。 ​ 示例： 123SELECT note_textFROM productnotesWHERE Match(note_text) Against(&apos;rabbit&apos;); ​ 结果： ​ 注意：productnotes表中的note_text必须添加索引。","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://ligangit.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"}]},{"title":"Gradle学习","slug":"Gradle学习","date":"2020-06-11T09:04:42.000Z","updated":"2020-06-11T09:06:31.099Z","comments":true,"path":"2020/06/11/Gradle学习/","link":"","permalink":"http://ligangit.com/2020/06/11/Gradle学习/","excerpt":"","text":"","categories":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/categories/研发工具/"}],"tags":[{"name":"Gradle","slug":"Gradle","permalink":"http://ligangit.com/tags/Gradle/"},{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"},{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"}]},{"title":"Maven的核心概念","slug":"Maven的核心概念","date":"2020-06-11T02:28:02.000Z","updated":"2020-06-11T08:57:11.853Z","comments":true,"path":"2020/06/11/Maven的核心概念/","link":"","permalink":"http://ligangit.com/2020/06/11/Maven的核心概念/","excerpt":"","text":"Maven的核心概念什么是MavenMaven是一款服务于Java平台的自动化构建工具。 约定的目录结构目录结构： 根目录：工程名 src目录：源码 pom.xml文件：Maven工程的核心配置文件 main目录：存放主程序 test目录：存放测试程序 java目录：存放java源文件 resource目录：存放框架或其他工具的配置文件 为什么要约定目录结构 Maven要负责我们这个项目的构建，以编译为例，Maven要想自动进行编译，那么它必须知道Java源文件保存在哪里。 如果我们自己定义的东西想要让框架或工具知道，有两种办法： 以配置的方式明确告诉框架 如：配置文件 遵守框架内部已经存在的约定 如：log4j.xml，log4j.properties 约定&gt;配置&gt;编码 POM 含义：Project Object Model 项目对象模型 pom.xml对于Maven工程是核心配置文件，与构建工程相关的一切设置都在这个文件中进行配置。 坐标使用下面三个向量在仓库中唯一定位一个Maven工程： groupid：公司或组织域名倒叙+项目名 1&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; artifactid：模块名 1&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; version：版本 1&lt;version&gt;2.2.2.RELEASE&lt;/version&gt; Maven工程的坐标与仓库中路径的对应关系 坐标： 123&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; 路径： 1org/springframework/boot/spring-boot-starter-parent/2.2.2.RELEASE/spring-boot-starter-parent-2.2.2.RELEASE.jar 依赖Maven解析依赖信息时会到本地仓库中查找被依赖的jar包。 ​ 对于我们自己开发的Maven工程，使用install命令安装后就可以进入仓库。 依赖的范围： compile 对主程序是否有效 有效 对测试程序是否有效 有效 是否参与打包 参与 是否参与部署 参与 典型例子：spring-core test 对主程序是否有效 无效 对测试程序是否有效 有效 是否参与打包 不参与 是否参与部署 不参与 典型的例子：junit provided 对主程序是否有效 有效 对测试程序是否有效 有效 是否参与打包 不参与 是否参与部署 不参与 典型的例子：servlet-api.jar、jsp-api.jar 依赖的传递性好处：可以传递的依赖不必在每个模块工程中重复声明，在依赖关系的最下面一层的工程中依赖一次即可。 注意：非compile范围的依赖不能传递，所以在各个模块工程中，如果需要就必须重复声明依赖。 依赖的排除123456&lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt;&lt;/exclusions&gt; 依赖的原则 作用：解决jar包的冲突问题 路径最短优先原则 ​ 根据依赖的传递性，MakeFriends可以选择log4j.1.2.17和log4j.1.2.14 ​ MakeFriends和log4j.1.2.17距离是3，但是和log4j.1.2.14距离是2，所以选择log4j.1.2.14。 路径相同时先声明者优先 ​ 先声明指的是dependency标签的声明顺序 统一管理依赖版本 使用properties标签内使用自定义标签统一声明版本号 注意：properties标签不只是只能用于声明依赖的版本号，如编码格式UTF-8，凡是需要统一声明后再引用的场合都可以使用。 在需要统一版本的位置，使用“${自定义标签名}”引用声明的版本号 示例： properties标签中声明了lombok.version标签，声明了project.build.sourceEncoding标签 1234&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;lombok.version&gt;1.18.6&lt;/lombok.version&gt;&lt;/properties&gt; dependency标签中使用“${lombok.version}”引用了lombok.version标签中的值 1234567 &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 仓库仓库的分类 本地仓库：当前电脑上部署的仓库目录，为当前电脑上所有Maven工程服务 远程仓库： 私服：搭建在局域网环境中，为局域网范围内所有Maven工程服务 中央仓库：架设在Internet上，为全世界所有Maven工程服务 中央仓库镜像：为了分担中央仓库的流量，提升用户访问速度 仓库中保存的内容：Maven工程 Maven自身所需要的插件 第三方框架或工具的jar包 我们自己开发的Maven工程 生命周期/插件/目标生命周期 各个构建环节的执行顺序：不能打乱顺序，必须按照既定的顺序来执行 Maven的核心程序中定义了抽象的生命周期，生命周期中各个阶段的具体任务是由插件来完成的。 Maven核心程序为了更好的实现自动化构建，按照下面描述的特点执行生命周期中的各个阶段：不论现在要执行生命周期中的哪一个阶段，都是从这个生命周期最初的位置开始执行。 插件和目标 生命周期的各个阶段仅仅定义了要执行的任务是什么。 各个阶段和插件的目标是对应的。 相似的目标由特定的插件来完成。 生命周期阶段 插件目标 插件 compile compile maven-compilee-plugin test-compile testCompile maven-compilee-plugin 可以将目标看做“调用插件功能的命令” 继承 现状 对于过个模块中的依赖，如junt，1号模块中使用了4.0版本，2号模块中使用4.0版本，但是3号模块中使用了4.9版本，由于test范围的依赖不能传递，所以必然会分散在各个模块中，很容易造成版本不一致。 需求 统一管理各个模块工程中对junit依赖的版本 解决思路 将junit依赖统一提取到“父“工程中，在子工程中声明junit依赖时不指定版本，以父工程中统一设定的为准，同时也便于修改 操作步骤 创建一个Maven工程作为父工程。注意：打包的方式pom 在子工程中声明对父工程的引用 将子工程的坐标中与父工程坐标中的重复内容删除 在父工程中统一管理junit的依赖 在子工程中删除junit依赖的版本号部分 注意 配置继承后，执行安装命令时要先安装父工程。 聚合 作用：一键安装各个模块工程 配置方式：在一个“总的聚合工程”中配置各个参与聚合的模块。 1234567&lt;!-- 配置聚合 --&gt;&lt;modules&gt; &lt;!-- 指定子工程 --&gt; &lt;module&gt;config&lt;/module&gt; &lt;module&gt;gateway&lt;/module&gt; &lt;module&gt;filesystem&lt;/module&gt; &lt;/modules&gt; 使用方式：在聚合工程的pom.xml 执行 mvn install。","categories":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/categories/研发工具/"}],"tags":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"},{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"maven","slug":"maven","permalink":"http://ligangit.com/tags/maven/"}]},{"title":"IDEA快捷键","slug":"IDEA快捷键","date":"2020-06-10T08:56:03.000Z","updated":"2020-06-11T01:48:43.183Z","comments":true,"path":"2020/06/10/IDEA快捷键/","link":"","permalink":"http://ligangit.com/2020/06/10/IDEA快捷键/","excerpt":"","text":"IDEA快捷键必须掌握 快捷键 简介 Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备） Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备） Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备） Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + / 代码块注释 （必备） Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） F2 跳转到下一个高亮错误 或 警告位置 （必备） Tab 缩进（必备） 连按两次Shift 弹出 Search Everywhere 弹出层（必备） Ctrl 快捷键 简介 Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + X 剪切光标所在行 或 剪切选择内容 Ctrl + C 复制光标所在行 或 复制选择内容 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） Ctrl + E 显示最近打开的文件记录列表 Ctrl + N 根据输入的 类名 查找类文件 Ctrl + G 在当前文件跳转到指定行处 Ctrl + J 插入自定义动态代码模板 Ctrl + P 方法参数提示显示 Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义 Ctrl + B 进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击 Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用 Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用 Ctrl + H 显示当前类的层次结构 Ctrl + O 选择可重写的方法 Ctrl + I 选择可继承的方法 Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F1 在光标所在的错误代码出显示错误信息 Ctrl + F3 调转到所选中的词的下一个引用位置 Ctrl + F4 关闭当前编辑文件 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行 Make Project 操作 Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 Ctrl + Enter 智能分隔行 Ctrl + End 跳到文件尾 Ctrl + Home 跳到文件头 Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备） Ctrl + Delete 删除光标后面的单词或是中文句 Ctrl + BackSpace 删除光标前面的单词或是中文句 Ctrl + 1,2,3…9 定位到对应数值的书签位置 Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径 Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要 Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置 Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置 Ctrl + 前方向键 等效于鼠标滚轮向前效果 Ctrl + 后方向键 等效于鼠标滚轮向后效果 Alt 快捷键 简介 Alt + ` 显示版本控制常用操作菜单弹出层 Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息 Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层 Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示 Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方 Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Alt + Home 定位 / 显示到当前文件的 Navigation Bar Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 Alt + 左方向键 按左方向切换当前已打开的文件视图 Alt + 右方向键 按右方向切换当前已打开的文件视图 Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 Alt + 1,2,3…9 显示对应数值的选项卡，其中 1 是 Project 用得最多 Shift 快捷键 简介 Shift + F1 如果有外部文档可以连接外部文档 Shift + F2 跳转到上一个高亮错误 或 警告位置 Shift + F3 在查找模式下，查找匹配上一个 Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留 Shift + F6 对文件 / 文件夹 重命名 Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样 Shift + F9 等效于点击工具栏的 Debug 按钮 Shift + F10 等效于点击工具栏的 Run 按钮 Shift + F11 弹出书签显示层 Shift + Tab 取消缩进 Shift + ESC 隐藏当前 或 最后一个激活的工具窗口 Shift + End 选中光标到当前行尾位置 Shift + Home 选中光标到当前行头位置 Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动 Ctrl + Alt 快捷键 简介 Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化 Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层 Ctrl + Alt + J 弹出模板选择窗口，讲选定的代码加入动态模板中 Ctrl + Alt + H 调用层次 Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Ctrl + Alt + V 快速引进变量 Ctrl + Alt + Y 同步、刷新 Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置 Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来 Ctrl + Alt + F11 切换全屏模式 Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层 Ctrl + Alt + Space 类名自动完成 Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件 Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件 Ctrl + Shift 快捷键 简介 Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备） Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备） Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板 Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层 Ctrl + Shift + E 显示最近修改的文件列表的弹出层 Ctrl + Shift + H 显示方法层次结构 Ctrl + Shift + B 跳转到类型声明处 Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义 Ctrl + Shift + A 查找动作 / 设置 Ctrl + Shift + / 代码块注释 （必备） Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置 Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置 Ctrl + Shift + + 展开所有代码 Ctrl + Shift + - 折叠所有代码 Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失 Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件 Ctrl + Shift + F9 编译选中的文件 / 包 / Module Ctrl + Shift + F12 编辑器最大化 Ctrl + Shift + Space 智能代码提示 Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） Ctrl + Shift + Backspace 退回到上次修改的地方 Ctrl + Shift + 1,2,3…9 快速添加指定数值的书签 Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 左方向键 在光标焦点是在工具选项卡上，缩小选项卡区域 Ctrl + Shift + 右方向键 在光标焦点是在工具选项卡上，扩大选项卡区域 Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 Alt + Shift 快捷键 简介 Alt + Shift + N 选择 / 添加 task Alt + Shift + F 显示添加到收藏夹弹出层 Alt + Shift + C 查看最近操作项目的变化情况列表 Alt + Shift + F 添加到收藏夹 Alt + Shift + I 查看项目当前文件 Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Alt + Shift + F9 弹出 Debug 的可选择菜单 Alt + Shift + F10 弹出 Run 的可选择菜单 Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 Alt + Shift + 前方向键 移动光标所在行向上移动 Alt + Shift + 后方向键 移动光标所在行向下移动 Ctrl + Shift + Alt 快捷键 简介 Ctrl + Shift + Alt + V 无格式黏贴 Ctrl + Shift + Alt + N 前往指定的变量 / 方法 Ctrl + Shift + Alt + S 打开当前项目设置 Ctrl + Shift + Alt + C 复制参考信息 其他 快捷键 简介 F2 跳转到下一个高亮错误 或 警告位置 （必备） F3 在查找模式下，定位到下一个匹配处 F4 编辑源 F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上 F11 添加书签 F12 回到前一个工具窗口 Tab 缩进（必备） ESC 从工具窗口进入代码文件窗口 连按两次Shift 弹出 Search Everywhere 弹出层（必备） 原文链接：https://blog.csdn.net/qq_38963960/java/article/details/89552704","categories":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/categories/研发工具/"}],"tags":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"},{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"idea","slug":"idea","permalink":"http://ligangit.com/tags/idea/"}]},{"title":"IDEA缓存和索引清理","slug":"IDEA缓存和索引清理","date":"2020-06-10T07:30:29.000Z","updated":"2020-08-15T12:59:02.000Z","comments":true,"path":"2020/06/10/IDEA缓存和索引清理/","link":"","permalink":"http://ligangit.com/2020/06/10/IDEA缓存和索引清理/","excerpt":"","text":"IDEA缓存和索引IntelliJ IDEA首次加载项目的时候。都会创建索引，而创建索引的时间根项目的文件多少成正比。 IntelliJ IDEA的缓存和索引主要是用来加快文件查询，从而加快各种查找、代码提示等操作的速度。 某些特殊情况下，IntelliJ IDEA的缓存和索引文件也是会损坏的，比如：断电、蓝屏引起的强制关机，当重新打开IDEA，很可能IDEA会报各种莫名其妙的错误，甚至项目打不开，IDEA主题还原成默认状态。 清理缓存和索引步骤： 执行完成后会重启IDEA，IDEA启动后会自动重新创建缓存文件和索引。","categories":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/categories/研发工具/"}],"tags":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"},{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"idea","slug":"idea","permalink":"http://ligangit.com/tags/idea/"}]},{"title":"IDEA部分模板","slug":"IDEA部分模板","date":"2020-06-09T09:17:04.000Z","updated":"2020-06-11T01:49:10.285Z","comments":true,"path":"2020/06/09/IDEA部分模板/","link":"","permalink":"http://ligangit.com/2020/06/09/IDEA部分模板/","excerpt":"","text":"部分常用模板psvm（main方法）1234//模板一：psvm public static void main(String[] args) &#123; &#125; sout（输出）12345678910111213//模板二：sout System.out.println(\"hello!\"); //变形： soutp / soutm /soutv / xxx.sout // soutp System.out.println(\"args = [\" + args + \"]\"); // soutm System.out.println(\"TempletsTest.main\"); // soutv int num=10; int num2=20; System.out.println(\"num2 = \" + num2); System.out.println(\"num = \" + num); System.out.println(num); fori（for循环）1234567891011121314//模板三： fori String[] arr= new String[]&#123;\"Tom\",\"Jerry\",\"Meimei\",\"Lilei\"&#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //变形 iter for (String s : arr) &#123; System.out.println(s); &#125; //变形 itar for (int i = 0; i &lt; arr.length; i++) &#123; String s = arr[i]; System.out.println(s); &#125; list.for（List循环）12345678910111213141516//模板四： list.for ArrayList list=new ArrayList(); list.add(\"hello\"); list.add(123); list.add(456); for (Object o : list) &#123; &#125; //变形： list.fori for (int i = 0; i &lt; list.size(); i++) &#123; &#125; //变形： list.forr 倒叙遍历 for (int i = list.size() - 1; i &gt;= 0; i--) &#123; &#125; ifn（判断NULL）1234567891011121314151617181920 ArrayList list=new ArrayList(); list.add(\"hello\"); list.add(123); list.add(456);//模板五：ifn if (list == null) &#123; &#125; //变形：inn if (list != null) &#123; &#125; //变形：xxx.null if (list == null) &#123; &#125; //变形：xxx.nn if (list != null) &#123; &#125; prsf（类常量）123456789//模板六：prsf 可生成 private static final private static final String sss=new String(); //变形：psf public static final int NUM1 = 9; //变形：psfi public static final int NUM2=10; //变形：psfs public static final String ST1=\"hello\"; 自定义模板打开设置 创建分组 创建模板 说明： ​ 步骤11：设置模板调用字符 ​ 步骤12：此模板的描述 ​ 步骤13：模板内容 12345/** *$VAR1$ */ private int $VAR2$; $END$ ​ 步骤14：设置模板应用范围 选择模板应用范围我们选择Java 选择之后点击OK，应用模板 结果 12345//自定义模板 pri/** *自定义模板测试 */ private int id; 附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.ArrayList;public class TempletsTest &#123; //自定义模板 pri /** *自定义模板测试 */ private int id; //模板六：prsf 可生成 private static final private static final String sss=new String(); //变形：psf public static final int NUM1 = 9; //变形：psfi public static final int NUM2=10; //变形：psfs public static final String ST1=\"hello\"; //模板一：psvm public static void main(String[] args) &#123; //模板二：sout System.out.println(\"hello!\"); //变形： soutp / soutm /soutv / xxx.sout // soutp System.out.println(\"args = [\" + args + \"]\"); // soutm System.out.println(\"TempletsTest.main\"); // soutv int num=10; int num2=20; System.out.println(\"num2 = \" + num2); System.out.println(\"num = \" + num); System.out.println(num); //模板三： fori String[] arr= new String[]&#123;\"Tom\",\"Jerry\",\"Meimei\",\"Lilei\"&#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //变形 iter for (String s : arr) &#123; System.out.println(s); &#125; //变形 itar for (int i = 0; i &lt; arr.length; i++) &#123; String s = arr[i]; System.out.println(s); &#125; //模板四： list.for ArrayList list=new ArrayList(); list.add(\"hello\"); list.add(123); list.add(456); for (Object o : list) &#123; &#125; //变形： list.fori for (int i = 0; i &lt; list.size(); i++) &#123; &#125; //变形： list.forr 倒叙遍历 for (int i = list.size() - 1; i &gt;= 0; i--) &#123; &#125; //模板五：ifn if (list == null) &#123; &#125; //变形：inn if (list != null) &#123; &#125; //变形：xxx.null if (list == null) &#123; &#125; //变形：xxx.nn if (list != null) &#123; &#125; &#125;&#125;","categories":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/categories/研发工具/"}],"tags":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"},{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"idea","slug":"idea","permalink":"http://ligangit.com/tags/idea/"}]},{"title":"Tomcat部署web工程的方式","slug":"Tomcat部署web工程的方式","date":"2020-06-05T09:25:48.000Z","updated":"2020-06-11T01:51:06.320Z","comments":true,"path":"2020/06/05/Tomcat部署web工程的方式/","link":"","permalink":"http://ligangit.com/2020/06/05/Tomcat部署web工程的方式/","excerpt":"","text":"Tomcat部署web工程的方式第一种只需要把web工程的目录拷贝到Tomcat的webapps目录下即可。 helloworld文件夹就是web项目 访问路径： http://localhost:8080/helloworld/hello.html 第二种进入Tomcat安装目录的conf\\Catalina\\localhost文件夹 创建一个xml配置文件（一个xml配置文件对应一个web工程）:如abc.xml abc.xml的配置信息： 1234567&lt;!-- Context 表示一个工程上下文 path 表示工程访问路径 docBase 表示web工程路径 path中的内容必须和xml文件名称相同--&gt;&lt;Context path=\"/abc\" docBase=\"D:\\test\\helloworld\"/&gt; 注意： ​ Context 表示一个工程上下文​ path 表示工程访问路径​ docBase 表示web工程路径 ​ path中的内容必须和xml文件名称相同，不然访问不到，如上例中的abc.xml， path=”/abc” 项目存放地址：D:\\test 访问路径： http://localhost:8080/abc/hello.html 默认访问当我们在浏览器地址中输入访问地址如下： http://ip:port/ 如 http://localhost:8080/ 没有工程名的时候，默认访问的是ROOT工程。 当我们在浏览器地址栏中输入的访问地址如下： http://ip:port/工程名/ 如 http://localhost:8080/abc/ 没有资源名，默认访问index.html页面。","categories":[{"name":"服务器软件","slug":"服务器软件","permalink":"http://ligangit.com/categories/服务器软件/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"服务器软件","slug":"服务器软件","permalink":"http://ligangit.com/tags/服务器软件/"},{"name":"tomcat","slug":"tomcat","permalink":"http://ligangit.com/tags/tomcat/"},{"name":"web","slug":"web","permalink":"http://ligangit.com/tags/web/"}]},{"title":"Echarts地图点击事件重复","slug":"Echarts地图点击事件重复","date":"2020-06-05T01:53:25.000Z","updated":"2020-06-05T02:37:57.832Z","comments":true,"path":"2020/06/05/Echarts地图点击事件重复/","link":"","permalink":"http://ligangit.com/2020/06/05/Echarts地图点击事件重复/","excerpt":"","text":"Echarts地图点击事件重复执行两次点击事件当我们点击Echarts地图，在点击事件的里面执行更新地图操作的时候，地图点击事件会执行两次。 如下： 1234567891011121314151617var mapMain = document.getElementById('mapMain'); var myChart = echarts.init(mapMain); myChart.setOption(option); myChart.on(\"click\", function (param) &#123; let area_code=param.data.area_code; if (param.name != \"\"&amp;&amp;area_code!=\"\") &#123; areaCode = area_code; proName=param.name; areaCode=areaCode.substring(0, 2); areaCodeNew=areaCode; //保存当前地区代码 c_area_level='2'; c_area_level_new=c_area_level; //保存当前地区等级 mapData(year, areaCode, c_area_level);//地图点击 地图 persent(year, areaCode,c_area_level); //右边 河流面积占区域面积百分比 &#125; getDataList(year, areaCodeNew,c_area_level_new); &#125;); 代码说明： areaCode、proName、areaCodeNew、c_area_level、c_area_level_new为全局变量； mapData(year, areaCode, c_area_level) 地图显示方法； persent(year, areaCode,c_area_level); 河流面积占区域面积百分比方法； getDataList(year, areaCodeNew,c_area_level_new) 数据显示方法 上面的代码是mapData(year, areaCode, c_area_level) 方法中的一部分。 当执行点击事件的时候： mapData()、persent()、getDataList()方法会执行两次，有时我们会在点击事件中修改全局变量，这个就需要注意了，执行两次的后的全局变量和执行一次后的全局变量值大多数会有所不同，从而影响其他方法的结果。 如： 假设c_area_level 初始值为’1’,那么执行一次点击事件后c_area_level_new为’1’，c_area_level为’2’；执行两次点击事件后c_area_level_new为’2’，c_area_level为’2’； 这时使用了c_area_level_new的getDataList()方法展示出来的数据会不同。 如何解决重复点击事件在点击事件执行一次后，再次刷新地图的时候不在执行点击事件。 核心代码： 1234//防止重复触发点击事件 if(myChart._$handlers.click)&#123; myChart._$handlers.click.length = 0; &#125; 我们只需要将上面那段代码添加到点击事件之就OK了。 123456789101112131415161718192021var mapMain = document.getElementById('mapMain'); var myChart = echarts.init(mapMain); myChart.setOption(option); //防止重复触发点击事件 if(myChart._$handlers.click)&#123; myChart._$handlers.click.length = 0; &#125; myChart.on(\"click\", function (param) &#123; let area_code=param.data.area_code; if (param.name != \"\"&amp;&amp;area_code!=\"\") &#123; areaCode = area_code; proName=param.name; areaCode=areaCode.substring(0, 2); areaCodeNew=areaCode; //保存当前地区代码 c_area_level='2'; c_area_level_new=c_area_level; //保存当前地区等级 mapData(year, areaCode, c_area_level);//地图点击 地图 persent(year, areaCode,c_area_level); //右边 河流面积占区域面积百分比 &#125; getDataList(year, areaCodeNew,c_area_level_new); &#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://ligangit.com/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://ligangit.com/tags/JS/"},{"name":"前端","slug":"前端","permalink":"http://ligangit.com/tags/前端/"},{"name":"Echarts","slug":"Echarts","permalink":"http://ligangit.com/tags/Echarts/"}]},{"title":"JS时间格式转换与获取","slug":"JS时间格式转换与获取","date":"2020-06-01T01:21:55.000Z","updated":"2020-06-05T03:41:51.398Z","comments":true,"path":"2020/06/01/JS时间格式转换与获取/","link":"","permalink":"http://ligangit.com/2020/06/01/JS时间格式转换与获取/","excerpt":"","text":"​ 项目中有很多时候需要用到时间格式、某些时间的获取，这里面主要包括了将时间字符转转Date对象，日期格式转换，本周、本月、本季度的开始和结束日期获取。 ​ 可以直接将代码复制，粘贴在一个JS文件中，然后调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/** * 获取本周、本季度、本月、上月的开始日期、结束日期 *///时间字符串转为Date对象 如：'2020-05-28'function getDate(strDate)&#123; var date = eval('new Date(' + strDate.replace(/\\d+(?=-[^-]+$)/, function (a) &#123; return parseInt(a, 10) - 1; &#125;).match(/\\d+/g) + ')'); return date;&#125;//格式化日期：yyyy-MM-ddfunction formatDate(date) &#123; var myyear = date.getFullYear(); var mymonth = date.getMonth()+1; var myweekday = date.getDate(); if(mymonth &lt; 10)&#123; mymonth = \"0\" + mymonth; &#125; if(myweekday &lt; 10)&#123; myweekday = \"0\" + myweekday; &#125; return (myyear+\"-\"+mymonth + \"-\" + myweekday);&#125;//获得某天所属月份的天数（参数为Date时间）function getMonthDays(date)&#123; var nowYear = date.getYear(); //当前年 var nowMonth = date.getMonth(); //当前月 var monthStartDate = new Date(nowYear, nowMonth, 1); var monthEndDate = new Date(nowYear, nowMonth + 1, 1); var days = (monthEndDate - monthStartDate)/(1000 * 60 * 60 * 24); return days;&#125;//获得本季度的开始月份function getQuarterStartMonth(nowMonth)&#123; var quarterStartMonth = 0; if(nowMonth&lt;3)&#123; quarterStartMonth = 0; &#125; if(2&lt;nowMonth &amp;&amp; nowMonth&lt;6)&#123; quarterStartMonth = 3; &#125; if(5&lt;nowMonth &amp;&amp; nowMonth&lt;9)&#123; quarterStartMonth = 6; &#125; if(nowMonth&gt;8)&#123; quarterStartMonth = 9; &#125; return quarterStartMonth;&#125;//获得本周的开始日期(参数为Date)function getWeekStartDate(date) &#123; var nowDayOfWeek = date.getDay(); //今天本周的第几天 var nowDay = date.getDate(); //当前日 var nowMonth = date.getMonth(); //当前月 var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var weekStartDate = new Date(nowYear, nowMonth, nowDay - nowDayOfWeek); return formatDate(weekStartDate);&#125;//获得本周的结束日期function getWeekEndDate(date) &#123; var nowDayOfWeek = date.getDay(); //今天本周的第几天 var nowDay = date.getDate(); //当前日 var nowMonth = date.getMonth(); //当前月 var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var weekEndDate = new Date(nowYear, nowMonth, nowDay + (6 - nowDayOfWeek)); return formatDate(weekEndDate);&#125;//获得本月的开始日期function getMonthStartDate(date)&#123; var nowMonth = date.getMonth(); //当前月 var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var monthStartDate = new Date(nowYear, nowMonth, 1); return formatDate(monthStartDate);&#125;//获得本月的结束日期function getMonthEndDate(date)&#123; var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var nowMonth = date.getMonth(); //当前月 var monthStartDate = new Date(nowYear, nowMonth, 1); var monthEndDate = new Date(nowYear, nowMonth + 1, 1); //下个月1号 var days = (monthEndDate - monthStartDate)/(1000 * 60 * 60 * 24); //计算本月的天数 var monthEndDate2 = new Date(nowYear, nowMonth, days); //本月最后一天 return formatDate(monthEndDate2);&#125;//获得上月开始时间function getLastMonthStartDate(date)&#123; var lastMonthDate = date; //上月日期 lastMonthDate.setDate(1); lastMonthDate.setMonth(lastMonthDate.getMonth()-1); var lastYear = lastMonthDate.getYear(); lastYear += (lastYear &lt; 2000) ? 1900 : 0; // var lastMonth = lastMonthDate.getMonth(); var lastMonthStartDate = new Date(lastYear, lastMonth, 1); return formatDate(lastMonthStartDate);&#125;//获得上月结束时间function getLastMonthEndDate(date)&#123; var lastMonthDate = date; //上月日期 lastMonthDate.setDate(1); lastMonthDate.setMonth(lastMonthDate.getMonth()-1); var lastYear = lastMonthDate.getYear(); lastYear += (lastYear &lt; 2000) ? 1900 : 0; // var lastMonth = lastMonthDate.getMonth(); //上个月月份 var monthStartDate = new Date(lastYear, lastMonth, 1); //上个月的1号 var monthEndDate = new Date(lastYear, lastMonth + 1, 1); //这个月的1号 var days = (monthEndDate - monthStartDate)/(1000 * 60 * 60 * 24); //上个月的天数 var lastMonthEndDate = new Date(lastYear, lastMonth, days); return formatDate(lastMonthEndDate);&#125;//获得本季度的开始日期function getQuarterStartDate(date)&#123; var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var nowMonth = date.getMonth(); //当前月 var quarterStartDate = new Date(nowYear, getQuarterStartMonth(nowMonth), 1); return formatDate(quarterStartDate);&#125;//获得本季度的结束日期function getQuarterEndDate(date)&#123; var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var nowMonth = date.getMonth(); //当前月 var quarterEndMonth = getQuarterStartMonth(nowMonth) + 2; var endDate = new Date(nowYear, quarterEndMonth, 1); //上个月的1号 var quarterStartDate = new Date(nowYear, quarterEndMonth, getMonthDays(endDate)); return formatDate(quarterStartDate);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://ligangit.com/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://ligangit.com/tags/JS/"},{"name":"前端","slug":"前端","permalink":"http://ligangit.com/tags/前端/"},{"name":"Util","slug":"Util","permalink":"http://ligangit.com/tags/Util/"}]},{"title":"Nginx学习-相关概念","slug":"Nginx学习-相关概念","date":"2020-05-29T08:25:21.000Z","updated":"2020-07-17T07:19:16.157Z","comments":true,"path":"2020/05/29/Nginx学习-相关概念/","link":"","permalink":"http://ligangit.com/2020/05/29/Nginx学习-相关概念/","excerpt":"","text":"主要学习几个概念：Nginx，正向代理、反向代理、负载均衡、动静分离。 Nginx相关概念什么是Nginx​ Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。 特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好 。 **Nginx专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率 。**它支持内核Poll模型，能经受高负载的考验,有报告表明能支持高达 50,000个并发连接数。 https://lnmp.org/nginx.html 正向代理​ 如果把局域网外的Internet想象成一个巨大的资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务器就称为正向代理。 正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 反向代理​ 反向代理，其实客户端对代理是无感知的，客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。 ​ 反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率 。 负载均衡负载均衡*（Load Balance）*其意思就是分摊到多个操作单元上进行执行 ， 从而共同完成工作任务。 ​ 单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。 动静分离​ 为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。","categories":[{"name":"服务器软件","slug":"服务器软件","permalink":"http://ligangit.com/categories/服务器软件/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://ligangit.com/tags/nginx/"},{"name":"服务器软件","slug":"服务器软件","permalink":"http://ligangit.com/tags/服务器软件/"}]},{"title":"Mysql注意事项（一）","slug":"Mysql注意事项（一）","date":"2020-05-13T13:49:03.000Z","updated":"2020-07-18T16:06:50.879Z","comments":true,"path":"2020/05/13/Mysql注意事项（一）/","link":"","permalink":"http://ligangit.com/2020/05/13/Mysql注意事项（一）/","excerpt":"","text":"最近回顾了一下MySQL，发现了一些MySQL需要注意的事项，同时也作为学习笔记，记录下来。 Mysql注意事项（一）1、通配符*检索所有的列。 不建议使用​ 通常，除非你确定需要表中的每个列，否则最好别使用*通配符，虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。 优点​ 由于不明确指定列名（因为星号检索每个列），所以能检索出名字未知的列。 2、DISTINCT​ 用于检索不同的行（去重）。 不能部分使用DISTINCT​ DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id,prod_price FROM products ；会查找出vend_id和prod_price都不相同的内容，而不是vend_id去除重复，除非指定的两个列都不同，否则所有列都将被检索出来。 示例： 表数据：z 1SELECT * FROM products; 结果：共14条记录 使用DISTINCT获取供应商： 1SELECT DISTINCT vend_id FROM products; 结果：共4条记录 部分使用DISTINCT： 1SELECT DISTINCT vend_id,prod_price FROM products; 结果：共12条记录 结果查出了vend_id和prod_price都不相同的内容； 3、LIMIT限制结果，指定返回的行 使用方法示例： 123SELECT prod_name FROM productsLIMIT 5; 结果：返回前5行 示例：获取行3开始的4行，即第4至第8行 123SELECT prod_name FROM productsLIMIT 3,4; 等价于：从行3开始取4行 123SELECT prod_name FROM productsLIMIT 4 OFFSET 3; 注意：行0行0 ：检索出来的第一行为行0而不是行1.因此，LIMIT 1,1将检索出第二行而不是第一行。 4、ORDER BY​ 排序数据，降序DESC，升序ASC（默认，即如果不指定DESC、也不指定ASC，则假定为ASC） 在多个列上降序排序​ 如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。 ORDER BY 子句的位置​ 在给出ORDER BY 子句时，应该保证它位于FROM子句之后，如果使用LIMIT，它必须位于ORDER BY 之后。使用子句的次序不对将产生错误消息。 5、WHERE​ 过滤数据 WHERE子句的位置​ 在给出WHERE子句时，应该保证它位于FROM子句之后，如果同时使用ORDER BY，应该让ORDER BY位于WHERE 之后，否则将会产生错误。 BETWEEN 范围值检查BETWEEN匹配范围中的所有值，包括指定的开始值和结束值。 NULL 空值检查​ NULL 无值，它与字段包含0,、空字符串或仅仅包含空格不同。 NULL与不匹配IS NULL 和 IS NOT NULL 即为空和不为空 123456789--IS NULLSELECT cust_id From customerswhere cust_email IS NULL;-- IS NOT NULLSELECT cust_id From customerswhere cust_email IS NOT NULL; 在过滤数据时，一定要验证返回数据中确定给出了被过滤列具有NULL的行。 AND、OR注意：AND比OR的优先级更高，建议在WHERE子句中使用圆括号； 示例：（未使用圆括号） 123SELECT prod_name,prod_priceFROM productsWHERE vend_id=1002 OR vend_id=1003 AND prod_price&gt;=10; 结果： 分析： ​ SQL在处理OR操作符之前，优先处理AND操作符。当SQL看到上述的WHERE子句时，它理解为由供应商1003制造的任何价格为10美元（含）以上的产品，或者由供应商1002制造的任何产品，不管其价格如何。换句话说，由于AND在计算次序中优先级更高，操作符被错误的组合了。 IN、NOTIN操作符 ​ 与OR操作符相比较，IN有如下优点（建议替换OR）： 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观； 在使用IN时，计算次序更容易管理（因为使用的操作符更少）； IN操作符一般比OR操作符清单执行更快； IN最大的优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。 NOT操作符 ​ 使用NOT对IN、BETWEEN和EXISTS子句取反。 6、LIKE、通配符%和_​ LIKE指示MYSQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较，匹配整个列； 示例1： 123SELECT prod_nameFROM productsWHERE prod_name LIKE &apos;1000&apos; 结果：不会返回prod_name为1000的行 ​ %表示任何字符出现任意次数； 示例2：使用了通配符%的LIKE 123SELECT prod_nameFROM productsWHERE prod_name LIKE &apos;%1000&apos; 结果：不会返回prod_name为1000的行 ​ _表示任意单个字符出现一次。 ​ 通配符搜索的处理一般比其他搜索所花时间更长。 NULL与%通配符​ %通配符几乎可以匹配任何东西，但是不能匹配NULL 通配符使用技巧 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确定需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始出。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的配置。如果放错地方，可能不会返回想要的数据。 7、日期和时间处理函数​ MySQL使用的日期格式为yyyy-mm-dd； 日期比较​ 示例： 123SELECT cust_id,order_num,order_dateFROM ordersWHERE order_date=&apos;2005-09-01&apos; ​ 结果： ​ 注意：使用WHERE order_date=’2005-09-01‘ 可靠吗？ ​ order_date的数据类型为datetime，这种类型存储日期和时间值，表中的时间值为00:00:00，但实际中很可能并不总是这样。比如：order_date值为2005-09-01 11:30:05，则WHERE order_date=’2005-09-01’失败，即使给出具有该日期的一行，也不会检索出来，因为WHERE匹配失败。 ​ 解决方案： ​ 使用Date()函数。Date(order_date)函数指示MySQL仅提取列的日期部分，更可靠的SELECT语句为： 123SELECT cust_id,order_num,order_dateFROM ordersWHERE DATE(order_date)=&apos;2005-09-01&apos; ​ 结果： 建议​ 如果要的是日期，请使用Date()。 ​ 如果你想要的仅是日期，则使用Date()是一个良好的习惯，即使你如果知道相应的列只包含日期也是如此。这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个Time()函数，在你只想要时间时应该使用它。 8、聚集函数AVG()函数​ 通过对表中行数计算并计算特定列值之和，求得该列的平均值。 ​ 只能用于单列 。AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。 ​ NULL值 。AVG()函数忽略列值为NULL的行。 COUNT()函数 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值； 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。 示例1： 12SELECT COUNT(*) AS num_custFROM customers; ​ 结果1：对所有行计数，不管行中各列有什么值 ​ 示例2： 12SELECT COUNT(cust_email) AS num_custFROM customers; ​ 结果2：对cust_email列中有值的计数 ### MAX()函数、MIN()函数​ MAX()返回指定列中的最大值； ​ MIN()返回指定列中的最小值。 ​ 对非数值数据使用MAX()或MIN() 返回文本列中的最大值或最小值。 SUM()函数​ 用来返回指定列值的和（总计）。 ​ 示例1： 123SELECT SUM(quantity) AS items_orderedFROM orderitemsWHERE order_num=20005; ​ 结果1： ​ 在多列上进行计算 利用标准的算术操作符，所有聚集函数都可用来执行多个列上的计算。 ​ 示例2： 123SELECT SUM(item_price*quantity) AS items_orderedFROM orderitemsWHERE order_num=20005; ​ 结果2： 聚集不同值​ 对聚合函数AVG()、COUNT()、MAX()、MIN()、SUM()的使用： 对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）； 只包含不同的值，指定DISTINCT参数。 使用DISTINCT，查询特定供应商提供的产品的平均价格。 示例： 123SELECT AVG(DISTINCT prod_price) AS avg_priceFROM productsWHERE vend_id=1003; 结果：使用了DISTINCT，平均值只考虑各个不同的价格 注意：如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT(DISTINCT)，否则会产生错误。类似的，DISTINCT必须使用列名，不能用于计算或表达式。","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://ligangit.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"}]},{"title":"java获取操作系统信息","slug":"java获取操作系统信息","date":"2020-04-23T01:44:05.000Z","updated":"2020-05-29T02:52:30.712Z","comments":true,"path":"2020/04/23/java获取操作系统信息/","link":"","permalink":"http://ligangit.com/2020/04/23/java获取操作系统信息/","excerpt":"","text":"​ 之前碰到过一个BUG，发现是文件路径有误，因为开发环境是Windows，获取某个目录的时候是以盘符开头，如：D:\\，但是项目部署环境是Linux，Linux中文件路径是‘/’开头，所以报错了。写下这篇博客记录一下。 获取系统信息代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.net.InetAddress;import java.net.NetworkInterface;import java.util.ArrayList;import java.util.Formatter;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Properties;public class SystemTest &#123; //通过截取cmd流方式得到计算机的配置信息(不好) public static List&lt;String&gt; getIpAddress() &#123; Process p = null; List&lt;String&gt; address = new ArrayList&lt;String&gt;(); try &#123; p = new ProcessBuilder(\"ipconfig\", \"/all\").start(); &#125; catch (Exception e) &#123; return address; &#125; StringBuffer sb = new StringBuffer(); //读取进程输出值 InputStream inputStream = p.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(inputStream)); String s = \"\"; try &#123; while ((s = br.readLine()) != null) &#123; sb.append(s + \"\\n\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; inputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(sb); return address; &#125; public static void getIpconfig() &#123; Map&lt;String, String&gt; map = System.getenv(); System.out.println(map.get(\"USERNAME\"));//获取用户名 System.out.println(map.get(\"COMPUTERNAME\"));//获取计算机名 System.out.println(map.get(\"USERDOMAIN\"));//获取计算机域名 &#125; //得到计算机的ip地址和mac地址 public static void getConfig() &#123; try &#123; InetAddress address = InetAddress.getLocalHost(); NetworkInterface ni = NetworkInterface.getByInetAddress(address); //ni.getInetAddresses().nextElement().getAddress(); byte[] mac = ni.getHardwareAddress(); String sIP = address.getHostAddress(); String sMAC = \"\"; Formatter formatter = new Formatter(); for (int i = 0; i &lt; mac.length; i++) &#123; sMAC = formatter.format(Locale.getDefault(), \"%02X%s\", mac[i], (i &lt; mac.length - 1) ? \"-\" : \"\").toString(); &#125; System.out.println(\"IP：\" + sIP); System.out.println(\"MAC：\" + sMAC); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //得到计算机的ip,名称,操作系统名称,操作系统版本 public static void Config() &#123; try &#123; InetAddress addr = InetAddress.getLocalHost(); String ip = addr.getHostAddress().toString(); //获取本机ip String hostName = addr.getHostName().toString(); //获取本机计算机名称 System.out.println(\"本机IP：\" + ip + \"\\n本机名称:\" + hostName); Properties props = System.getProperties(); System.out.println(\"操作系统的名称：\" + props.getProperty(\"os.name\")); System.out.println(\"操作系统的版本：\" + props.getProperty(\"os.version\")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //其它的一些东西,会有用到的时候的 public static void all() &#123; Properties props = System.getProperties(); System.out.println(\"Java的运行环境版本：\" + props.getProperty(\"java.version\")); System.out.println(\"Java的运行环境供应商：\" + props.getProperty(\"java.vendor\")); System.out.println(\"Java供应商的URL：\" + props.getProperty(\"java.vendor.url\")); System.out.println(\"Java的安装路径：\" + props.getProperty(\"java.home\")); System.out.println(\"Java的虚拟机规范版本：\" + props.getProperty(\"java.vm.specification.version\")); System.out.println(\"Java的虚拟机规范供应商：\" + props.getProperty(\"java.vm.specification.vendor\")); System.out.println(\"Java的虚拟机规范名称：\" + props.getProperty(\"java.vm.specification.name\")); System.out.println(\"Java的虚拟机实现版本：\" + props.getProperty(\"java.vm.version\")); System.out.println(\"Java的虚拟机实现供应商：\" + props.getProperty(\"java.vm.vendor\")); System.out.println(\"Java的虚拟机实现名称：\" + props.getProperty(\"java.vm.name\")); System.out.println(\"Java运行时环境规范版本：\" + props.getProperty(\"java.specification.version\")); System.out.println(\"Java运行时环境规范供应商：\" + props.getProperty(\"java.specification.vender\")); System.out.println(\"Java运行时环境规范名称：\" + props.getProperty(\"java.specification.name\")); System.out.println(\"Java的类格式版本号：\" + props.getProperty(\"java.class.version\")); System.out.println(\"Java的类路径：\" + props.getProperty(\"java.class.path\")); System.out.println(\"加载库时搜索的路径列表：\" + props.getProperty(\"java.library.path\")); System.out.println(\"默认的临时文件路径：\" + props.getProperty(\"java.io.tmpdir\")); System.out.println(\"一个或多个扩展目录的路径：\" + props.getProperty(\"java.ext.dirs\")); System.out.println(\"操作系统的名称：\" + props.getProperty(\"os.name\")); System.out.println(\"操作系统的构架：\" + props.getProperty(\"os.arch\")); System.out.println(\"操作系统的版本：\" + props.getProperty(\"os.version\")); System.out.println(\"文件分隔符：\" + props.getProperty(\"file.separator\")); //在 unix 系统中是＂／＂ System.out.println(\"路径分隔符：\" + props.getProperty(\"path.separator\")); //在 unix 系统中是＂:＂ System.out.println(\"行分隔符：\" + props.getProperty(\"line.separator\")); //在 unix 系统中是＂/n＂ System.out.println(\"用户的账户名称：\" + props.getProperty(\"user.name\")); System.out.println(\"用户的主目录：\" + props.getProperty(\"user.home\")); System.out.println(\"用户的当前工作目录：\" + props.getProperty(\"user.dir\")); &#125; public static void main(String[] args) &#123; getConfig(); Config(); all(); &#125;&#125; 运行main方法部分结果： 获取文件路径（Windows 和Linux区别）注意： Windows的文件盘符是以盘符开头，如：D:\\ 但是 Linux的文件盘符是以’/‘开头，如：/usr/local 因此：我们在获取和系统相关的路径的时候，需要注意项目部署的环境，linux环境下的路径前面待’/‘，但是windows环境下的路径前面不带‘/’ 1234// 注意：windows环境下的路径获取// this.path = ClassUtils.getDefaultClassLoader().getResource(&quot;&quot;).getPath().substring(1);// 获取静态资源路径（去除了前面的/）// 注意：linux环境下的路径获取 this.path = ClassUtils.getDefaultClassLoader().getResource(&quot;&quot;).getPath();// 获取静态资源路径（不能去除前面的/）","categories":[{"name":"java","slug":"java","permalink":"http://ligangit.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"操作系统","slug":"操作系统","permalink":"http://ligangit.com/tags/操作系统/"}]},{"title":"java数据库保存文件路径注意事项","slug":"java数据库保存文件路径注意事项","date":"2020-04-09T07:37:04.000Z","updated":"2020-06-02T01:45:21.614Z","comments":true,"path":"2020/04/09/java数据库保存文件路径注意事项/","link":"","permalink":"http://ligangit.com/2020/04/09/java数据库保存文件路径注意事项/","excerpt":"","text":"Java上传或下载文件路径存储数据库注意事项数据库中存储全路径易造成读取文件为空​ 我们使用java下载或上传文件，文件路径一般都是保存在数据库中，如在数据库中建一张和此文件相关的表，其中包含文件路径字段。 ​ 我们上传或下载文件的时候一般都是使用绝对路径，如: D:/files/img1.png，而且我们在数据库中也直接把这整个绝对路径存储在里面了。 ​ 这就可能导致文件读取是因路径问题导致读取出来的文件为空。 ​ 特别是磁盘挂载后，很容易造成读取、下载出来的文件内容是空的。 ​ 注：磁盘挂载 原因​ 当我们上传和下载的方法不在同一个服务器上的时候，我们上传的路径可能是 D:/files/Apk/线上4_8.apk ，并且保存在数据库中： 我们下载时读取的是数据库中的绝对路径，从数据库中得到了文件所在路径为D:/files/Apk/线上4_8.apk ，但是下载接口在另外一台服务器上，我们采用了磁盘挂载后，在下载接口所在服务器访问上传的文件所在的路径为Z:/Apk/线上4_8.apk， 当我们下载时，下载接口读取的路劲为D:/files/Apk/线上4_8.apk ，实际需要为Z:/Apk/线上4_8.apk，所以造成了下载的文件为空。 解决方案 改数据库存储： ​ 数据库中存放的文件路径为文件名称，或者文件夹+/+文件名称 改java后台路径获取代码 我们将绝对路径的盘符放在配置文件中，当我们读取、上传、下载的时候从配置文件中获取盘符，将盘符和文件名一起组成绝对路径。 如：配置文件添加属性 uploadApk 修改前上传保存数据库java代码： 修改后上传保存数据库java代码： 修改前下载java代码： 修改后下载java代码： 这样我们读取、下载时获取的路径就是Z:/Apk/线上4_8.apk 配置文件修改 我们在部署项目的时候，只需要将上传文件项目部署时将配置文件修改为 下载文件项目部署时修改配置文件修改为 成功获取正确的文件！","categories":[{"name":"java","slug":"java","permalink":"http://ligangit.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"}]},{"title":"Spring学习-定时任务","slug":"Spring学习-定时任务","date":"2020-03-24T09:59:26.000Z","updated":"2020-06-02T01:44:41.332Z","comments":true,"path":"2020/03/24/Spring学习-定时任务/","link":"","permalink":"http://ligangit.com/2020/03/24/Spring学习-定时任务/","excerpt":"","text":"SpringBoot定时任务定时任务执行的代码注意： @Component //加入到容器中@EnableScheduling //定时任务或者周期任务的注解 @Scheduled(fixedDelay=ONE_Minute) //配置定时任务在执行完毕后多长时间再执行（示例中设置间隔60秒） 1234567891011121314151617181920@Component@EnableScheduling //定时任务或者周期任务的注解public class TestJob &#123; @Autowired private PushMapper pushMapper; public final static long ONE_Minute = 60 * 1000;//60s执行一次 @Scheduled(fixedDelay=ONE_Minute) public void getNameLimit2() &#123; try &#123; System.out.println(\"开始...\"); List&lt;Map&lt;String, Object&gt;&gt; overtimeList=pushMapper.queryPushProblemOvertime(null); System.out.println(overtimeList.get(0).toString()); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println(\"结束...\"); &#125;&#125; Dao层的mapper文件代码注意： @Mapper@Repository // 将这个文件配置到Bean，不然定时任务会取不到数据库数据 123456@Mapper@Repositorypublic interface PushMapper &#123; //查询未商定超时问题 List&lt;Map&lt;String,Object&gt;&gt; queryPushProblemOvertime(Map&lt;String, Object&gt; params);&#125; 结果","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"定时任务","slug":"定时任务","permalink":"http://ligangit.com/tags/定时任务/"}]},{"title":"Oracle判断值相等","slug":"Oracle判断值相等","date":"2020-03-24T02:57:55.000Z","updated":"2020-03-24T03:52:58.796Z","comments":true,"path":"2020/03/24/Oracle判断值相等/","link":"","permalink":"http://ligangit.com/2020/03/24/Oracle判断值相等/","excerpt":"","text":"​ 今天做项目的查询统计时，oracle数据库中有数据，但是带条件后一直查询不出来，最后发现了条件关联查询时，有NULL数据的比较，所以记录一下。 Oracle判断两个数据是否相等1、表数据student表： middle表： 2、判断两个都不可能为空数据直接使用 “=”： 1select * from student s,middle sc where s.sid=sc.sid 结果如下： 3、判断两个可能为空的数据继续使用“=”，发现为NULL数据不能判断相等 12select * from student s,middle sc where s.sid=sc.sid and s.email=sc.email 结果如下： 使用 NVL 函数： 12select * from student,sc where student.sid=sc.sid and NVL(student.email,0) = NVL(sc.email,0) 结果如下： 4、NVL函数NVL函数的格式如下：NVL(expr1,expr2) 含义是：如果oracle第一个参数为空那么显示第二个参数的值，如果第一个参数的值不为空，则显示第一个参数本来的值。 1select sname, NVL(email, '123456@qq.com') from student 结果如下： 注意： NVL(expr1,expr2)，expr1为变量，expr2为当expr1为空时，设置的默认值（一般为0）； 其中：NVL(expr1, 0)和NVL(expr1, ‘0’)的效果一样，最终expr1为空时值结果都为字符串‘0’。","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"},{"name":"oracle","slug":"oracle","permalink":"http://ligangit.com/tags/oracle/"}]},{"title":"SpringBoot学习-自动配置原理","slug":"SpringBoot学习-自动配置原理","date":"2020-01-18T09:29:41.000Z","updated":"2020-07-25T07:31:01.975Z","comments":true,"path":"2020/01/18/SpringBoot学习-自动配置原理/","link":"","permalink":"http://ligangit.com/2020/01/18/SpringBoot学习-自动配置原理/","excerpt":"","text":"Spring Boot学习-自动配置原理1. 自动配置原理 SpringBoot启动的时候加载主配置类，开启了自动配置功能==@EnableAutoConfiguration== @EnableAutoConfiguration作用： 利用AutoConfigurationImportSelector给容器中导入一些组件 可以查看selectImports()方法的内容； List configurations = this.getCandidateConfigurations(annotationMetadata, attributes); 获取候选的配置 1AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); //获取候选的配置 * 1234SpringFactoriesLoader.loadFactoryNames() ; //扫描所有jar包类路径下 META-INF/spring.factories //把扫描到的这些文件的内容包装成properties对象 //从properties中获取EnableAutoConfiguration.class类（类名）对应的值，然后把它们添加到容器中 ==将类路径 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 1234567org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\ org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\ 等等... 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来自动配置。 每一个自动配置类进行自动配置功能； 以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728293031323334@Configuration( proxyBeanMethods = false) //表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) //启动指定类的ConfigurationProperties功能；将配置文件中的值和HttpProperties绑定起来；并把HttpProperties加入到ioc容器中@ConditionalOnWebApplication( type = Type.SERVLET) //Spring底层@Conditional注解，根据不同的条件如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中乱码解决过滤器；@ConditionalOnProperty( prefix = \"spring.http.encoding\", value = &#123;\"enabled\"&#125;, matchIfMissing = true) //判断配置文件中是否存在某个配置spring.http.encoding.enabled;如果不存在，判断也是成立的//即使我们配置文件中不配置spring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; @Bean //给容器中添加一个组件，这个组件中的某些值需要从properties中获取 @ConditionalOnMissingBean //判断容器中没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一旦这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties( prefix = \"spring.http\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpProperties &#123; 2. 精髓 SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； 我们再来看这个自动配置类中底层配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfiguration：自动配置类；给容器中添加组件 xxxxProperties：封装配置文件中相关的属性； 3. 细节 @Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类在一定条件下才能生效； 我们怎么知道哪些自动配置类生效； 我们可以启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； 12345678910111213141516171819202122232425262728============================CONDITIONS EVALUATION REPORT============================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet' (OnClassCondition) - found 'session' scope (OnWebApplicationCondition) DispatcherServletAutoConfiguration.DispatcherServletConfiguration matched: - @ConditionalOnClass found required class 'javax.servlet.ServletRegistration' (OnClassCondition) - Default DispatcherServlet did not find dispatcher servlet beans (DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition)Negative matches:(没有启动，没有匹配成功的自动配置类)----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class 'javax.jms.ConnectionFactory' (OnClassCondition) AopAutoConfiguration.AspectJAutoProxyingConfiguration: Did not match: - @ConditionalOnClass did not find required class 'org.aspectj.weaver.Advice' (OnClassCondition)","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"自动配置","slug":"自动配置","permalink":"http://ligangit.com/tags/自动配置/"}]},{"title":"SpringBoot学习-配置文件","slug":"SpringBoot学习-配置文件","date":"2019-12-14T09:09:16.000Z","updated":"2020-07-25T07:22:19.346Z","comments":true,"path":"2019/12/14/SpringBoot学习-配置文件/","link":"","permalink":"http://ligangit.com/2019/12/14/SpringBoot学习-配置文件/","excerpt":"","text":"SpringBoot学习-配置文件和注解1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的： application.properties application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML( YAML Ain’t a Markup Language ) ​ YAML Ain’t a Markup Language : YAML不是一种标记语言； ​ Yet Another Markup Language ： 仍是一种标记语言； 标记语言： ​ 以前的配置文件，大多都是使用的是xxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法1、基本语法​ k:[空格]v 表示一对键值对（空格必须有）； ​ 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的; 123server: port: 8081 path: /hello ​ 属性和值也是大小写敏感； 2、值的写法 字面量： 普通的值（数字，字符串，布尔） k: v ：字面直接来写： ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi” ：输出：zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符数据 ​ name: ‘zhangsan \\n lisi’：输出：zhangsan \\n lisi 对象、Map（属性值）（键值对）： k: v ：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set） 用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入 配置文件 123456789101112person: lastName: zhangsan age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: v2&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2 javaBean 12345678910111213141516/* 将配置文件中配置的每一个属性的值，映射到组件中* @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定* prefix = \"person\" ：配置文件中哪个下面的所有属性进行一一映射* 只有这个组件是容器中的组件，才能还用容器@ConfigurationProperties提供的功能* */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 12345&lt;!--导入配置文件处理器,配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/dependency&gt; 4、@ConfigurationProperties和@Vlaue获取值比较 @ConfigurationProperties @Vlaue 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value; 如果说，我们专门编写了一个JavaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； @ConfigurationProperties(prefix = “person”)默认从全局配置文件中获取。 5、配置文件注入值数据校验1234567891011121314151617@Component@ConfigurationProperties(prefix = \"person\")@Validated //添加数据校验public class Person &#123; @Email //lastName必须是邮箱格式 （@ConfigurationProperties才支持）// @Value(\"$&#123;person.last-name&#125;\") //支持// @Value(\"$&#123;person.lastName&#125;\") //不支持（-n替换为N） private String lastName;// @Value(\"#&#123;11*2&#125;\") private Integer age;// @Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 6、@PropertySource和@ImportResource@PropertySource​ @PropertySource：加载指定的配置文件； 1234567891011121314151617181920/* 将配置文件中配置的每一个属性的值，映射到组件中* @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定* prefix = \"person\" ：配置文件中哪个下面的所有属性进行一一映射* 只有这个组件是容器中的组件，才能还用容器@ConfigurationProperties提供的功能* @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取* */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validated //添加数据校验public class Person &#123; // @Email //lastName必须是邮箱格式 （@ConfigurationProperties才支持）// @Value(\"$&#123;person.last-name&#125;\")// @Value(\"$&#123;person.lastName&#125;\") //（不支持-n替换为N） private String lastName;// @Value(\"#&#123;11*2&#125;\") private Integer age;// @Value(\"true\") private Boolean boss; @ImportResource​ @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； Spring Boot里面，没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；想让Spring的配置文件生效，加载进来；需要把@ImportResource标注在一个配置类上； 12//Spring的配置文件，让其生效@ImportResource(locations = &#123;\"classpath:bean.xml\"&#125;) ​ 现在不在编写Spring的配置文件 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.ligangit.springbootstudy.service.HelloService\"&gt; &lt;/bean&gt;&lt;/beans&gt; ​ SpringBoot推荐给容器中添加组件的方式：推荐使用全注解的方式 配置类====Spring配置文件 使用@Bean给容器中添加组件 123456789101112131415/** * @Configuration 指明当前类是一个配置类，就是来替代之前的Spring配置文件 * 在配置文件中使用&lt;bean&gt;&lt;/bean&gt;标签添加组件 * 现在使用@Bean给容器中添加组件 */@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名 @Bean public HelloService helloService()&#123; System.out.println(\"配置类中@Bean给容器中添加组件了。。。\"); return new HelloService(); &#125;&#125; 7、配置文件中的占位符 随机数 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 占位符获取之前配置的值，如果没有，那么值默认是表达式，也可以用“:”指定默认值（如 ${person.hello:hello}） 123456789101112person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.boss=falseperson.birth=2017/12/12person.maps.k1=v1person.maps.k2=v4person.lists=a,b,c#person.dog.name=$&#123;person.last-name&#125;_小狗#如果占位符的值没有，那么值默认是表达式，如$&#123;person.hello&#125;，那么输出$&#123;person.hello&#125;# 也可以设置默认值，如$&#123;person.hello:hello&#125;，那么输出helloperson.dog.name=$&#123;person.hello:hello&#125;_小狗person.dog.age=2 8、ProfileProfile是Spring对不同环境提供不同配置功能的支持，可以激活、指定参数等方式快速切换环境 多Profile文件格式在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml； 默认使用application.properties的配置； yml支持多文档块方式1234567891011121314151617server: port: 8081spring: profiles: active:prod---server: port: 8082spring: profiles:dev---server: port: 8084spring: profiles:prod --指定属于哪个环境 激活指定profile 在配置文件中指定 spring.profiles.active=dev 命令行： 打包后启动的时候 java -jar hello.jar –spring.profiles.active=dev 直接在测试的时候，配置传入命令行参数 –spring.profiles.active=dev 虚拟机参数： -Dspring.profiles.active=dev 9、配置文件加载位置​ SpringBoot启动会扫描application.properties或者application.yml文件作为springboot的配置文件。默认创建项目生成application.properties/yml位置在classpath目录下，也可以在以下4个地方创建，优先级自上而下由高到低，SpringBoot会从这四个位置全部加载主配置文件，各个配置文件成互补状态存在，高优先级的配置会覆盖低优先级的配置。 -file: ./config/ 当前项目下的config文件夹 -file: ./ 当前项目下 -classpath: /config/ 类路径下的config文件夹 -classpath:/ 类路径的根目录 ​ ==还可以通过spring.config.location来改变默认的配置文件位置（在配置文件中配置是没有用的，必须在打包后使用此命令）== ​ 使用示例：java -jar hello.jar –spring.config.location=D:/application.properties ​ 项目打包好后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同其作用形成互补配置。 10、外部配置加载顺序SpringBoot也可以从以下位置加载配置：优先级从高到底，高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置 命令行参数 java -jar hello.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开；–配置项=值 来自java:comp/env的JNDI属性 Java系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource配置的random.*属性值 jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 直接将配置文件放在和jar包同级的目录下 直接使用 java -jar 启动就OK jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 jar包外部的application.properties或application.yml(不带spring.profile)配置文件 jar包内部的application.properties或application.yml(不带spring.profile)配置文件 @Configuration注解类上的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 ​ 首先看有没有带profile，然后再看配置文件在jar包内还是外，带profile&gt;没带profile，jar包外&gt;jar包内； ​ ==有jar包外向jar包内进行寻找，优先加载带profile的配置文件，再加载不带profile的配置文件==","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"注解","slug":"注解","permalink":"http://ligangit.com/tags/注解/"}]},{"title":"SpringBoot学习-HelloWorld探究","slug":"SpringBoot学习-HelloWorld探究","date":"2019-12-11T09:26:54.000Z","updated":"2020-06-02T01:44:12.379Z","comments":true,"path":"2019/12/11/SpringBoot学习-HelloWorld探究/","link":"","permalink":"http://ligangit.com/2019/12/11/SpringBoot学习-HelloWorld探究/","excerpt":"","text":"SpringBoot学习-Hello World探究1、POM文件1、父项目1234567891011121314 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath&gt;../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来正真管理Spring Boot应用里面的所有依赖版本 Spring Boot的版本依赖中心； 以后我们导入的依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要申明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web： ​ spring-boot-starter：spring boot场景启动器，帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个starters（启动器），只需要在项目里面引入这些starters，相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景的启动器。 2、主程序类，主入口类12345678910/***@Description @SpringBootApplication 来标注一个主程序类，说明这是一个SpringBoot类*/@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class, args); &#125;&#125; @SpringBootApplication： Spring Boot应用标注在某个类上说明这个类是Spring Boot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用。 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; ​ 1、@SpringBootConfiguration: SpringBoot配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类……配置文件：配置类也是容器中的一个组件：@Component ​ 2、@EnableAutoConfiguration:开启自动配置功能； ​ 以前我们需要配置的东西，Sping Boot帮我们自动配置；@EnableAutoConfiguration告诉我们SpringBoot开启自动配置功能；这样的自动配置才能生效； 123@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage: 自动配置包 ​ @Import({Registrar.class})： ​ Spring的底层注解@Import，给容器导入一个组件；导入的组件有Registrar.class； ​ ==将主配置类（@SpringBootConfiguration标注的类）的所在包及下面子包里面的所有组件扫描到Spring容器；== ​ @Import({AutoConfigurationImportSelector.class}): ​ AutoConfigurationImportSelector: 导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxAutoConfiguration）;就是给容器中导入这个场景需要的所有组件，并配置好这些组件； ​ 有了自动配置类，免去了我们手动编写配置注入功能组件等工作； ​ ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们做了； ​ J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-2.2.2.RELEASE.jar；","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"}]},{"title":"SpringBoot学习-项目创建","slug":"SpringBoot学习-项目创建","date":"2019-12-09T08:32:12.000Z","updated":"2020-07-18T16:02:01.534Z","comments":true,"path":"2019/12/09/SpringBoot学习-项目创建/","link":"","permalink":"http://ligangit.com/2019/12/09/SpringBoot学习-项目创建/","excerpt":"","text":"SpringBoot学习-项目创建1、搭建环境 jdk1.8以上 maven3.3以上 IDEA2019 2、创建Maven项目​ 创建一个普通的Maven项目 3、在pom.xm添加依赖123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4、编写一个主程序：启动SpringBoot应用123456789@SpringBootApplication // 来标注一个主程序类，说明这是一个Spring Boot项目public class Application &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(Application.class, args); &#125;&#125; 5、编写相关的Controller、Service注意：controller、service包和主程序类同级 123456789@Controllerpublic class HelloWorldController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 6、运行主程序测试http://localhost:8080/hello 7、简化部署123456789&lt;!--这个插件，可以将引用打包成一个可执行的jar包--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打包成jar包，直接使用java -jar的命令执行 8、快速创建Spring Boot项目 File -&gt; New -&gt; Project，选择Spring Initializr，选择JDK 设置组织ID，模块ID 选择应用场景，导入对应依赖，如选择Web 设置工程名（一般为默认值），然后Finish 向导联网会自动创建Spring Boot项目，目录结构如下，其中选中的文件一般无用，可以删除 默认生成的Spring Boot项目； 主程序已经生成好了，我们只写需要我们自己的逻辑 resource文件夹中目录结构 static：保存所有的静态资源，如 js、css、images; templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker，thymeleaf）; application.properties：Spring Boot的配置文件 默认目录结构如下：","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"}]},{"title":"Oracle导出导入数据库","slug":"Oracle导出导入数据库","date":"2019-11-13T08:43:46.000Z","updated":"2020-06-02T01:44:50.312Z","comments":true,"path":"2019/11/13/Oracle导出导入数据库/","link":"","permalink":"http://ligangit.com/2019/11/13/Oracle导出导入数据库/","excerpt":"","text":"Oracle数据库导出1、查询地址​ 查询数据库配置的地址 1select * from dba_directories; 2、导出​ 进入Oracle服务器，打开CMD，运行导出命令。 语法：12345678910111213--语法expdp oracle_user_name/oracle_user_pwd@ip:port/ ORACLE_SID directory=file_save_address DUMPFILE=exprot_file_name.dmp logfile=exprot_logfile_name.log REUSE_DUMPFILES = Y version=version_num--名词解释(这些名词都需要换成个人实际的信息)--oracle_user_name 数据库用户名称--oracle_user_pwd 数据库用户密码--ip ip地址（服务器ip地址，个人登录Oracle时填写的IP，也是数据库的ip地址）--port 端口号--ORACLE_SID 数据库实例--file_save_address 数据库保存路径（是数据库配置地址的别名）--exprot_file_name.dmp 导出数据库名称（.dmp不能更改）--exprot_logfile_name.log 导出数据库生成的日志文件名称（.log不能更改）--version_num 数据库版本 （version=version_num 可以不带上） 示例： 本人登录Oracle的用户信息： ​ 2、执行SQL语句： 1select * from dba_directories; 得到地址信息： ​ ​ 我选择将导出文件保存在G:\\app\\Administrator/admin/credit/dpdump/目录下，所以选择的file_save_address为DATA_PUMP_DIR，这个地址是Oracle服务器所安装的主机中的地址。 在Oracle服务器所安装的主机上运行CMD命令 ​ 导出mydb用户下的数据库，并将地址保存在DATA_PUMP_DIR 目录下，导出文件名为mydb20191113_expdp.dmp ，导出的日志文件为mydb20191113_expdp.log，Oracle数据库版本为11.2.0.1.0 12--示例expdp mydb/123456@192.168.168.138:1521/CREDIT directory=DATA_PUMP_DIR DUMPFILE=mydb20191113_expdp.dmp logfile=mydb20191113_expdp.log REUSE_DUMPFILES = Y version=11.2.0.1.0 注意： ​ DATA_PUMP_DIR 是在Oracle管理工具中执行SQL语句后的地址信息中有一条地址名称。 Oracle数据库导入1、查询用户名​ 查询需要导入的数据库的用户名是否存在，如果不存在需要创建用户、创建表空间，创建好之后，再执行导入数据库操作；如果用户存在则直接执行导入数据库操作。 1select * from dba_users; 2、创建用户、表空间查询Oracle地址​ 在执行创建用户、表空间之前，我们需要知道表空间的创建的地址，继续使用查询地址SQL（在需要导入的数据库中执行），查看Oracle的地址。 1select * from dba_directories; ​ 继续使用导出时的Oracle数据库： ​ 语法：12345678910111213--创建表空间create tablespace oracle_user_name datafile 'oracle_address/tablespace_name.DBF' size 200m reuse autoextend on next 200m maxsize unlimited default storage(initial 128k next 128k minextents 2 maxextents unlimited);--创建表空间中的用户create user user_name identified by user_password default tablespace tablespace_name;--授权grant dba,connect,resource,create any table,select any table,update any table,insert any table,delete any table ,drop any table to tablespace_name;--名词解释(这些名词都可以换成自己需要的)--oracle_address 查询数据库地址时的地址，也是导入文件存放的地址--tablespace_name 表空间名称--user_name 用户名--user_password 用户密码 示例：​ 我选择在E:/export_dir目录下创建表空间qydj，用户名为qydj，密码为1。 123create tablespace NECIPS_ZSTZSB datafile 'E:/export_dir/qydj.DBF' size 200m reuse autoextend on next 200m maxsize unlimited default storage(initial 128k next 128k minextents 2 maxextents unlimited);create user qydj identified by 1 default tablespace qydj;grant dba,connect,resource,create any table,select any table,update any table,insert any table,delete any table ,drop any table to qydj; 导入数据 首先将需要导入的数据库文件复制到Oracle的一个地址目录下； 执行CMD导入命令。 语法：1234567891011impdp user_name/user_password directory=EXPORT_DIR dumpfile=exprot_file_name.DMP remap_schema=old_schema:new_schema remap_tablespace=old_tablespace:new_tablespace logfile=import_file_log.log--名词解释(这些名词都换成自己实际的内容)--user_name 刚创建的用户名--user_password 刚创建的用户的密码--oracle_address 需要导入的数据库的文件地址（这个地址是在oracle中配置好的，我们将数据库的.dmp文件复制到这个目录下）--old_schema 模式名称（一般为导入数据库的用户名）--new_schema 模式名称（一般为刚创建的用户名）--old_tablespace 表空间（导入数据库的表空间）--new_tablespace 表空间（刚创建的表空间）--import_file_log 日志文件（导入操作生成的日志文件） 示例：​ 将之前导出的数据库导入到上一步创建的qydj用户下。 1impdp qydj/1 directory=oracle_address dumpfile=mydb20191113_expdp.DMP remap_schema=mydb:qydj remap_tablespace=mydb:qydj logfile=qydj20191113.log ​ 注意： ​ 我们在导入的时候可能会报用户名已存在，视图、存储过程报错（已编译，但有警告），这些是没关系的，这些可能是我们的视图、存储过程跨用户查询了数据。","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"},{"name":"oracle","slug":"oracle","permalink":"http://ligangit.com/tags/oracle/"}]},{"title":"idea打开新Web项目并运行","slug":"idea打开新Web项目并运行","date":"2019-11-06T01:46:24.000Z","updated":"2020-06-11T02:20:32.503Z","comments":true,"path":"2019/11/06/idea打开新Web项目并运行/","link":"","permalink":"http://ligangit.com/2019/11/06/idea打开新Web项目并运行/","excerpt":"","text":"​ 记得刚开始使用idea的时候，拿到一个web项目，却不知道怎么跑起来，这几天打开完整的Web项目有点多，而且一开始也忘记了怎么配置，今天就写了这篇博客。 一、配置Web结构（设置war包）1、使用IDEA打开项目，进入Project Structure点击File，选择Project Structure，操作如下图： 2、添加Modules点击Modules，然后点击”十“按钮，选择Web，操作如下图： 点击Web后会得到下面的效果图，在在图中我修改好了web.xml文件路径、根路径，我们将红色框中的内容改为自己web项目中web.xml的路径信息就可以了： 3、添加Artifacts点击Artifacts，然后点击”十“按钮，选择Web Application:Exploded，点击 From Modules…，然后会弹出选择Modules框，操作如下图： 选择我们刚创建号的Modules，点击OK，如下图： 4、添加jar包点击Libraris，然后点击”十“按钮，选择Java，操作如下图： 选择jar包，jar包在WEB-INF文件夹下的lib文件夹中，我们可以之间选择lib文件夹，也可以选择lib中的jar包，选择之后会弹出选择Modules框，点击OK就可以了，操作如下图： 5、点击Apply，点击OK二、配置tomcat1、添加tomcat sercer点击Add Configuration，再点击“十”按钮，然后将鼠标焦点放置在Tomcat Server上，选择Local，进入Tomcat信息配置窗口，操作如下图： 2、配置Tomcat信息弹出的Tomcat信息窗口如下图： 第一项 是设置的IDEA显示的Tomcat名称； 第二项 是自己的Tomcat版本； 第三项 是JRE，可以选择自己安装的JDK下的jre文件 第四项 是运行的web包，即之前配置的war包 我们需要点击Fix，添加运行的war包，点击Fix后，出现如下界面： 在这里我们可以修改项目访问路径，如果像上面的界面一样，那么访问项目的URL就是： http://localhost:8080/zhirong_wisdomFire_war_exploded 其中“/zhirong_wisdomFire_war_exploded ”就是8080后面的项目路径，我们可以修改成自己想要的值，如“/”，那么访问地址就是： http://localhost:8080/ 3、最后点击“Apply”，点击”OK“得到如下界面 我们点击红色方框中的绿色三角形按钮，即“启动”按钮就可以启动项目了。","categories":[{"name":"java","slug":"java","permalink":"http://ligangit.com/categories/java/"}],"tags":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"},{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"idea","slug":"idea","permalink":"http://ligangit.com/tags/idea/"},{"name":"web","slug":"web","permalink":"http://ligangit.com/tags/web/"}]},{"title":"idea对web项目打war包","slug":"idea对web项目打war包","date":"2019-11-04T09:10:23.000Z","updated":"2020-06-11T01:50:25.506Z","comments":true,"path":"2019/11/04/idea对web项目打war包/","link":"","permalink":"http://ligangit.com/2019/11/04/idea对web项目打war包/","excerpt":"","text":"​ 很多时候，完成项目需要打成war包，然后部署在服务器里面，对于小白来说，一开始会不知道怎么打包，我就是经历过，所以将这个打包的过程写下来。 ​ 下面有两种打包方式，一种是传统的web项目，一种是maven项目。 传统web项目打war包1、File –&gt;Project Structure，如下图： 2、点击”Artifacts“，然后在右边的界面中点击”十“号，选择”Web Application:Archive“，选择打包项，选择后就可以点击”Apply“按钮了，操作如下图： 3、执行打包过程，点击”Build”，选择“Build Artifacts”，选择war包，然后先点击“Clean”,清空下，清空之后，在此点击”Build”，选择“Build Artifacts”，选择war包，然后先点击“Bulid”,清空下，操作如下图： 4、打包好的War包在classes –&gt; artifacts ,如下图 Maven项目打war包1、点击窗口右边的”Maven”，弹出窗口； 2、点击“Clean”，先清空项目； 3、点击“Insatll”，打jar包； 4、点击“Pagkage”，打War包。 具体操作如下图： 5、打包好的War包在target文件夹下 ,如下图","categories":[{"name":"java","slug":"java","permalink":"http://ligangit.com/categories/java/"}],"tags":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"},{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"idea","slug":"idea","permalink":"http://ligangit.com/tags/idea/"},{"name":"web","slug":"web","permalink":"http://ligangit.com/tags/web/"}]},{"title":"博客加载图片","slug":"博客加载图片","date":"2019-10-25T09:34:56.000Z","updated":"2019-11-04T10:11:44.284Z","comments":true,"path":"2019/10/25/博客加载图片/","link":"","permalink":"http://ligangit.com/2019/10/25/博客加载图片/","excerpt":"","text":"​ 如今开始写博客了，最近几篇博客需要用到图片，但是一直不知道怎么解决，使用markdown语法的图片，使用markdown编辑软件可以看到，但是在网页上加载不出来，一直在网上查找解决方案，现在可以展示图片了，现在将这方法写下来。 创建文件夹在博客目录下的资源文件夹下创建保存图片的文件下。 博客目录如下： 在source目录下创建images文件夹，用于保存图片。 如下图： 在博客中引用图片移动图片​ 我们将需要引用的图片放在images文件夹里面，当然也可以创建多个文件夹分批保存图片，如下图。 使用图片方法一：​ 在博文中需要引用图片的位置编写如下语法： 123456![图片解释说明](图片路径) 图片解释说明是显示图片下面的字； 图片路径 是存放图片的路径； 如：我刚创建的images,引用地址就是 /images/图片名字： ![博客引用图片](/images/show.png) ​ 效果如下： 方法二：​ 使用&lt;img&gt; 标签，就如写html插入图片一样： 123456&lt;img src=\"图片路径\" alt=\"图片解释说明文字\"&gt; 图片路劲 是存放图片的路径； alt属性可有可无； 如：我刚创建的images,引用地址就是 /images/图片名字： &lt;img src=\"/images/show.png\" alt=\"博客引用图片\"&gt; ​ 效果如下： 缺陷​ 这种在博客中添加图片的方式，在加载图片的时候可能会比较慢，特别是图片过多的时候，项目会比较大，最好是将图片托管在图片网站，然后直接使用网上地址。 注意​ 当我们把博客托管在github上后，我们在使用hexo s 命令，本地运行后，可能会显示不出图片，这是因为hexo g 命令会将图片的地址转换为网络地址，会带上你的gtihub网址，这时我们想在本地看到效果的化，先执行 hexo d ,上传到github，然后在hexo s，在本地查看效果。","categories":[{"name":"博客","slug":"博客","permalink":"http://ligangit.com/categories/博客/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://ligangit.com/tags/markdown/"},{"name":"博客","slug":"博客","permalink":"http://ligangit.com/tags/博客/"}]},{"title":"mysql之数据合并","slug":"mysql之数据合并","date":"2019-10-11T03:49:05.000Z","updated":"2019-11-13T10:12:48.927Z","comments":true,"path":"2019/10/11/mysql之数据合并/","link":"","permalink":"http://ligangit.com/2019/10/11/mysql之数据合并/","excerpt":"","text":"​ 在进行数据库的数据整理的时候，特别是对新老平台、规则替换的时候，会碰到数据合并的问题，我将这次整理过程的数据合并写了这篇博客。 需求表中存在很多需要合并的内容，如下图 将两列数据保留一条，并且内容合并在一起，需要将内容顺序拼接。 方法使用left join 连接，将保留的信息，和合并的内容连接； 使用CONCAT(str1,str2,…) 函数，拼接字符串； 使用CHAR_LENGTH(str) 函数，判断内容字符串的长度，便于内容顺序合并。 12345678910111213141516171819202122-- 3、保存需要合并的内容create table smcontent22 ( select SM_ID ,destaddr , DATE_FORMAT(sendtime,&apos;%Y-%m-%d&apos;) sendtime,SM_CONTENT from tbl_smresult where PROTOCOLTYPE=3 and SM_CONTENT not like &apos;【政务外网短信平台】%&apos; and pktotal&gt;1) ;-- 4.2 合并两条短信的内容 UPDATE tbl_smresult a left join smcontent22 b on a.SM_ID =b.SM_ID and a.PROTOCOLTYPE=&apos;3&apos; and a.destaddr=b.destaddr set a.SM_CONTENT= CONCAT(a.SM_CONTENT,b.SM_CONTENT) where a.SM_ID =b.SM_ID and a.PROTOCOLTYPE=&apos;3&apos; and a.destaddr=b.destaddr and DATE_FORMAT(a.sendtime,&apos;%Y-%m-%d&apos;)=b.sendtime and CHAR_LENGTH(b.SM_CONTENT)&lt;67 and a.SM_CONTENT like &apos;【政务外网短信平台】%&apos; ;","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://ligangit.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"},{"name":"数据处理","slug":"数据处理","permalink":"http://ligangit.com/tags/数据处理/"}]},{"title":"mysql存储过程学习","slug":"mysql存储过程编写","date":"2019-09-29T01:20:49.000Z","updated":"2019-11-13T10:12:32.722Z","comments":true,"path":"2019/09/29/mysql存储过程编写/","link":"","permalink":"http://ligangit.com/2019/09/29/mysql存储过程编写/","excerpt":"","text":"​ 进行Java Web 项目的时候，经常需要执行数据库查询，有时对一些表数据进行统计，特别是统计分析的时候，原有的SQL执行会比较慢，而且每次点击都会比较慢，如今使用存储过程，可以将那些不需要实时展示的统计数据统计并存储在统计结果表里面，提高查询速度。 mysql存储过程学习1、申明存储过程1CREATE DEFINER = CURRENT_USER PROCEDURE `demo`() 2、存储过程开始和结束符号所有的内容SQL语句都是写在BEGIN END 里面。 123BEGIN #Routine body goes here...END; 3、变量定义 int类型： 变量名 num，类型 int，无符号， 默认值 4000000。（默认值可以不设置，即 default 4000000可去掉） 1DECLARE num int unsigned default 4000000; varchar类型： 变量名Mobile ，类型VARCHAR，长度50，默认值 hello。（默认值可以不设置，即 default ‘hello’ 可去掉） 编码格式 charset ‘utf8’ 设置编码格式为utf8。 1DECLARE Mobile VARCHAR(50) default &apos;hello&apos; charset &apos;utf8&apos;; 4、变量赋值 已定义变量赋值(局部变量) 方法一：使用set 1set Mobile=&apos;world&apos;; 方法二：使用select …. into… 1234select mobile into Mobile from students where id=1; 未定义变量直接赋值（用户变量） 方法一：使用set 1set @email=&apos;12345@qq.com&apos;; 方法二：使用select …. into… 12set @email=&apos;&apos;;select @email :=email from students; 5、条件语句 if-then-else语句 123if startyear&gt;2016 then select name from students;end if; 12345if startyear&gt;2016 then select name from students;else select email from students;end if; case语句 1x 1declare var int; 2set var=0;3case var4when 0 then5 select name from students;6when 1 then7 select email from students;8else9 select mobile from students;10end case;mysql 6、循环语句 while ···· end while 123456declare var int; set var=0;while var&lt;3 do select name from students where id=var; set var=var+1;end while; repeat···· end repea 操作后判断循环条件，while是先判断循环条件在执行循环体。 1234567declare var int; set var=0;repeat select name from students where id=var; set var=var+1;until var&gt;2end repeat; loop ·····endloop loop 循环不需要初始条件，这点和 while 循环相似，同时和 repeat 循环一样不需要结束条件, leave 语句的意义是离开循环。 12345678declare var int; set var=0;LOOP_LABLE:loop set var=var+1; if var&gt;2 then leave LOOP_LABLE; end if;end loop; 7、游标的使用 定义游标及数据 1234-- mobile变量接收游标中的值DECLARE Mobile VARCHAR(50) ; DECLARE UpdateAuthorCursor CURSOR for SELECT name from students; 设置游标内容执行完毕标志 1DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; 打开游标 1open UpdateAuthorCursor; 循环游标内数据 123456789posLoop:LOOP --判断是否结束循环 if done then leave posLoop; end if; --取出游标中的数据，并保存在变量中 FETCH UpdateAuthorCursor into Mobile; update students set mobile=Mobile where id=0; end LOOP; 关闭游标 1close UpdateAuthorCursor; 8、示例1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 创建存储过程CREATE DEFINER=`root`@`localhost` PROCEDURE `merge2019`()BEGIN-- 定义变量DECLARE yearnum int DEFAULT year(CURRENT_DATE); DECLARE Mobile VARCHAR(50) ; DECLARE Content VARCHAR(3200) ; DECLARE Taskid VARCHAR(255) ; DECLARE Sendtime VARCHAR(255) ; -- 创建游标 DECLARE done INT DEFAULT FALSE; DECLARE UpdateAuthorCursor CURSOR for SELECT b.CONTENT,b.MOBILE , case when b.TASKID is not null then b.TASKID else &apos;&apos; end as TASKID , DATE_FORMAT(b.SENDTIME,&apos;%Y-%m-%d&apos;) as sendtime FROM jx_sendresult_2019_1 b; -- 设置游标循环结束标志 DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;-- 打开游标 OPEN UpdateAuthorCursor; -- 循环游标内容 read_loop: LOOP FETCH UpdateAuthorCursor INTO Content, Mobile, Taskid, Sendtime; -- 设置循环结束标识 IF done THEN LEAVE read_loop; END IF; -- 执行SQL操作 select count(1) from tbl_smresult; UPDATE tbl_smresult_2019_2 SET MSGID = Taskid WHERE SM_CONTENT= Content and DESTADDR= Mobile and MSGID =&apos;&apos; and DATE_FORMAT(SENDTIME,&apos;%Y-%m-%d&apos;)=Sendtime limit 1; COMMIT; END LOOP; -- 关闭游标 CLOSE UpdateAuthorCursor; -- 结束存储过程END","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://ligangit.com/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"},{"name":"存储过程","slug":"存储过程","permalink":"http://ligangit.com/tags/存储过程/"},{"name":"游标","slug":"游标","permalink":"http://ligangit.com/tags/游标/"}]},{"title":"取出hibernate执行的SQL的结果集","slug":"取出hibernate执行的SQL的结果集","date":"2019-09-25T09:34:56.000Z","updated":"2020-06-11T02:14:03.267Z","comments":true,"path":"2019/09/25/取出hibernate执行的SQL的结果集/","link":"","permalink":"http://ligangit.com/2019/09/25/取出hibernate执行的SQL的结果集/","excerpt":"","text":"​ 最近碰到了BUG，在操作hibernate的SQL结果集的时候报类型转换错误，在这个问题上花费了好多时间，就将这个BUG的解决心得写在了这篇博客里面。 取出hibernate执行的SQL的结果集java取出数据报错最近在一个SSH项目中碰到了一个获取数据的问题，SQL执行后的结果集使用类型转换提取数据时报错。 下面是DAO层实现类中的方法：返回了结果集List。 1234567891011121314151617181920public List&lt;TblSwitch&gt; getPagelist(Integer limit, Integer offser, String where, Object[] obj) &#123; logger.info(\"get getPagelist by:\"); String sql=\"select a.add_user, \" + \" a.old_protocol,a.now_protocol,a.mobile,a.add_time,a.delete_mark,a.update_time,a.id,a.remark \" + \" from tbl_switch a where 1=1 and a.delete_mark=0 \"+where+\" ORDER BY a.add_time DESC \"; List&lt;TblSwitch&gt; list=null; try&#123; Query query=this.getSession().createSQLQuery(sql).setFirstResult(limit).setMaxResults(offser); if(null !=obj&amp;&amp;obj.length&gt;0)&#123; for(int i=0;i&lt;obj.length;i++)&#123; query.setParameter(i, obj[i]); &#125; &#125; list=query.list(); &#125;catch(Exception e)&#123; logger.error(\"get page getPagelist error:\"+e.getMessage()); e.printStackTrace(); &#125; return list; &#125; 在控制层对结果集list进行操作 ​ 当我想对结果集进行操作的时候，发现无法对类型进行强制转换（将list中的每个对象强转为TblSwitch类型），在这条语句中会报错，但是我需要取出每个对象的内容。 123for (int i = 0; i &lt; list.size(); i++) &#123; TblSwitch tblSwitch1=list.get(i); &#125; ​ 强转Map同样报错 1Map&lt;String, Object&gt; dataMap = (Map&lt;String, Object&gt;) list.get(i); ​ 强转Map报错信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454627-Sep-2019 15:47:26.547 涓ラ噸 [http-nio-8080-exec-8] org.apache.catalina.core.StandardWrapperValve.invoke Servlet.service() for servlet [msg] in context with path [] threw exception [Request processing failed; nested exception is java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to java.util.Map] with root cause java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to java.util.Map at com.zhirong.base.web.SwitchNumberController.popSumExport(SwitchNumberController.java:547) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.bind.annotation.support.HandlerMethodInvoker.invokeHandlerMethod(HandlerMethodInvoker.java:176) at org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.invokeHandlerMethod(AnnotationMethodHandlerAdapter.java:426) at org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.handle(AnnotationMethodHandlerAdapter.java:414) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:790) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:719) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:644) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:549) at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at net.bull.javamelody.MonitoringFilter.doFilter(MonitoringFilter.java:203) at net.bull.javamelody.MonitoringFilter.doFilter(MonitoringFilter.java:181) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:800) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:806) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) 解决方法：方法一：​ 将对象赋值给Object map，这时map中有list中的对象的数据，但是不能用map.getAddUser()的方法获取，这时我将map强制转换成了Object[] objs，这样就将一个对象的属性用数组的形式保存起来了，通过数组下标取值，获取数据。 12345678910111213141516171819for (int i = 0; i &lt; list.size(); i++) &#123; Object map=list.get(i); Object[] objs=(Object[])map; //强转object数组对象 if (null!=objs[0])&#123; adduser=objs[0].toString(); &#125; if (null!=objs[1])&#123; oldProtocol=objs[1].toString(); &#125; if (null!=objs[2])&#123; nowProtocol=objs[2].toString(); &#125; if (null!=objs[3])&#123; mobile=objs[3].toString(); &#125; if (null!=objs[4])&#123; addtime=objs[4].toString(); &#125; &#125; 方法二：​ 将SQL结果返回值设置为List，不在是List&lt;TblSwitch&gt;，这时在遍历list的时候可以将list中的对象强转为Map类型。 修改返回值： 1234567891011121314151617181920public List getPagelist(Integer limit, Integer offser,String where, Object[] obj) &#123; logger.info(\"get getPagelist by:\"); String sql=\"select a.add_user, \" + \" a.old_protocol,a.now_protocol,a.mobile,a.add_time,a.delete_mark,a.update_time,a.id,a.remark \" + \" from tbl_switch a where 1=1 and a.delete_mark=0 \"+where+\" ORDER BY a.add_time DESC \"; List list=null; try&#123; Query query=this.getSession().createSQLQuery(sql).setFirstResult(limit).setMaxResults(offser); if(null !=obj&amp;&amp;obj.length&gt;0)&#123; for(int i=0;i&lt;obj.length;i++)&#123; query.setParameter(i, obj[i]); &#125; &#125; list=query.list(); &#125;catch(Exception e)&#123; logger.error(\"get page getPagelist error:\"+e.getMessage()); e.printStackTrace(); &#125; return list;&#125; 使用Map接收list的对象 1Map&lt;String, Object&gt; dataMap = (Map&lt;String, Object&gt;) list.get(i); 页面取值页面取值也是同样使用下标获取数据。 c:if 判断list是否为空； 1&lt;c:if test=\"$&#123;null != list&#125;\"&gt; c:forEach 遍历list； 1&lt;c:forEach items=\"$&#123;list&#125;\" var=\"dataList\" varStatus=\"status\"&gt; ${} 取值，利用下标确定对象中的某个属性。 1$&#123;dataList[3]&#125; 页面部分代码 123456789101112131415161718192021222324252627282930313233343536373839 &lt;c:if test=\"$&#123;null != list&#125;\"&gt; &lt;c:forEach items=\"$&#123;list&#125;\" var=\"dataList\" varStatus=\"status\"&gt; &lt;c:choose&gt; &lt;c:when test=\"$&#123;status.count % 2 == 0&#125;\"&gt; &lt;tr style=\"background-color:#FFFFFF\" onclick=\"Zving.DataGrid.onRowClick(this,event);\"&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;tr style=\"background-color:#F9FBFC\" onclick=\"Zving.DataGrid.onRowClick(this,event);\"&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;td rowno=\"$&#123;(page.page*page.rows) + (status.index+1) &#125;\" class=\"rowNo\" style=\"text-align: center;\"&gt; $&#123;(status.index+1)+(page.page*page.rows)&#125; &lt;/td&gt; &lt;td title=\"$&#123;dataList[3] &#125;\" style=\"text-align: center;\"&gt; $&#123;dataList[3]&#125; &lt;/td&gt; &lt;td title=\"$&#123;dataList[1] &#125;\" style=\"text-align: center;\"&gt; &lt;c:if test=\"$&#123;dataList[1]=='0'&#125;\"&gt;移动&lt;/c:if&gt; &lt;c:if test=\"$&#123;dataList[1]=='1'&#125;\"&gt;联通&lt;/c:if&gt; &lt;c:if test=\"$&#123;dataList[1]=='2'&#125;\"&gt;电信&lt;/c:if&gt; &lt;/td&gt; &lt;td title=\"$&#123;dataList[2] &#125;\" style=\"text-align: center;\"&gt; &lt;c:if test=\"$&#123;dataList[2]=='0'&#125;\"&gt;移动&lt;/c:if&gt; &lt;c:if test=\"$&#123;dataList[2]=='1'&#125;\"&gt;联通&lt;/c:if&gt; &lt;c:if test=\"$&#123;dataList[2]=='2'&#125;\"&gt;电信&lt;/c:if&gt; &lt;/td&gt; &lt;td title=\"&lt;fmt:formatDate value=\"$&#123;dataList[4]&#125;\" pattern=\"yyyy-MM-dd\" /&gt;\" style=\"text-align: center;\"&gt; &lt;fmt:formatDate value=\"$&#123;dataList[4]&#125;\" pattern=\"yyyy-MM-dd\" /&gt; &lt;/td&gt; &lt;td title=\"$&#123;dataList[0]&#125;\" style=\"text-align: center;\"&gt;$&#123;dataList[0]&#125;&lt;/td&gt; &lt;td title=\"\" style=\"text-align: center;\"&gt; &amp;nbsp;&amp;nbsp; &lt;a href=\"#\" onclick=\"return doUpdate($&#123;dataList[7]&#125;)\"&gt;修改&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href=\"#\" onclick=\"return del($&#123;dataList[7]&#125;)\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/c:if&gt;","categories":[{"name":"java","slug":"java","permalink":"http://ligangit.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"hibernate","slug":"hibernate","permalink":"http://ligangit.com/tags/hibernate/"},{"name":"object","slug":"object","permalink":"http://ligangit.com/tags/object/"},{"name":"bug","slug":"bug","permalink":"http://ligangit.com/tags/bug/"}]},{"title":"Typora学习md语法","slug":"Typoras学习md语法","date":"2019-09-04T08:41:07.000Z","updated":"2020-07-14T01:27:15.561Z","comments":true,"path":"2019/09/04/Typoras学习md语法/","link":"","permalink":"http://ligangit.com/2019/09/04/Typoras学习md语法/","excerpt":"","text":"​ 开始写博客了，对我这种小白来说，自己以前没有接触过makdown语法，现在开始使用了，就开始学习了，主要是使用Typora学习markdown语法，一边写博客一边学习。 用Typora学习.MD语法1、标题 语法 12345# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题 2、引用 语法 123&gt; 引用内容1&gt; 引用内容2&gt;&gt; 引用内容3 效果 引用内容1 引用内容2 引用内容3 3、列表3.1 无序列表 语法 123* 无序列表1+ 无序列表2_ 无序列表3 效果 无序列表1 无序列表2 无序列表3 3.2 多行无序列表 语法 123* 多行无序列表1TAB键 * 多行无序列表2TAB键 TAB键 * 多行无序列表3 效果 多行无序列表1 多行无序类表2 多行无序列表3 语法2 123* 多行无序类表1TAB键 多行无序列表2TAB键 多行无序列表3 效果2 多行无序类表1 多行无序列表2 多行无序列表3 3.3 有序列表 语法 1231. 有序列表12. 有序列表23. 有序类表3 效果 有序类表1 有序列表2 有序列表3 3.4 多行有序列表 语法 12345671. 多行有序类表12. 多行有序列表2 1. 多行有序列表2-1 2. 多行有序列表2-23. 多行有序列表3 1. 多行有序列表3-1 2. 多行有序列表3-2 效果 多行有序列表1 多行有序列表2 多行有序列表2-1 多行有序列表2-2 多行有序列表3 多行有序列表3-1 多行有序列表3-2 3.5 任务列表 语法 123-[ ] 起床-[x] 洗漱-[ ] 吃早餐 效果 -[ ] 起床 -[x] 洗漱 -[ ] 吃早餐 3.6表格 语法 123456|姓名|性别|年龄|手机号|邮箱||:---|:--:|:--:|:--:|---:||张三|男|20|18799999999|123456@qq.com||李四|女|19|18799999999|123456@qq.com||王五|男|21|18799999999|123456@qq.com||赵六|女|17|18799999999|123456qq.com| 效果 姓名 性别 年龄 手机号 邮箱 张三 男 20 18799999999 123456@qq.com 李四 女 19 18799999999 123456@qq.com 王五 男 21 18799999999 123456@qq.com 赵六 女 17 18799999999 123456@qq.com 4. 链接4.1 图片 语法1（本地图片） 12![图片上传失败...](图片地址)![图片上传失败...](hello.png) 效果 语法2（网络图片） 1![typora.jpg](https://upload-images.jianshu.io/upload_images/1538862-d91e815790b81e4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 效果 4.2 超链接 语法1（行内式） 12[无标题](https://www.baidu.com)[有标题][https://www.baidu.com \"此处是标题\"] 效果1 [无标题][https://www.baidu.com] [有标题][https://www.baidu.com “此处是标题”] 语法2（参数式） 1234[方式1]:https://www.baidu.com \"参数\"[方式2]:https://www.baidu.com '参数'[方式3]:https://www.baidu.com (参数)[方式4]:&lt;https://www.baidu.com&gt; \"参数\" 效果2 语法3（链接显示） 1&lt;https://www.ligangit.com&gt; 效果3 https://www.ligangit.com 5. 字体样式5.1 斜体 语法 12*斜体*_斜体_ 效果 斜体 斜体 5.2 加粗 语法 12**加粗**__加粗__ 效果 加粗 加粗 5.3 下划线 语法 1&lt;u&gt;下划线&lt;/u&gt; 效果 下划线 5.4 删除线 语法 1~~删除线~~ 效果 删除线 5.5 分割线 语法 1--- 效果 5.6 转义 语法 123456\\\\\\*\\+\\-\\`\\_ 效果 \\*+-`_","categories":[{"name":"博客","slug":"博客","permalink":"http://ligangit.com/categories/博客/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://ligangit.com/tags/markdown/"},{"name":"Typoras","slug":"Typoras","permalink":"http://ligangit.com/tags/Typoras/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-27T04:03:57.408Z","updated":"2019-11-04T10:06:33.400Z","comments":true,"path":"2019/07/27/hello-world/","link":"","permalink":"http://ligangit.com/2019/07/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}