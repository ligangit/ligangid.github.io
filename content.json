{"meta":{"title":"ligangit","subtitle":"时光，不会辜负每一个默默努力的人","description":"在码农的世界里面默默的挣扎着","author":"Li Gang","url":"http://ligangit.com","root":"/"},"pages":[],"posts":[{"title":"IDEA快捷键","slug":"IDEA快捷键","date":"2020-06-10T08:56:03.000Z","updated":"2020-06-11T01:48:43.183Z","comments":true,"path":"2020/06/10/IDEA快捷键/","link":"","permalink":"http://ligangit.com/2020/06/10/IDEA快捷键/","excerpt":"","text":"IDEA快捷键必须掌握 快捷键 简介 Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备） Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备） Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备） Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + / 代码块注释 （必备） Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） F2 跳转到下一个高亮错误 或 警告位置 （必备） Tab 缩进（必备） 连按两次Shift 弹出 Search Everywhere 弹出层（必备） Ctrl 快捷键 简介 Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + X 剪切光标所在行 或 剪切选择内容 Ctrl + C 复制光标所在行 或 复制选择内容 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） Ctrl + E 显示最近打开的文件记录列表 Ctrl + N 根据输入的 类名 查找类文件 Ctrl + G 在当前文件跳转到指定行处 Ctrl + J 插入自定义动态代码模板 Ctrl + P 方法参数提示显示 Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义 Ctrl + B 进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击 Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用 Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用 Ctrl + H 显示当前类的层次结构 Ctrl + O 选择可重写的方法 Ctrl + I 选择可继承的方法 Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F1 在光标所在的错误代码出显示错误信息 Ctrl + F3 调转到所选中的词的下一个引用位置 Ctrl + F4 关闭当前编辑文件 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行 Make Project 操作 Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 Ctrl + Enter 智能分隔行 Ctrl + End 跳到文件尾 Ctrl + Home 跳到文件头 Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备） Ctrl + Delete 删除光标后面的单词或是中文句 Ctrl + BackSpace 删除光标前面的单词或是中文句 Ctrl + 1,2,3…9 定位到对应数值的书签位置 Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径 Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要 Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置 Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置 Ctrl + 前方向键 等效于鼠标滚轮向前效果 Ctrl + 后方向键 等效于鼠标滚轮向后效果 Alt 快捷键 简介 Alt + ` 显示版本控制常用操作菜单弹出层 Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息 Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层 Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示 Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方 Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Alt + Home 定位 / 显示到当前文件的 Navigation Bar Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 Alt + 左方向键 按左方向切换当前已打开的文件视图 Alt + 右方向键 按右方向切换当前已打开的文件视图 Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 Alt + 1,2,3…9 显示对应数值的选项卡，其中 1 是 Project 用得最多 Shift 快捷键 简介 Shift + F1 如果有外部文档可以连接外部文档 Shift + F2 跳转到上一个高亮错误 或 警告位置 Shift + F3 在查找模式下，查找匹配上一个 Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留 Shift + F6 对文件 / 文件夹 重命名 Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样 Shift + F9 等效于点击工具栏的 Debug 按钮 Shift + F10 等效于点击工具栏的 Run 按钮 Shift + F11 弹出书签显示层 Shift + Tab 取消缩进 Shift + ESC 隐藏当前 或 最后一个激活的工具窗口 Shift + End 选中光标到当前行尾位置 Shift + Home 选中光标到当前行头位置 Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动 Ctrl + Alt 快捷键 简介 Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化 Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层 Ctrl + Alt + J 弹出模板选择窗口，讲选定的代码加入动态模板中 Ctrl + Alt + H 调用层次 Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Ctrl + Alt + V 快速引进变量 Ctrl + Alt + Y 同步、刷新 Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置 Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来 Ctrl + Alt + F11 切换全屏模式 Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层 Ctrl + Alt + Space 类名自动完成 Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备）（注意与其他软件快捷键冲突） Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件 Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件 Ctrl + Shift 快捷键 简介 Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备） Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备） Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板 Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层 Ctrl + Shift + E 显示最近修改的文件列表的弹出层 Ctrl + Shift + H 显示方法层次结构 Ctrl + Shift + B 跳转到类型声明处 Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义 Ctrl + Shift + A 查找动作 / 设置 Ctrl + Shift + / 代码块注释 （必备） Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置 Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置 Ctrl + Shift + + 展开所有代码 Ctrl + Shift + - 折叠所有代码 Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失 Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件 Ctrl + Shift + F9 编译选中的文件 / 包 / Module Ctrl + Shift + F12 编辑器最大化 Ctrl + Shift + Space 智能代码提示 Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） Ctrl + Shift + Backspace 退回到上次修改的地方 Ctrl + Shift + 1,2,3…9 快速添加指定数值的书签 Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 左方向键 在光标焦点是在工具选项卡上，缩小选项卡区域 Ctrl + Shift + 右方向键 在光标焦点是在工具选项卡上，扩大选项卡区域 Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 Alt + Shift 快捷键 简介 Alt + Shift + N 选择 / 添加 task Alt + Shift + F 显示添加到收藏夹弹出层 Alt + Shift + C 查看最近操作项目的变化情况列表 Alt + Shift + F 添加到收藏夹 Alt + Shift + I 查看项目当前文件 Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Alt + Shift + F9 弹出 Debug 的可选择菜单 Alt + Shift + F10 弹出 Run 的可选择菜单 Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 Alt + Shift + 前方向键 移动光标所在行向上移动 Alt + Shift + 后方向键 移动光标所在行向下移动 Ctrl + Shift + Alt 快捷键 简介 Ctrl + Shift + Alt + V 无格式黏贴 Ctrl + Shift + Alt + N 前往指定的变量 / 方法 Ctrl + Shift + Alt + S 打开当前项目设置 Ctrl + Shift + Alt + C 复制参考信息 其他 快捷键 简介 F2 跳转到下一个高亮错误 或 警告位置 （必备） F3 在查找模式下，定位到下一个匹配处 F4 编辑源 F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上 F11 添加书签 F12 回到前一个工具窗口 Tab 缩进（必备） ESC 从工具窗口进入代码文件窗口 连按两次Shift 弹出 Search Everywhere 弹出层（必备） 原文链接：https://blog.csdn.net/qq_38963960/java/article/details/89552704","categories":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/categories/研发工具/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"idea","slug":"idea","permalink":"http://ligangit.com/tags/idea/"},{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"}]},{"title":"IDEA缓存和索引清理","slug":"IDEA缓存和索引清理","date":"2020-06-10T07:30:29.000Z","updated":"2020-06-11T01:48:50.834Z","comments":true,"path":"2020/06/10/IDEA缓存和索引清理/","link":"","permalink":"http://ligangit.com/2020/06/10/IDEA缓存和索引清理/","excerpt":"","text":"IDEA缓存和索引IntelliJ IDEA首次加载项目的时候。都会创建索引，而创建索引的时间根项目的文件多少成正比。 IntelliJ IDEA的缓存和索引主要是用来加快文件查询，从而加快各种查找、代码提示等操作的速度。 某些特殊情况下，IntelliJ IDEA的缓存和索引文件也是会损坏的，比如：断电、蓝屏引起的强制关机，当重新打开IDEA，很可能IDEA会报各种莫名其妙的错误，甚至项目打不开，IDEA主题还原成默认状态。 清理缓存和索引步骤： 执行完成后会重启IDEA，IDEA启动后会自动重新创建缓存文件和索引。","categories":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/categories/研发工具/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"idea","slug":"idea","permalink":"http://ligangit.com/tags/idea/"},{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"}]},{"title":"IDEA部分模板","slug":"IDEA部分模板","date":"2020-06-09T09:17:04.000Z","updated":"2020-06-11T01:49:10.285Z","comments":true,"path":"2020/06/09/IDEA部分模板/","link":"","permalink":"http://ligangit.com/2020/06/09/IDEA部分模板/","excerpt":"","text":"部分常用模板psvm（main方法）1234//模板一：psvm public static void main(String[] args) &#123; &#125; sout（输出）12345678910111213//模板二：sout System.out.println(\"hello!\"); //变形： soutp / soutm /soutv / xxx.sout // soutp System.out.println(\"args = [\" + args + \"]\"); // soutm System.out.println(\"TempletsTest.main\"); // soutv int num=10; int num2=20; System.out.println(\"num2 = \" + num2); System.out.println(\"num = \" + num); System.out.println(num); fori（for循环）1234567891011121314//模板三： fori String[] arr= new String[]&#123;\"Tom\",\"Jerry\",\"Meimei\",\"Lilei\"&#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //变形 iter for (String s : arr) &#123; System.out.println(s); &#125; //变形 itar for (int i = 0; i &lt; arr.length; i++) &#123; String s = arr[i]; System.out.println(s); &#125; list.for（List循环）12345678910111213141516//模板四： list.for ArrayList list=new ArrayList(); list.add(\"hello\"); list.add(123); list.add(456); for (Object o : list) &#123; &#125; //变形： list.fori for (int i = 0; i &lt; list.size(); i++) &#123; &#125; //变形： list.forr 倒叙遍历 for (int i = list.size() - 1; i &gt;= 0; i--) &#123; &#125; ifn（判断NULL）1234567891011121314151617181920 ArrayList list=new ArrayList(); list.add(\"hello\"); list.add(123); list.add(456);//模板五：ifn if (list == null) &#123; &#125; //变形：inn if (list != null) &#123; &#125; //变形：xxx.null if (list == null) &#123; &#125; //变形：xxx.nn if (list != null) &#123; &#125; prsf（类常量）123456789//模板六：prsf 可生成 private static final private static final String sss=new String(); //变形：psf public static final int NUM1 = 9; //变形：psfi public static final int NUM2=10; //变形：psfs public static final String ST1=\"hello\"; 自定义模板打开设置 创建分组 创建模板 说明： ​ 步骤11：设置模板调用字符 ​ 步骤12：此模板的描述 ​ 步骤13：模板内容 12345/** *$VAR1$ */ private int $VAR2$; $END$ ​ 步骤14：设置模板应用范围 选择模板应用范围我们选择Java 选择之后点击OK，应用模板 结果 12345//自定义模板 pri/** *自定义模板测试 */ private int id; 附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.ArrayList;public class TempletsTest &#123; //自定义模板 pri /** *自定义模板测试 */ private int id; //模板六：prsf 可生成 private static final private static final String sss=new String(); //变形：psf public static final int NUM1 = 9; //变形：psfi public static final int NUM2=10; //变形：psfs public static final String ST1=\"hello\"; //模板一：psvm public static void main(String[] args) &#123; //模板二：sout System.out.println(\"hello!\"); //变形： soutp / soutm /soutv / xxx.sout // soutp System.out.println(\"args = [\" + args + \"]\"); // soutm System.out.println(\"TempletsTest.main\"); // soutv int num=10; int num2=20; System.out.println(\"num2 = \" + num2); System.out.println(\"num = \" + num); System.out.println(num); //模板三： fori String[] arr= new String[]&#123;\"Tom\",\"Jerry\",\"Meimei\",\"Lilei\"&#125;; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; //变形 iter for (String s : arr) &#123; System.out.println(s); &#125; //变形 itar for (int i = 0; i &lt; arr.length; i++) &#123; String s = arr[i]; System.out.println(s); &#125; //模板四： list.for ArrayList list=new ArrayList(); list.add(\"hello\"); list.add(123); list.add(456); for (Object o : list) &#123; &#125; //变形： list.fori for (int i = 0; i &lt; list.size(); i++) &#123; &#125; //变形： list.forr 倒叙遍历 for (int i = list.size() - 1; i &gt;= 0; i--) &#123; &#125; //模板五：ifn if (list == null) &#123; &#125; //变形：inn if (list != null) &#123; &#125; //变形：xxx.null if (list == null) &#123; &#125; //变形：xxx.nn if (list != null) &#123; &#125; &#125;&#125;","categories":[{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/categories/研发工具/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"idea","slug":"idea","permalink":"http://ligangit.com/tags/idea/"},{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"}]},{"title":"Tomcat部署web工程的方式","slug":"Tomcat部署web工程的方式","date":"2020-06-05T09:25:48.000Z","updated":"2020-06-11T01:51:06.320Z","comments":true,"path":"2020/06/05/Tomcat部署web工程的方式/","link":"","permalink":"http://ligangit.com/2020/06/05/Tomcat部署web工程的方式/","excerpt":"","text":"Tomcat部署web工程的方式第一种只需要把web工程的目录拷贝到Tomcat的webapps目录下即可。 helloworld文件夹就是web项目 访问路径： http://localhost:8080/helloworld/hello.html 第二种进入Tomcat安装目录的conf\\Catalina\\localhost文件夹 创建一个xml配置文件（一个xml配置文件对应一个web工程）:如abc.xml abc.xml的配置信息： 1234567&lt;!-- Context 表示一个工程上下文 path 表示工程访问路径 docBase 表示web工程路径 path中的内容必须和xml文件名称相同--&gt;&lt;Context path=\"/abc\" docBase=\"D:\\test\\helloworld\"/&gt; 注意： ​ Context 表示一个工程上下文​ path 表示工程访问路径​ docBase 表示web工程路径 ​ path中的内容必须和xml文件名称相同，不然访问不到，如上例中的abc.xml， path=”/abc” 项目存放地址：D:\\test 访问路径： http://localhost:8080/abc/hello.html 默认访问当我们在浏览器地址中输入访问地址如下： http://ip:port/ 如 http://localhost:8080/ 没有工程名的时候，默认访问的是ROOT工程。 当我们在浏览器地址栏中输入的访问地址如下： http://ip:port/工程名/ 如 http://localhost:8080/abc/ 没有资源名，默认访问index.html页面。","categories":[{"name":"服务器软件","slug":"服务器软件","permalink":"http://ligangit.com/categories/服务器软件/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"服务器软件","slug":"服务器软件","permalink":"http://ligangit.com/tags/服务器软件/"},{"name":"tomcat","slug":"tomcat","permalink":"http://ligangit.com/tags/tomcat/"},{"name":"web","slug":"web","permalink":"http://ligangit.com/tags/web/"}]},{"title":"Echarts地图点击事件重复","slug":"Echarts地图点击事件重复","date":"2020-06-05T01:53:25.000Z","updated":"2020-06-05T02:37:57.832Z","comments":true,"path":"2020/06/05/Echarts地图点击事件重复/","link":"","permalink":"http://ligangit.com/2020/06/05/Echarts地图点击事件重复/","excerpt":"","text":"Echarts地图点击事件重复执行两次点击事件当我们点击Echarts地图，在点击事件的里面执行更新地图操作的时候，地图点击事件会执行两次。 如下： 1234567891011121314151617var mapMain = document.getElementById('mapMain'); var myChart = echarts.init(mapMain); myChart.setOption(option); myChart.on(\"click\", function (param) &#123; let area_code=param.data.area_code; if (param.name != \"\"&amp;&amp;area_code!=\"\") &#123; areaCode = area_code; proName=param.name; areaCode=areaCode.substring(0, 2); areaCodeNew=areaCode; //保存当前地区代码 c_area_level='2'; c_area_level_new=c_area_level; //保存当前地区等级 mapData(year, areaCode, c_area_level);//地图点击 地图 persent(year, areaCode,c_area_level); //右边 河流面积占区域面积百分比 &#125; getDataList(year, areaCodeNew,c_area_level_new); &#125;); 代码说明： areaCode、proName、areaCodeNew、c_area_level、c_area_level_new为全局变量； mapData(year, areaCode, c_area_level) 地图显示方法； persent(year, areaCode,c_area_level); 河流面积占区域面积百分比方法； getDataList(year, areaCodeNew,c_area_level_new) 数据显示方法 上面的代码是mapData(year, areaCode, c_area_level) 方法中的一部分。 当执行点击事件的时候： mapData()、persent()、getDataList()方法会执行两次，有时我们会在点击事件中修改全局变量，这个就需要注意了，执行两次的后的全局变量和执行一次后的全局变量值大多数会有所不同，从而影响其他方法的结果。 如： 假设c_area_level 初始值为’1’,那么执行一次点击事件后c_area_level_new为’1’，c_area_level为’2’；执行两次点击事件后c_area_level_new为’2’，c_area_level为’2’； 这时使用了c_area_level_new的getDataList()方法展示出来的数据会不同。 如何解决重复点击事件在点击事件执行一次后，再次刷新地图的时候不在执行点击事件。 核心代码： 1234//防止重复触发点击事件 if(myChart._$handlers.click)&#123; myChart._$handlers.click.length = 0; &#125; 我们只需要将上面那段代码添加到点击事件之就OK了。 123456789101112131415161718192021var mapMain = document.getElementById('mapMain'); var myChart = echarts.init(mapMain); myChart.setOption(option); //防止重复触发点击事件 if(myChart._$handlers.click)&#123; myChart._$handlers.click.length = 0; &#125; myChart.on(\"click\", function (param) &#123; let area_code=param.data.area_code; if (param.name != \"\"&amp;&amp;area_code!=\"\") &#123; areaCode = area_code; proName=param.name; areaCode=areaCode.substring(0, 2); areaCodeNew=areaCode; //保存当前地区代码 c_area_level='2'; c_area_level_new=c_area_level; //保存当前地区等级 mapData(year, areaCode, c_area_level);//地图点击 地图 persent(year, areaCode,c_area_level); //右边 河流面积占区域面积百分比 &#125; getDataList(year, areaCodeNew,c_area_level_new); &#125;);","categories":[{"name":"前端","slug":"前端","permalink":"http://ligangit.com/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://ligangit.com/tags/JS/"},{"name":"前端","slug":"前端","permalink":"http://ligangit.com/tags/前端/"},{"name":"Echarts","slug":"Echarts","permalink":"http://ligangit.com/tags/Echarts/"}]},{"title":"JS时间格式转换与获取","slug":"JS时间格式转换与获取","date":"2020-06-01T01:21:55.000Z","updated":"2020-06-05T03:41:51.398Z","comments":true,"path":"2020/06/01/JS时间格式转换与获取/","link":"","permalink":"http://ligangit.com/2020/06/01/JS时间格式转换与获取/","excerpt":"","text":"​ 项目中有很多时候需要用到时间格式、某些时间的获取，这里面主要包括了将时间字符转转Date对象，日期格式转换，本周、本月、本季度的开始和结束日期获取。 ​ 可以直接将代码复制，粘贴在一个JS文件中，然后调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/** * 获取本周、本季度、本月、上月的开始日期、结束日期 *///时间字符串转为Date对象 如：'2020-05-28'function getDate(strDate)&#123; var date = eval('new Date(' + strDate.replace(/\\d+(?=-[^-]+$)/, function (a) &#123; return parseInt(a, 10) - 1; &#125;).match(/\\d+/g) + ')'); return date;&#125;//格式化日期：yyyy-MM-ddfunction formatDate(date) &#123; var myyear = date.getFullYear(); var mymonth = date.getMonth()+1; var myweekday = date.getDate(); if(mymonth &lt; 10)&#123; mymonth = \"0\" + mymonth; &#125; if(myweekday &lt; 10)&#123; myweekday = \"0\" + myweekday; &#125; return (myyear+\"-\"+mymonth + \"-\" + myweekday);&#125;//获得某天所属月份的天数（参数为Date时间）function getMonthDays(date)&#123; var nowYear = date.getYear(); //当前年 var nowMonth = date.getMonth(); //当前月 var monthStartDate = new Date(nowYear, nowMonth, 1); var monthEndDate = new Date(nowYear, nowMonth + 1, 1); var days = (monthEndDate - monthStartDate)/(1000 * 60 * 60 * 24); return days;&#125;//获得本季度的开始月份function getQuarterStartMonth(nowMonth)&#123; var quarterStartMonth = 0; if(nowMonth&lt;3)&#123; quarterStartMonth = 0; &#125; if(2&lt;nowMonth &amp;&amp; nowMonth&lt;6)&#123; quarterStartMonth = 3; &#125; if(5&lt;nowMonth &amp;&amp; nowMonth&lt;9)&#123; quarterStartMonth = 6; &#125; if(nowMonth&gt;8)&#123; quarterStartMonth = 9; &#125; return quarterStartMonth;&#125;//获得本周的开始日期(参数为Date)function getWeekStartDate(date) &#123; var nowDayOfWeek = date.getDay(); //今天本周的第几天 var nowDay = date.getDate(); //当前日 var nowMonth = date.getMonth(); //当前月 var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var weekStartDate = new Date(nowYear, nowMonth, nowDay - nowDayOfWeek); return formatDate(weekStartDate);&#125;//获得本周的结束日期function getWeekEndDate(date) &#123; var nowDayOfWeek = date.getDay(); //今天本周的第几天 var nowDay = date.getDate(); //当前日 var nowMonth = date.getMonth(); //当前月 var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var weekEndDate = new Date(nowYear, nowMonth, nowDay + (6 - nowDayOfWeek)); return formatDate(weekEndDate);&#125;//获得本月的开始日期function getMonthStartDate(date)&#123; var nowMonth = date.getMonth(); //当前月 var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var monthStartDate = new Date(nowYear, nowMonth, 1); return formatDate(monthStartDate);&#125;//获得本月的结束日期function getMonthEndDate(date)&#123; var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var nowMonth = date.getMonth(); //当前月 var monthStartDate = new Date(nowYear, nowMonth, 1); var monthEndDate = new Date(nowYear, nowMonth + 1, 1); //下个月1号 var days = (monthEndDate - monthStartDate)/(1000 * 60 * 60 * 24); //计算本月的天数 var monthEndDate2 = new Date(nowYear, nowMonth, days); //本月最后一天 return formatDate(monthEndDate2);&#125;//获得上月开始时间function getLastMonthStartDate(date)&#123; var lastMonthDate = date; //上月日期 lastMonthDate.setDate(1); lastMonthDate.setMonth(lastMonthDate.getMonth()-1); var lastYear = lastMonthDate.getYear(); lastYear += (lastYear &lt; 2000) ? 1900 : 0; // var lastMonth = lastMonthDate.getMonth(); var lastMonthStartDate = new Date(lastYear, lastMonth, 1); return formatDate(lastMonthStartDate);&#125;//获得上月结束时间function getLastMonthEndDate(date)&#123; var lastMonthDate = date; //上月日期 lastMonthDate.setDate(1); lastMonthDate.setMonth(lastMonthDate.getMonth()-1); var lastYear = lastMonthDate.getYear(); lastYear += (lastYear &lt; 2000) ? 1900 : 0; // var lastMonth = lastMonthDate.getMonth(); //上个月月份 var monthStartDate = new Date(lastYear, lastMonth, 1); //上个月的1号 var monthEndDate = new Date(lastYear, lastMonth + 1, 1); //这个月的1号 var days = (monthEndDate - monthStartDate)/(1000 * 60 * 60 * 24); //上个月的天数 var lastMonthEndDate = new Date(lastYear, lastMonth, days); return formatDate(lastMonthEndDate);&#125;//获得本季度的开始日期function getQuarterStartDate(date)&#123; var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var nowMonth = date.getMonth(); //当前月 var quarterStartDate = new Date(nowYear, getQuarterStartMonth(nowMonth), 1); return formatDate(quarterStartDate);&#125;//获得本季度的结束日期function getQuarterEndDate(date)&#123; var nowYear = date.getYear(); //当前年 nowYear += (nowYear &lt; 2000) ? 1900 : 0; // var nowMonth = date.getMonth(); //当前月 var quarterEndMonth = getQuarterStartMonth(nowMonth) + 2; var endDate = new Date(nowYear, quarterEndMonth, 1); //上个月的1号 var quarterStartDate = new Date(nowYear, quarterEndMonth, getMonthDays(endDate)); return formatDate(quarterStartDate);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://ligangit.com/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://ligangit.com/tags/JS/"},{"name":"前端","slug":"前端","permalink":"http://ligangit.com/tags/前端/"},{"name":"Util","slug":"Util","permalink":"http://ligangit.com/tags/Util/"}]},{"title":"Nginx学习-相关概念","slug":"Nginx学习-相关概念","date":"2020-05-29T08:25:21.000Z","updated":"2020-06-02T01:27:58.312Z","comments":true,"path":"2020/05/29/Nginx学习-相关概念/","link":"","permalink":"http://ligangit.com/2020/05/29/Nginx学习-相关概念/","excerpt":"","text":"主要学习几个概念：Nginx，正向代理、反向代理、负载均衡、动静分离。 Nginx相关概念什么是Nginx​ Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。 特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好 。 **Nginx专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率 。**它支持内核Poll模型，能经受高负载的考验,有报告表明能支持高达 50,000个并发连接数。 https://lnmp.org/nginx.html 正向代理​ 如果把局域网外的Internet想象成一个巨大的资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务器就称为正向代理。 正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 反向代理​ 反向代理，其实客户端对代理是无感知的，客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。 ​ 反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率 。 负载均衡负载均衡*（Load Balance）*其意思就是分摊到多个操作单元上进行执行 ， 从而共同完成工作任务。 ​ 单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。 动静分离​ 为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。","categories":[{"name":"服务器软件","slug":"服务器软件","permalink":"http://ligangit.com/categories/服务器软件/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://ligangit.com/tags/nginx/"},{"name":"服务器软件","slug":"服务器软件","permalink":"http://ligangit.com/tags/服务器软件/"}]},{"title":"Mysql注意事项（一）","slug":"Mysql注意事项（一）","date":"2020-05-13T13:49:03.000Z","updated":"2020-06-02T01:31:48.862Z","comments":true,"path":"2020/05/13/Mysql注意事项（一）/","link":"","permalink":"http://ligangit.com/2020/05/13/Mysql注意事项（一）/","excerpt":"","text":"最近回顾了一下MySQL，发现了一些MySQL需要注意的事项，同时也作为学习笔记，记录下来。 Mysql注意事项（一）1、通配符*检索所有的列。 不建议使用​ 通常，除非你确定需要表中的每个列，否则最好别使用*通配符，虽然使用通配符可能会使你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。 优点​ 由于不明确指定列名（因为星号检索每个列），所以能检索出名字未知的列。 2、DISTINCT​ 用于检索不同的行（去重）。 不能部分使用DISTINCT​ DISTINCT关键字应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT vend_id,prod_price FROM products ；会查找出vend_id和prod_price都不相同的内容，而不是vend_id去除重复，除非指定的两个列都不同，否则所有列都将被检索出来。 示例： 表数据：z 1SELECT * FROM products; 结果：共14条记录 使用DISTINCT获取供应商： 1SELECT DISTINCT vend_id FROM products; 结果：共4条记录 部分使用DISTINCT： 1SELECT DISTINCT vend_id,prod_price FROM products; 结果：共12条记录 结果查出了vend_id和prod_price都不相同的内容； 3、LIMIT限制结果，指定返回的行 使用方法示例： 123SELECT prod_name FROM productsLIMIT 5; 结果：返回前5行 示例：获取行3开始的4行，即第4至第8行 123SELECT prod_name FROM productsLIMIT 3,4; 等价于：从行3开始取4行 123SELECT prod_name FROM productsLIMIT 4 OFFSET 3; 注意：行0行0 ：检索出来的第一行为行0而不是行1.因此，LIMIT 1,1将检索出第二行而不是第一行。 4、ORDER BY​ 排序数据，降序DESC，升序ASC（默认，即如果不指定DESC、也不指定ASC，则假定为ASC） 在多个列上降序排序​ 如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。 ORDER BY 子句的位置​ 在给出ORDER BY 子句时，应该保证它位于FROM子句之后，如果使用LIMIT，它必须位于ORDER BY 之后。使用子句的次序不对将产生错误消息。 5、WHERE​ 过滤数据 WHERE子句的位置​ 在给出WHERE子句时，应该保证它位于FROM子句之后，如果同时使用ORDER BY，应该让ORDER BY位于WHERE 之后，否则将会产生错误。 BETWEEN 范围值检查BETWEEN匹配范围中的所有值，包括指定的开始值和结束值。 NULL 空值检查​ NULL 无值，它与字段包含0,、空字符串或仅仅包含空格不同。 NULL与不匹配IS NULL 和 IS NOT NULL 即为空和不为空 123456789--IS NULLSELECT cust_id From customerswhere cust_email IS NULL;-- IS NOT NULLSELECT cust_id From customerswhere cust_email IS NOT NULL; 在过滤数据时，一定要验证返回数据中确定给出了被过滤列具有NULL的行。 AND、OR注意：AND比OR的优先级更高，建议在WHERE子句中使用圆括号； 示例：（未使用圆括号） 123SELECT prod_name,prod_priceFROM productsWHERE vend_id=1002 OR vend_id=1003 AND prod_price&gt;=10; 结果： 分析： ​ SQL在处理OR操作符之前，优先处理AND操作符。当SQL看到上述的WHERE子句时，它理解为由供应商1003制造的任何价格为10美元（含）以上的产品，或者由供应商1002制造的任何产品，不管其价格如何。换句话说，由于AND在计算次序中优先级更高，操作符被错误的组合了。 IN、NOTIN操作符 ​ 与OR操作符相比较，IN有如下优点（建议替换OR）： 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观； 在使用IN时，计算次序更容易管理（因为使用的操作符更少）； IN操作符一般比OR操作符清单执行更快； IN最大的优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。 NOT操作符 ​ 使用NOT对IN、BETWEEN和EXISTS子句取反。 6、LIKE、通配符%和_​ LIKE指示MYSQL，后跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较，匹配整个列； 示例1： 123SELECT prod_nameFROM productsWHERE prod_name LIKE &apos;1000&apos; 结果：不会返回prod_name为1000的行 ​ %表示任何字符出现任意次数； 示例2：使用了通配符%的LIKE 123SELECT prod_nameFROM productsWHERE prod_name LIKE &apos;%1000&apos; 结果：不会返回prod_name为1000的行 ​ _表示任意单个字符出现一次。 ​ 通配符搜索的处理一般比其他搜索所花时间更长。 NULL与%通配符​ %通配符几乎可以匹配任何东西，但是不能匹配NULL 通配符使用技巧 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。 在确定需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始出。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的配置。如果放错地方，可能不会返回想要的数据。 7、日期和时间处理函数​ MySQL使用的日期格式为yyyy-mm-dd； 日期比较​ 示例： 123SELECT cust_id,order_num,order_dateFROM ordersWHERE order_date=&apos;2005-09-01&apos; ​ 结果： ​ 注意：使用WHERE order_date=’2005-09-01‘ 可靠吗？ ​ order_date的数据类型为datetime，这种类型存储日期和时间值，表中的时间值为00:00:00，但实际中很可能并不总是这样。比如：order_date值为2005-09-01 11:30:05，则WHERE order_date=’2005-09-01’失败，即使给出具有该日期的一行，也不会检索出来，因为WHERE匹配失败。 ​ 解决方案： ​ 使用Date()函数。Date(order_date)函数指示MySQL仅提取列的日期部分，更可靠的SELECT语句为： 123SELECT cust_id,order_num,order_dateFROM ordersWHERE DATE(order_date)=&apos;2005-09-01&apos; ​ 结果： 建议​ 如果要的是日期，请使用Date()。 ​ 如果你想要的仅是日期，则使用Date()是一个良好的习惯，即使你如果知道相应的列只包含日期也是如此。这样，如果由于某种原因表中以后有日期和时间值，你的SQL代码也不用改变。当然，也存在一个Time()函数，在你只想要时间时应该使用它。 8、聚集函数AVG()函数​ 通过对表中行数计算并计算特定列值之和，求得该列的平均值。 ​ 只能用于单列 。AVG()只能用来确定特定数值列的平均值，而且列名必须作为函数参数给出。为了获得多个列的平均值，必须使用多个AVG()函数。 ​ NULL值 。AVG()函数忽略列值为NULL的行。 COUNT()函数 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值； 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。 示例1： 12SELECT COUNT(*) AS num_custFROM customers; ​ 结果1：对所有行计数，不管行中各列有什么值 ​ 示例2： 12SELECT COUNT(cust_email) AS num_custFROM customers; ​ 结果2：对cust_email列中有值的计数 ### MAX()函数、MIN()函数​ MAX()返回指定列中的最大值； ​ MIN()返回指定列中的最小值。 ​ 对非数值数据使用MAX()或MIN() 返回文本列中的最大值或最小值。 SUM()函数​ 用来返回指定列值的和（总计）。 ​ 示例1： 123SELECT SUM(quantity) AS items_orderedFROM orderitemsWHERE order_num=20005; ​ 结果1： ​ 在多列上进行计算 利用标准的算术操作符，所有聚集函数都可用来执行多个列上的计算。 ​ 示例2： 123SELECT SUM(item_price*quantity) AS items_orderedFROM orderitemsWHERE order_num=20005; ​ 结果2： 聚集不同值​ 对聚合函数AVG()、COUNT()、MAX()、MIN()、SUM()的使用： 对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）； 只包含不同的值，指定DISTINCT参数。 使用DISTINCT，查询特定供应商提供的产品的平均价格。 示例： 123SELECT AVG(DISTINCT prod_price) AS avg_priceFROM productsWHERE vend_id=1003; 结果：使用了DISTINCT，平均值只考虑各个不同的价格 注意：如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT(DISTINCT)，否则会产生错误。类似的，DISTINCT必须使用列名，不能用于计算或表达式。","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"},{"name":"mysql","slug":"mysql","permalink":"http://ligangit.com/tags/mysql/"}]},{"title":"java获取操作系统信息","slug":"java获取操作系统信息","date":"2020-04-23T01:44:05.000Z","updated":"2020-05-29T02:52:30.712Z","comments":true,"path":"2020/04/23/java获取操作系统信息/","link":"","permalink":"http://ligangit.com/2020/04/23/java获取操作系统信息/","excerpt":"","text":"​ 之前碰到过一个BUG，发现是文件路径有误，因为开发环境是Windows，获取某个目录的时候是以盘符开头，如：D:\\，但是项目部署环境是Linux，Linux中文件路径是‘/’开头，所以报错了。写下这篇博客记录一下。 获取系统信息代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.net.InetAddress;import java.net.NetworkInterface;import java.util.ArrayList;import java.util.Formatter;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Properties;public class SystemTest &#123; //通过截取cmd流方式得到计算机的配置信息(不好) public static List&lt;String&gt; getIpAddress() &#123; Process p = null; List&lt;String&gt; address = new ArrayList&lt;String&gt;(); try &#123; p = new ProcessBuilder(\"ipconfig\", \"/all\").start(); &#125; catch (Exception e) &#123; return address; &#125; StringBuffer sb = new StringBuffer(); //读取进程输出值 InputStream inputStream = p.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(inputStream)); String s = \"\"; try &#123; while ((s = br.readLine()) != null) &#123; sb.append(s + \"\\n\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; inputStream.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(sb); return address; &#125; public static void getIpconfig() &#123; Map&lt;String, String&gt; map = System.getenv(); System.out.println(map.get(\"USERNAME\"));//获取用户名 System.out.println(map.get(\"COMPUTERNAME\"));//获取计算机名 System.out.println(map.get(\"USERDOMAIN\"));//获取计算机域名 &#125; //得到计算机的ip地址和mac地址 public static void getConfig() &#123; try &#123; InetAddress address = InetAddress.getLocalHost(); NetworkInterface ni = NetworkInterface.getByInetAddress(address); //ni.getInetAddresses().nextElement().getAddress(); byte[] mac = ni.getHardwareAddress(); String sIP = address.getHostAddress(); String sMAC = \"\"; Formatter formatter = new Formatter(); for (int i = 0; i &lt; mac.length; i++) &#123; sMAC = formatter.format(Locale.getDefault(), \"%02X%s\", mac[i], (i &lt; mac.length - 1) ? \"-\" : \"\").toString(); &#125; System.out.println(\"IP：\" + sIP); System.out.println(\"MAC：\" + sMAC); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //得到计算机的ip,名称,操作系统名称,操作系统版本 public static void Config() &#123; try &#123; InetAddress addr = InetAddress.getLocalHost(); String ip = addr.getHostAddress().toString(); //获取本机ip String hostName = addr.getHostName().toString(); //获取本机计算机名称 System.out.println(\"本机IP：\" + ip + \"\\n本机名称:\" + hostName); Properties props = System.getProperties(); System.out.println(\"操作系统的名称：\" + props.getProperty(\"os.name\")); System.out.println(\"操作系统的版本：\" + props.getProperty(\"os.version\")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //其它的一些东西,会有用到的时候的 public static void all() &#123; Properties props = System.getProperties(); System.out.println(\"Java的运行环境版本：\" + props.getProperty(\"java.version\")); System.out.println(\"Java的运行环境供应商：\" + props.getProperty(\"java.vendor\")); System.out.println(\"Java供应商的URL：\" + props.getProperty(\"java.vendor.url\")); System.out.println(\"Java的安装路径：\" + props.getProperty(\"java.home\")); System.out.println(\"Java的虚拟机规范版本：\" + props.getProperty(\"java.vm.specification.version\")); System.out.println(\"Java的虚拟机规范供应商：\" + props.getProperty(\"java.vm.specification.vendor\")); System.out.println(\"Java的虚拟机规范名称：\" + props.getProperty(\"java.vm.specification.name\")); System.out.println(\"Java的虚拟机实现版本：\" + props.getProperty(\"java.vm.version\")); System.out.println(\"Java的虚拟机实现供应商：\" + props.getProperty(\"java.vm.vendor\")); System.out.println(\"Java的虚拟机实现名称：\" + props.getProperty(\"java.vm.name\")); System.out.println(\"Java运行时环境规范版本：\" + props.getProperty(\"java.specification.version\")); System.out.println(\"Java运行时环境规范供应商：\" + props.getProperty(\"java.specification.vender\")); System.out.println(\"Java运行时环境规范名称：\" + props.getProperty(\"java.specification.name\")); System.out.println(\"Java的类格式版本号：\" + props.getProperty(\"java.class.version\")); System.out.println(\"Java的类路径：\" + props.getProperty(\"java.class.path\")); System.out.println(\"加载库时搜索的路径列表：\" + props.getProperty(\"java.library.path\")); System.out.println(\"默认的临时文件路径：\" + props.getProperty(\"java.io.tmpdir\")); System.out.println(\"一个或多个扩展目录的路径：\" + props.getProperty(\"java.ext.dirs\")); System.out.println(\"操作系统的名称：\" + props.getProperty(\"os.name\")); System.out.println(\"操作系统的构架：\" + props.getProperty(\"os.arch\")); System.out.println(\"操作系统的版本：\" + props.getProperty(\"os.version\")); System.out.println(\"文件分隔符：\" + props.getProperty(\"file.separator\")); //在 unix 系统中是＂／＂ System.out.println(\"路径分隔符：\" + props.getProperty(\"path.separator\")); //在 unix 系统中是＂:＂ System.out.println(\"行分隔符：\" + props.getProperty(\"line.separator\")); //在 unix 系统中是＂/n＂ System.out.println(\"用户的账户名称：\" + props.getProperty(\"user.name\")); System.out.println(\"用户的主目录：\" + props.getProperty(\"user.home\")); System.out.println(\"用户的当前工作目录：\" + props.getProperty(\"user.dir\")); &#125; public static void main(String[] args) &#123; getConfig(); Config(); all(); &#125;&#125; 运行main方法部分结果： 获取文件路径（Windows 和Linux区别）注意： Windows的文件盘符是以盘符开头，如：D:\\ 但是 Linux的文件盘符是以’/‘开头，如：/usr/local 因此：我们在获取和系统相关的路径的时候，需要注意项目部署的环境，linux环境下的路径前面待’/‘，但是windows环境下的路径前面不带‘/’ 1234// 注意：windows环境下的路径获取// this.path = ClassUtils.getDefaultClassLoader().getResource(&quot;&quot;).getPath().substring(1);// 获取静态资源路径（去除了前面的/）// 注意：linux环境下的路径获取 this.path = ClassUtils.getDefaultClassLoader().getResource(&quot;&quot;).getPath();// 获取静态资源路径（不能去除前面的/）","categories":[{"name":"java","slug":"java","permalink":"http://ligangit.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"操作系统","slug":"操作系统","permalink":"http://ligangit.com/tags/操作系统/"}]},{"title":"java数据库保存文件路径注意事项","slug":"java数据库保存文件路径注意事项","date":"2020-04-09T07:37:04.000Z","updated":"2020-06-02T01:45:21.614Z","comments":true,"path":"2020/04/09/java数据库保存文件路径注意事项/","link":"","permalink":"http://ligangit.com/2020/04/09/java数据库保存文件路径注意事项/","excerpt":"","text":"Java上传或下载文件路径存储数据库注意事项数据库中存储全路径易造成读取文件为空​ 我们使用java下载或上传文件，文件路径一般都是保存在数据库中，如在数据库中建一张和此文件相关的表，其中包含文件路径字段。 ​ 我们上传或下载文件的时候一般都是使用绝对路径，如: D:/files/img1.png，而且我们在数据库中也直接把这整个绝对路径存储在里面了。 ​ 这就可能导致文件读取是因路径问题导致读取出来的文件为空。 ​ 特别是磁盘挂载后，很容易造成读取、下载出来的文件内容是空的。 ​ 注：磁盘挂载 原因​ 当我们上传和下载的方法不在同一个服务器上的时候，我们上传的路径可能是 D:/files/Apk/线上4_8.apk ，并且保存在数据库中： 我们下载时读取的是数据库中的绝对路径，从数据库中得到了文件所在路径为D:/files/Apk/线上4_8.apk ，但是下载接口在另外一台服务器上，我们采用了磁盘挂载后，在下载接口所在服务器访问上传的文件所在的路径为Z:/Apk/线上4_8.apk， 当我们下载时，下载接口读取的路劲为D:/files/Apk/线上4_8.apk ，实际需要为Z:/Apk/线上4_8.apk，所以造成了下载的文件为空。 解决方案 改数据库存储： ​ 数据库中存放的文件路径为文件名称，或者文件夹+/+文件名称 改java后台路径获取代码 我们将绝对路径的盘符放在配置文件中，当我们读取、上传、下载的时候从配置文件中获取盘符，将盘符和文件名一起组成绝对路径。 如：配置文件添加属性 uploadApk 修改前上传保存数据库java代码： 修改后上传保存数据库java代码： 修改前下载java代码： 修改后下载java代码： 这样我们读取、下载时获取的路径就是Z:/Apk/线上4_8.apk 配置文件修改 我们在部署项目的时候，只需要将上传文件项目部署时将配置文件修改为 下载文件项目部署时修改配置文件修改为 成功获取正确的文件！","categories":[{"name":"java","slug":"java","permalink":"http://ligangit.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"}]},{"title":"Spring学习-定时任务","slug":"Spring学习-定时任务","date":"2020-03-24T09:59:26.000Z","updated":"2020-06-02T01:44:41.332Z","comments":true,"path":"2020/03/24/Spring学习-定时任务/","link":"","permalink":"http://ligangit.com/2020/03/24/Spring学习-定时任务/","excerpt":"","text":"SpringBoot定时任务定时任务执行的代码注意： @Component //加入到容器中@EnableScheduling //定时任务或者周期任务的注解 @Scheduled(fixedDelay=ONE_Minute) //配置定时任务在执行完毕后多长时间再执行（示例中设置间隔60秒） 1234567891011121314151617181920@Component@EnableScheduling //定时任务或者周期任务的注解public class TestJob &#123; @Autowired private PushMapper pushMapper; public final static long ONE_Minute = 60 * 1000;//60s执行一次 @Scheduled(fixedDelay=ONE_Minute) public void getNameLimit2() &#123; try &#123; System.out.println(\"开始...\"); List&lt;Map&lt;String, Object&gt;&gt; overtimeList=pushMapper.queryPushProblemOvertime(null); System.out.println(overtimeList.get(0).toString()); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; System.out.println(\"结束...\"); &#125;&#125; Dao层的mapper文件代码注意： @Mapper@Repository // 将这个文件配置到Bean，不然定时任务会取不到数据库数据 123456@Mapper@Repositorypublic interface PushMapper &#123; //查询未商定超时问题 List&lt;Map&lt;String,Object&gt;&gt; queryPushProblemOvertime(Map&lt;String, Object&gt; params);&#125; 结果","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"定时任务","slug":"定时任务","permalink":"http://ligangit.com/tags/定时任务/"}]},{"title":"Oracle判断值相等","slug":"Oracle判断值相等","date":"2020-03-24T02:57:55.000Z","updated":"2020-03-24T03:52:58.796Z","comments":true,"path":"2020/03/24/Oracle判断值相等/","link":"","permalink":"http://ligangit.com/2020/03/24/Oracle判断值相等/","excerpt":"","text":"​ 今天做项目的查询统计时，oracle数据库中有数据，但是带条件后一直查询不出来，最后发现了条件关联查询时，有NULL数据的比较，所以记录一下。 Oracle判断两个数据是否相等1、表数据student表： middle表： 2、判断两个都不可能为空数据直接使用 “=”： 1select * from student s,middle sc where s.sid=sc.sid 结果如下： 3、判断两个可能为空的数据继续使用“=”，发现为NULL数据不能判断相等 12select * from student s,middle sc where s.sid=sc.sid and s.email=sc.email 结果如下： 使用 NVL 函数： 12select * from student,sc where student.sid=sc.sid and NVL(student.email,0) = NVL(sc.email,0) 结果如下： 4、NVL函数NVL函数的格式如下：NVL(expr1,expr2) 含义是：如果oracle第一个参数为空那么显示第二个参数的值，如果第一个参数的值不为空，则显示第一个参数本来的值。 1select sname, NVL(email, '123456@qq.com') from student 结果如下： 注意： NVL(expr1,expr2)，expr1为变量，expr2为当expr1为空时，设置的默认值（一般为0）； 其中：NVL(expr1, 0)和NVL(expr1, ‘0’)的效果一样，最终expr1为空时值结果都为字符串‘0’。","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://ligangit.com/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"}]},{"title":"Spring学习-Bean配置","slug":"Spring学习-Bean配置","date":"2020-03-20T06:50:14.000Z","updated":"2020-03-20T06:50:14.361Z","comments":true,"path":"2020/03/20/Spring学习-Bean配置/","link":"","permalink":"http://ligangit.com/2020/03/20/Spring学习-Bean配置/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SprongBoot学习-自动配置原理","slug":"SprongBoot学习-自动配置原理","date":"2020-01-18T09:29:41.000Z","updated":"2020-06-02T01:43:58.574Z","comments":true,"path":"2020/01/18/SprongBoot学习-自动配置原理/","link":"","permalink":"http://ligangit.com/2020/01/18/SprongBoot学习-自动配置原理/","excerpt":"","text":"Spring Boot学习-自动配置原理1. 自动配置原理 SpringBoot启动的时候加载主配置类，开启了自动配置功能==@EnableAutoConfiguration== @EnableAutoConfiguration作用： 利用AutoConfigurationImportSelector给容器中导入一些组件 可以查看selectImports()方法的内容； List configurations = this.getCandidateConfigurations(annotationMetadata, attributes); 获取候选的配置 1AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); //获取候选的配置 * 1234SpringFactoriesLoader.loadFactoryNames() ; //扫描所有jar包类路径下 META-INF/spring.factories //把扫描到的这些文件的内容包装成properties对象 //从properties中获取EnableAutoConfiguration.class类（类名）对应的值，然后把它们添加到容器中 ==将类路径 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；== 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\ org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\ org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\ org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\ org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\ org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\ org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\ org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveRestClientAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\ org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\ org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\ org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\\ org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\ org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\ org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\ org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\ org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\ org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\ org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\ org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\ org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\ org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\ org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\ org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\ org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\ org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\ org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\ org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\ org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\ org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\ org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\ org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\ org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\ org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\ org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\ org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\ org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\ org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\ org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\ org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\ org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\ org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\ org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\ org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\ org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\\ org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\\ org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\\ org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\\ org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\ org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\ org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\ org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\ org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\ org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\ org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\ org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\ org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\ org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\ org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\ org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\ org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\ org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\ org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\ org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来自动配置。 每一个自动配置类进行自动配置功能； 以HttpEncodingAutoConfiguration（Http编码自动配置）为例解释自动配置原理； 12345678910111213141516171819202122232425262728293031323334@Configuration( proxyBeanMethods = false) //表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(&#123;HttpProperties.class&#125;) //启动指定类的ConfigurationProperties功能；将配置文件中的值和HttpProperties绑定起来；并把HttpProperties加入到ioc容器中@ConditionalOnWebApplication( type = Type.SERVLET) //Spring底层@Conditional注解，根据不同的条件如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是web应用，如果是，当前配置类生效@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中乱码解决过滤器；@ConditionalOnProperty( prefix = \"spring.http.encoding\", value = &#123;\"enabled\"&#125;, matchIfMissing = true) //判断配置文件中是否存在某个配置spring.http.encoding.enabled;如果不存在，判断也是成立的//即使我们配置文件中不配置spring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) &#123; this.properties = properties.getEncoding(); &#125; @Bean //给容器中添加一个组件，这个组件中的某些值需要从properties中获取 @ConditionalOnMissingBean //判断容器中没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一旦这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 所有在配置文件中能配置的属性都是在xxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties( prefix = \"spring.http\") //从配置文件中获取指定的值和bean的属性进行绑定public class HttpProperties &#123; 2. 精髓 SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类； 我们再来看这个自动配置类中底层配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfiguration：自动配置类；给容器中添加组件 xxxxProperties：封装配置文件中相关的属性； 3. 细节 @Conditional派生注解（Spring注解版原生的@Conditional作用） 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置类在一定条件下才能生效； 我们怎么知道哪些自动配置类生效； 我们可以启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； 12345678910111213141516171819202122232425262728============================CONDITIONS EVALUATION REPORT============================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet' (OnClassCondition) - found 'session' scope (OnWebApplicationCondition) DispatcherServletAutoConfiguration.DispatcherServletConfiguration matched: - @ConditionalOnClass found required class 'javax.servlet.ServletRegistration' (OnClassCondition) - Default DispatcherServlet did not find dispatcher servlet beans (DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition)Negative matches:(没有启动，没有匹配成功的自动配置类)----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required class 'javax.jms.ConnectionFactory' (OnClassCondition) AopAutoConfiguration.AspectJAutoProxyingConfiguration: Did not match: - @ConditionalOnClass did not find required class 'org.aspectj.weaver.Advice' (OnClassCondition)","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"自动配置","slug":"自动配置","permalink":"http://ligangit.com/tags/自动配置/"}]},{"title":"SpringBoot学习-配置文件","slug":"SpringBoot学习-配置文件","date":"2019-12-14T09:09:16.000Z","updated":"2020-06-02T01:44:32.218Z","comments":true,"path":"2019/12/14/SpringBoot学习-配置文件/","link":"","permalink":"http://ligangit.com/2019/12/14/SpringBoot学习-配置文件/","excerpt":"","text":"SpringBoot学习-配置文件和注解1、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的： application.properties application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML( YAML Ain’t a Markup Language ) ​ YAML Ain’t a Markup Language : YAML不是一种标记语言； ​ Yet Another Markup Language ： 仍是一种标记语言； 标记语言： ​ 以前的配置文件，大多都是使用的是xxx.xml文件； ​ YAML：以数据为中心，比json、xml等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2、YAML语法1、基本语法​ k:[空格]v 表示一对键值对（空格必须有）； ​ 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的; 123server: port: 8081 path: /hello ​ 属性和值也是大小写敏感； 2、值的写法 字面量： 普通的值（数字，字符串，布尔） k: v ：字面直接来写： ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi” ：输出：zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符数据 ​ name: ‘zhangsan \\n lisi’：输出：zhangsan \\n lisi 对象、Map（属性值）（键值对）： k: v ：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是k: v的方式 123friends: lastName: zhangsan age: 20 行内写法 1friends: &#123;lastName: zhangsan,age: 18 数组（List、Set） 用- 值表示数组中的一个元素 1234pets:- cat- dog- pig 行内写法 1pets: [cat,dog,pig] 3、配置文件值注入 配置文件 123456789101112person: lastName: zhangsan age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: v2&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 2 javaBean 12345678910111213141516/* 将配置文件中配置的每一个属性的值，映射到组件中* @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定* prefix = \"person\" ：配置文件中哪个下面的所有属性进行一一映射* 只有这个组件是容器中的组件，才能还用容器@ConfigurationProperties提供的功能* */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 12345&lt;!--导入配置文件处理器,配置文件进行绑定就会有提示--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/dependency&gt; 4、@ConfigurationProperties和@Vlaue获取值比较 @ConfigurationProperties @Vlaue 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件yml还是properties都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value; 如果说，我们专门编写了一个JavaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties； @ConfigurationProperties(prefix = “person”)默认从全局配置文件中获取。 5、配置文件注入值数据校验1234567891011121314151617@Component@ConfigurationProperties(prefix = \"person\")@Validated //添加数据校验public class Person &#123; @Email //lastName必须是邮箱格式 （@ConfigurationProperties才支持）// @Value(\"$&#123;person.last-name&#125;\") //支持// @Value(\"$&#123;person.lastName&#125;\") //不支持（-n替换为N） private String lastName;// @Value(\"#&#123;11*2&#125;\") private Integer age;// @Value(\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 6、@PropertySource和@ImportResource​ @PropertySource：加载指定的配置文件； 1234567891011121314151617181920/* 将配置文件中配置的每一个属性的值，映射到组件中* @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定* prefix = \"person\" ：配置文件中哪个下面的所有属性进行一一映射* 只有这个组件是容器中的组件，才能还用容器@ConfigurationProperties提供的功能* @ConfigurationProperties(prefix = \"person\")默认从全局配置文件中获取* */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validated //添加数据校验public class Person &#123; // @Email //lastName必须是邮箱格式 （@ConfigurationProperties才支持）// @Value(\"$&#123;person.last-name&#125;\")// @Value(\"$&#123;person.lastName&#125;\") //（不支持-n替换为N） private String lastName;// @Value(\"#&#123;11*2&#125;\") private Integer age;// @Value(\"true\") private Boolean boss; ​ @ImportResource：导入Sprin的配置文件，让配置文件里面的内容生效； Spring Boot里面，没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上； 12//Spring的配置文件，让其生效@ImportResource(locations = &#123;\"classpath:bean.xml\"&#125;) ​ 现在不在编写Spring的配置文件 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.ligangit.springbootstudy.service.HelloService\"&gt; &lt;/bean&gt;&lt;/beans&gt; ​ SpringBoot推荐给容器中添加组件的方式：推荐使用全注解的方式 配置类====Spring配置文件 使用@Bean给容器中添加组件 7、配置文件中的占位符 随机数 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 占位符获取之前配置的值，如果没有可以用:指定默认值 123456789person.last-name=zhangsan$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.boss=falseperson.birth=2017/12/12person.maps.k1=v1person.maps.k2=v4person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_小狗person.dog.age=2 8、Profile​ Profile是Spring对不同环境提供不同配置功能的支持，可以激活、指定参数等方式快速切换环境 多Profile文件格式 在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml； 默认使用application.properties的配置； yml支持多文档块方式 1234567891011121314151617server: port: 8081spring: profiles: active:prod---server: port: 8082spring: profiles:dev---server: port: 8084spring: profiles:prod --指定属于哪个环境 激活指定profile 在配置文件中指定 spring.profiles.active=dev 命令行： –spring.profiles.active=dev 虚拟机参数： -Dspring.profiles.active=dev 9、配置文件加载位置​ SpringBoot启动会扫描application.properties或者application.yml文件作为springboot的配置文件。默认创建项目生成application.properties/yml位置在classpath目录下，也可以在以下4个地方创建，优先级自上而下由高到低，SpringBoot会从这四个位置全部加载主配置文件，各个配置文件成互补状态存在，高优先级的配置会覆盖低优先级的配置。 -file: ./config/ -file: ./ -classpath: /config/ -classpath:/ ​ ==还可以通过spring.config.location来改变默认的配置文件位置== ​ 项目打包好后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同其作用形成互补配置。 ​ ==首先看有没有带profile，然后再看配置文件在jar包内还是外，带profile&gt;没带profile，jar包外&gt;jar包内；== ​ 有jar包外向jar包内进行寻找，优先加载待profile的配置文件，在加载不带profile的配置文件","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"},{"name":"注解","slug":"注解","permalink":"http://ligangit.com/tags/注解/"}]},{"title":"SpringBoot学习-HelloWorld探究","slug":"SpringBoot学习-HelloWorld探究","date":"2019-12-11T09:26:54.000Z","updated":"2020-06-02T01:44:12.379Z","comments":true,"path":"2019/12/11/SpringBoot学习-HelloWorld探究/","link":"","permalink":"http://ligangit.com/2019/12/11/SpringBoot学习-HelloWorld探究/","excerpt":"","text":"SpringBoot学习-Hello World探究1、POM文件1、父项目1234567891011121314 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;/parent&gt;他的父项目是&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath&gt;../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来正真管理Spring Boot应用里面的所有依赖版本 Spring Boot的版本依赖中心； 以后我们导入的依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要申明版本号） 2、启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web： ​ spring-boot-starter：spring boot场景启动器，帮我们导入了web模块正常运行所依赖的组件； Spring Boot将所有的功能场景都抽取出来，做成一个starters（启动器），只需要在项目里面引入这些starters，相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景的启动器。 2、主程序类，主入口类12345678910/***@Description @SpringBootApplication 来标注一个主程序类，说明这是一个SpringBoot类*/@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(HelloWorldMainApplication.class, args); &#125;&#125; @SpringBootApplication： Spring Boot应用标注在某个类上说明这个类是Spring Boot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用。 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; ​ 1、@SpringBootConfiguration: SpringBoot配置类； ​ 标注在某个类上，表示这是一个Spring Boot的配置类； ​ @Configuration:配置类上来标注这个注解； ​ 配置类……配置文件：配置类也是容器中的一个组件：@Component ​ 2、@EnableAutoConfiguration:开启自动配置功能； ​ 以前我们需要配置的东西，Sping Boot帮我们自动配置；@EnableAutoConfiguration告诉我们SpringBoot开启自动配置功能；这样的自动配置才能生效； 123@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage: 自动配置包 ​ @Import({Registrar.class})： ​ Spring的底层注解@Import，给容器导入一个组件；导入的组件有Registrar.class； ​ ==将主配置类（@SpringBootConfiguration标注的类）的所在包及下面子包里面的所有组件扫描到Spring容器；== ​ @Import({AutoConfigurationImportSelector.class}): ​ AutoConfigurationImportSelector: 导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxAutoConfiguration）;就是给容器中导入这个场景需要的所有组件，并配置好这些组件； ​ 有了自动配置类，免去了我们手动编写配置注入功能组件等工作； ​ ==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们做了； ​ J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-2.2.2.RELEASE.jar；","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"}]},{"title":"SpringBoot学习-项目创建","slug":"SpringBoot学习-项目创建","date":"2019-12-09T08:32:12.000Z","updated":"2020-06-02T01:44:26.382Z","comments":true,"path":"2019/12/09/SpringBoot学习-项目创建/","link":"","permalink":"http://ligangit.com/2019/12/09/SpringBoot学习-项目创建/","excerpt":"","text":"SpringBoot学习-项目创建1、搭建环境 jdk1.8以上 maven3.3以上 IDEA2019 2、创建Maven项目​ 创建一个普通的Maven项目 3、在pom.xm添加依赖123456789101112&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4、编写一个主程序：启动SpringBoot应用123456789@SpringBootApplication // 来标注一个主程序类，说明这是一个Spring Boot项目public class Application &#123; public static void main(String[] args) &#123; //Spring应用启动起来 SpringApplication.run(Application.class, args); &#125;&#125; 5、编写相关的Controller、Service注意：controller、service包和主程序类同级 123456789@Controllerpublic class HelloWorldController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 6、运行主程序测试http://localhost:8080/hello 7、简化部署123456789&lt;!--这个插件，可以将引用打包成一个可执行的jar包--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打包成jar包，直接使用java -jar的命令执行 8、快速创建Spring Boot项目 File -&gt; New -&gt; Project，选择Spring Initializr，选择JDK 设置组织ID，模块ID 选择应用场景，导入对应依赖，如选择Web 设置工程名（一般为默认值），然后Finish 向导联网会自动创建Spring Boot项目，目录结构如下，其中选中的文件一般无用，可以删除 默认生成的Spring Boot项目； 主程序已经生成好了，我们只写需要我们自己的逻辑 resource文件夹中目录结构 static：保存所有的静态资源，如 js、css、images; templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker，thymeleaf）; application.properties：Spring Boot的配置文件 默认目录结构如下：","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://ligangit.com/tags/SpringBoot/"}]},{"title":"Oracle导出导入数据库","slug":"Oracle导出导入数据库","date":"2019-11-13T08:43:46.000Z","updated":"2020-06-02T01:44:50.312Z","comments":true,"path":"2019/11/13/Oracle导出导入数据库/","link":"","permalink":"http://ligangit.com/2019/11/13/Oracle导出导入数据库/","excerpt":"","text":"Oracle数据库导出1、查询地址​ 查询数据库配置的地址 1select * from dba_directories; 2、导出​ 进入Oracle服务器，打开CMD，运行导出命令。 语法：12345678910111213--语法expdp oracle_user_name/oracle_user_pwd@ip:port/ ORACLE_SID directory=file_save_address DUMPFILE=exprot_file_name.dmp logfile=exprot_logfile_name.log REUSE_DUMPFILES = Y version=version_num--名词解释(这些名词都需要换成个人实际的信息)--oracle_user_name 数据库用户名称--oracle_user_pwd 数据库用户密码--ip ip地址（服务器ip地址，个人登录Oracle时填写的IP，也是数据库的ip地址）--port 端口号--ORACLE_SID 数据库实例--file_save_address 数据库保存路径（是数据库配置地址的别名）--exprot_file_name.dmp 导出数据库名称（.dmp不能更改）--exprot_logfile_name.log 导出数据库生成的日志文件名称（.log不能更改）--version_num 数据库版本 （version=version_num 可以不带上） 示例： 本人登录Oracle的用户信息： ​ 2、执行SQL语句： 1select * from dba_directories; 得到地址信息： ​ ​ 我选择将导出文件保存在G:\\app\\Administrator/admin/credit/dpdump/目录下，所以选择的file_save_address为DATA_PUMP_DIR，这个地址是Oracle服务器所安装的主机中的地址。 在Oracle服务器所安装的主机上运行CMD命令 ​ 导出mydb用户下的数据库，并将地址保存在DATA_PUMP_DIR 目录下，导出文件名为mydb20191113_expdp.dmp ，导出的日志文件为mydb20191113_expdp.log，Oracle数据库版本为11.2.0.1.0 12--示例expdp mydb/123456@192.168.168.138:1521/CREDIT directory=DATA_PUMP_DIR DUMPFILE=mydb20191113_expdp.dmp logfile=mydb20191113_expdp.log REUSE_DUMPFILES = Y version=11.2.0.1.0 注意： ​ DATA_PUMP_DIR 是在Oracle管理工具中执行SQL语句后的地址信息中有一条地址名称。 Oracle数据库导入1、查询用户名​ 查询需要导入的数据库的用户名是否存在，如果不存在需要创建用户、创建表空间，创建好之后，再执行导入数据库操作；如果用户存在则直接执行导入数据库操作。 1select * from dba_users; 2、创建用户、表空间查询Oracle地址​ 在执行创建用户、表空间之前，我们需要知道表空间的创建的地址，继续使用查询地址SQL（在需要导入的数据库中执行），查看Oracle的地址。 1select * from dba_directories; ​ 继续使用导出时的Oracle数据库： ​ 语法：12345678910111213--创建表空间create tablespace oracle_user_name datafile 'oracle_address/tablespace_name.DBF' size 200m reuse autoextend on next 200m maxsize unlimited default storage(initial 128k next 128k minextents 2 maxextents unlimited);--创建表空间中的用户create user user_name identified by user_password default tablespace tablespace_name;--授权grant dba,connect,resource,create any table,select any table,update any table,insert any table,delete any table ,drop any table to tablespace_name;--名词解释(这些名词都可以换成自己需要的)--oracle_address 查询数据库地址时的地址，也是导入文件存放的地址--tablespace_name 表空间名称--user_name 用户名--user_password 用户密码 示例：​ 我选择在E:/export_dir目录下创建表空间qydj，用户名为qydj，密码为1。 123create tablespace NECIPS_ZSTZSB datafile 'E:/export_dir/qydj.DBF' size 200m reuse autoextend on next 200m maxsize unlimited default storage(initial 128k next 128k minextents 2 maxextents unlimited);create user qydj identified by 1 default tablespace qydj;grant dba,connect,resource,create any table,select any table,update any table,insert any table,delete any table ,drop any table to qydj; 导入数据 首先将需要导入的数据库文件复制到Oracle的一个地址目录下； 执行CMD导入命令。 语法：1234567891011impdp user_name/user_password directory=EXPORT_DIR dumpfile=exprot_file_name.DMP remap_schema=old_schema:new_schema remap_tablespace=old_tablespace:new_tablespace logfile=import_file_log.log--名词解释(这些名词都换成自己实际的内容)--user_name 刚创建的用户名--user_password 刚创建的用户的密码--oracle_address 需要导入的数据库的文件地址（这个地址是在oracle中配置好的，我们将数据库的.dmp文件复制到这个目录下）--old_schema 模式名称（一般为导入数据库的用户名）--new_schema 模式名称（一般为刚创建的用户名）--old_tablespace 表空间（导入数据库的表空间）--new_tablespace 表空间（刚创建的表空间）--import_file_log 日志文件（导入操作生成的日志文件） 示例：​ 将之前导出的数据库导入到上一步创建的qydj用户下。 1impdp qydj/1 directory=oracle_address dumpfile=mydb20191113_expdp.DMP remap_schema=mydb:qydj remap_tablespace=mydb:qydj logfile=qydj20191113.log ​ 注意： ​ 我们在导入的时候可能会报用户名已存在，视图、存储过程报错（已编译，但有警告），这些是没关系的，这些可能是我们的视图、存储过程跨用户查询了数据。","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://ligangit.com/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"}]},{"title":"idea打开新Web项目并运行","slug":"idea打开新Web项目并运行","date":"2019-11-06T01:46:24.000Z","updated":"2020-06-11T01:58:03.593Z","comments":true,"path":"2019/11/06/idea打开新Web项目并运行/","link":"","permalink":"http://ligangit.com/2019/11/06/idea打开新Web项目并运行/","excerpt":"","text":"​ 记得刚开始使用idea的时候，拿到一个web项目，却不知道怎么跑起来，这几天打开完整的Web项目有点多，而且一开始也忘记了怎么配置，今天就写了这篇博客。 一、配置Web结构（设置war包）1、使用IDEA打开项目，进入Project Structure点击File，选择Project Structure，操作如下图： 2、添加Modules点击Modules，然后点击”十“按钮，选择Web，操作如下图： 点击Web后会得到下面的效果图，在在图中我修改好了web.xml文件路径、根路径，我们将红色框中的内容改为自己web项目中web.xml的路径信息就可以了： 3、添加Artifacts点击Artifacts，然后点击”十“按钮，选择Web Application:Exploded，点击 From Modules…，然后会弹出选择Modules框，操作如下图： 选择我们刚创建号的Modules，点击OK，如下图： 4、添加jar包点击Libraris，然后点击”十“按钮，选择Java，操作如下图： 选择jar包，jar包在WEB-INF文件夹下的lib文件夹中，我们可以之间选择lib文件夹，也可以选择lib中的jar包，选择之后会弹出选择Modules框，点击OK就可以了，操作如下图： 5、点击Apply，点击OK二、配置tomcat1、添加tomcat sercer点击Add Configuration，再点击“十”按钮，然后将鼠标焦点放置在Tomcat Server上，选择Local，进入Tomcat信息配置窗口，操作如下图： 2、配置Tomcat信息弹出的Tomcat信息窗口如下图： 第一项 是设置的IDEA显示的Tomcat名称； 第二项 是自己的Tomcat版本； 第三项 是JRE，可以选择自己安装的JDK下的jre文件 第四项 是运行的web包，即之前配置的war包 我们需要点击Fix，添加运行的war包，点击Fix后，出现如下界面： 在这里我们可以修改项目访问路径，如果像上面的界面一样，那么访问项目的URL就是： http://localhost:8080/zhirong_wisdomFire_war_exploded 其中“/zhirong_wisdomFire_war_exploded ”就是8080后面的项目路径，我们可以修改成自己想要的值，如“/”，那么访问地址就是： http://localhost:8080/ 3、最后点击“Apply”，点击”OK“得到如下界面 我们点击红色方框中的绿色三角形按钮，即“启动”按钮就可以启动项目了。","categories":[{"name":"java","slug":"java","permalink":"http://ligangit.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"idea","slug":"idea","permalink":"http://ligangit.com/tags/idea/"},{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"},{"name":"web","slug":"web","permalink":"http://ligangit.com/tags/web/"}]},{"title":"idea对web项目打war包","slug":"idea对web项目打war包","date":"2019-11-04T09:10:23.000Z","updated":"2020-06-11T01:50:25.506Z","comments":true,"path":"2019/11/04/idea对web项目打war包/","link":"","permalink":"http://ligangit.com/2019/11/04/idea对web项目打war包/","excerpt":"","text":"​ 很多时候，完成项目需要打成war包，然后部署在服务器里面，对于小白来说，一开始会不知道怎么打包，我就是经历过，所以将这个打包的过程写下来。 ​ 下面有两种打包方式，一种是传统的web项目，一种是maven项目。 传统web项目打war包1、File –&gt;Project Structure，如下图： 2、点击”Artifacts“，然后在右边的界面中点击”十“号，选择”Web Application:Archive“，选择打包项，选择后就可以点击”Apply“按钮了，操作如下图： 3、执行打包过程，点击”Build”，选择“Build Artifacts”，选择war包，然后先点击“Clean”,清空下，清空之后，在此点击”Build”，选择“Build Artifacts”，选择war包，然后先点击“Bulid”,清空下，操作如下图： 4、打包好的War包在classes –&gt; artifacts ,如下图 Maven项目打war包1、点击窗口右边的”Maven”，弹出窗口； 2、点击“Clean”，先清空项目； 3、点击“Insatll”，打jar包； 4、点击“Pagkage”，打War包。 具体操作如下图： 5、打包好的War包在target文件夹下 ,如下图","categories":[{"name":"java","slug":"java","permalink":"http://ligangit.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"idea","slug":"idea","permalink":"http://ligangit.com/tags/idea/"},{"name":"研发工具","slug":"研发工具","permalink":"http://ligangit.com/tags/研发工具/"},{"name":"web","slug":"web","permalink":"http://ligangit.com/tags/web/"}]},{"title":"博客加载图片","slug":"博客加载图片","date":"2019-10-25T09:34:56.000Z","updated":"2019-11-04T10:11:44.284Z","comments":true,"path":"2019/10/25/博客加载图片/","link":"","permalink":"http://ligangit.com/2019/10/25/博客加载图片/","excerpt":"","text":"​ 如今开始写博客了，最近几篇博客需要用到图片，但是一直不知道怎么解决，使用markdown语法的图片，使用markdown编辑软件可以看到，但是在网页上加载不出来，一直在网上查找解决方案，现在可以展示图片了，现在将这方法写下来。 创建文件夹在博客目录下的资源文件夹下创建保存图片的文件下。 博客目录如下： 在source目录下创建images文件夹，用于保存图片。 如下图： 在博客中引用图片移动图片​ 我们将需要引用的图片放在images文件夹里面，当然也可以创建多个文件夹分批保存图片，如下图。 使用图片方法一：​ 在博文中需要引用图片的位置编写如下语法： 123456![图片解释说明](图片路径) 图片解释说明是显示图片下面的字； 图片路径 是存放图片的路径； 如：我刚创建的images,引用地址就是 /images/图片名字： ![博客引用图片](/images/show.png) ​ 效果如下： 方法二：​ 使用&lt;img&gt; 标签，就如写html插入图片一样： 123456&lt;img src=\"图片路径\" alt=\"图片解释说明文字\"&gt; 图片路劲 是存放图片的路径； alt属性可有可无； 如：我刚创建的images,引用地址就是 /images/图片名字： &lt;img src=\"/images/show.png\" alt=\"博客引用图片\"&gt; ​ 效果如下： 缺陷​ 这种在博客中添加图片的方式，在加载图片的时候可能会比较慢，特别是图片过多的时候，项目会比较大，最好是将图片托管在图片网站，然后直接使用网上地址。 注意​ 当我们把博客托管在github上后，我们在使用hexo s 命令，本地运行后，可能会显示不出图片，这是因为hexo g 命令会将图片的地址转换为网络地址，会带上你的gtihub网址，这时我们想在本地看到效果的化，先执行 hexo d ,上传到github，然后在hexo s，在本地查看效果。","categories":[{"name":"博客","slug":"博客","permalink":"http://ligangit.com/categories/博客/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://ligangit.com/tags/markdown/"},{"name":"博客","slug":"博客","permalink":"http://ligangit.com/tags/博客/"}]},{"title":"mysql之数据合并","slug":"mysql之数据合并","date":"2019-10-11T03:49:05.000Z","updated":"2019-11-13T10:12:48.927Z","comments":true,"path":"2019/10/11/mysql之数据合并/","link":"","permalink":"http://ligangit.com/2019/10/11/mysql之数据合并/","excerpt":"","text":"​ 在进行数据库的数据整理的时候，特别是对新老平台、规则替换的时候，会碰到数据合并的问题，我将这次整理过程的数据合并写了这篇博客。 需求表中存在很多需要合并的内容，如下图 将两列数据保留一条，并且内容合并在一起，需要将内容顺序拼接。 方法使用left join 连接，将保留的信息，和合并的内容连接； 使用CONCAT(str1,str2,…) 函数，拼接字符串； 使用CHAR_LENGTH(str) 函数，判断内容字符串的长度，便于内容顺序合并。 12345678910111213141516171819202122-- 3、保存需要合并的内容create table smcontent22 ( select SM_ID ,destaddr , DATE_FORMAT(sendtime,&apos;%Y-%m-%d&apos;) sendtime,SM_CONTENT from tbl_smresult where PROTOCOLTYPE=3 and SM_CONTENT not like &apos;【政务外网短信平台】%&apos; and pktotal&gt;1) ;-- 4.2 合并两条短信的内容 UPDATE tbl_smresult a left join smcontent22 b on a.SM_ID =b.SM_ID and a.PROTOCOLTYPE=&apos;3&apos; and a.destaddr=b.destaddr set a.SM_CONTENT= CONCAT(a.SM_CONTENT,b.SM_CONTENT) where a.SM_ID =b.SM_ID and a.PROTOCOLTYPE=&apos;3&apos; and a.destaddr=b.destaddr and DATE_FORMAT(a.sendtime,&apos;%Y-%m-%d&apos;)=b.sendtime and CHAR_LENGTH(b.SM_CONTENT)&lt;67 and a.SM_CONTENT like &apos;【政务外网短信平台】%&apos; ;","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"},{"name":"mysql","slug":"mysql","permalink":"http://ligangit.com/tags/mysql/"},{"name":"数据处理","slug":"数据处理","permalink":"http://ligangit.com/tags/数据处理/"}]},{"title":"mysql存储过程学习","slug":"mysql存储过程编写","date":"2019-09-29T01:20:49.000Z","updated":"2019-11-13T10:12:32.722Z","comments":true,"path":"2019/09/29/mysql存储过程编写/","link":"","permalink":"http://ligangit.com/2019/09/29/mysql存储过程编写/","excerpt":"","text":"​ 进行Java Web 项目的时候，经常需要执行数据库查询，有时对一些表数据进行统计，特别是统计分析的时候，原有的SQL执行会比较慢，而且每次点击都会比较慢，如今使用存储过程，可以将那些不需要实时展示的统计数据统计并存储在统计结果表里面，提高查询速度。 mysql存储过程学习1、申明存储过程1CREATE DEFINER = CURRENT_USER PROCEDURE `demo`() 2、存储过程开始和结束符号所有的内容SQL语句都是写在BEGIN END 里面。 123BEGIN #Routine body goes here...END; 3、变量定义 int类型： 变量名 num，类型 int，无符号， 默认值 4000000。（默认值可以不设置，即 default 4000000可去掉） 1DECLARE num int unsigned default 4000000; varchar类型： 变量名Mobile ，类型VARCHAR，长度50，默认值 hello。（默认值可以不设置，即 default ‘hello’ 可去掉） 编码格式 charset ‘utf8’ 设置编码格式为utf8。 1DECLARE Mobile VARCHAR(50) default &apos;hello&apos; charset &apos;utf8&apos;; 4、变量赋值 已定义变量赋值(局部变量) 方法一：使用set 1set Mobile=&apos;world&apos;; 方法二：使用select …. into… 1234select mobile into Mobile from students where id=1; 未定义变量直接赋值（用户变量） 方法一：使用set 1set @email=&apos;12345@qq.com&apos;; 方法二：使用select …. into… 12set @email=&apos;&apos;;select @email :=email from students; 5、条件语句 if-then-else语句 123if startyear&gt;2016 then select name from students;end if; 12345if startyear&gt;2016 then select name from students;else select email from students;end if; case语句 1x 1declare var int; 2set var=0;3case var4when 0 then5 select name from students;6when 1 then7 select email from students;8else9 select mobile from students;10end case;mysql 6、循环语句 while ···· end while 123456declare var int; set var=0;while var&lt;3 do select name from students where id=var; set var=var+1;end while; repeat···· end repea 操作后判断循环条件，while是先判断循环条件在执行循环体。 1234567declare var int; set var=0;repeat select name from students where id=var; set var=var+1;until var&gt;2end repeat; loop ·····endloop loop 循环不需要初始条件，这点和 while 循环相似，同时和 repeat 循环一样不需要结束条件, leave 语句的意义是离开循环。 12345678declare var int; set var=0;LOOP_LABLE:loop set var=var+1; if var&gt;2 then leave LOOP_LABLE; end if;end loop; 7、游标的使用 定义游标及数据 1234-- mobile变量接收游标中的值DECLARE Mobile VARCHAR(50) ; DECLARE UpdateAuthorCursor CURSOR for SELECT name from students; 设置游标内容执行完毕标志 1DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; 打开游标 1open UpdateAuthorCursor; 循环游标内数据 123456789posLoop:LOOP --判断是否结束循环 if done then leave posLoop; end if; --取出游标中的数据，并保存在变量中 FETCH UpdateAuthorCursor into Mobile; update students set mobile=Mobile where id=0; end LOOP; 关闭游标 1close UpdateAuthorCursor; 8、示例1234567891011121314151617181920212223242526272829303132333435363738394041424344-- 创建存储过程CREATE DEFINER=`root`@`localhost` PROCEDURE `merge2019`()BEGIN-- 定义变量DECLARE yearnum int DEFAULT year(CURRENT_DATE); DECLARE Mobile VARCHAR(50) ; DECLARE Content VARCHAR(3200) ; DECLARE Taskid VARCHAR(255) ; DECLARE Sendtime VARCHAR(255) ; -- 创建游标 DECLARE done INT DEFAULT FALSE; DECLARE UpdateAuthorCursor CURSOR for SELECT b.CONTENT,b.MOBILE , case when b.TASKID is not null then b.TASKID else &apos;&apos; end as TASKID , DATE_FORMAT(b.SENDTIME,&apos;%Y-%m-%d&apos;) as sendtime FROM jx_sendresult_2019_1 b; -- 设置游标循环结束标志 DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;-- 打开游标 OPEN UpdateAuthorCursor; -- 循环游标内容 read_loop: LOOP FETCH UpdateAuthorCursor INTO Content, Mobile, Taskid, Sendtime; -- 设置循环结束标识 IF done THEN LEAVE read_loop; END IF; -- 执行SQL操作 select count(1) from tbl_smresult; UPDATE tbl_smresult_2019_2 SET MSGID = Taskid WHERE SM_CONTENT= Content and DESTADDR= Mobile and MSGID =&apos;&apos; and DATE_FORMAT(SENDTIME,&apos;%Y-%m-%d&apos;)=Sendtime limit 1; COMMIT; END LOOP; -- 关闭游标 CLOSE UpdateAuthorCursor; -- 结束存储过程END","categories":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://ligangit.com/tags/sql/"},{"name":"mysql","slug":"mysql","permalink":"http://ligangit.com/tags/mysql/"},{"name":"存储过程","slug":"存储过程","permalink":"http://ligangit.com/tags/存储过程/"},{"name":"游标","slug":"游标","permalink":"http://ligangit.com/tags/游标/"}]},{"title":"取出hibernate执行的SQL的结果集","slug":"取出hibernate执行的SQL的结果集","date":"2019-09-25T09:34:56.000Z","updated":"2020-06-11T01:49:31.674Z","comments":true,"path":"2019/09/25/取出hibernate执行的SQL的结果集/","link":"","permalink":"http://ligangit.com/2019/09/25/取出hibernate执行的SQL的结果集/","excerpt":"","text":"​ 最近碰到了BUG，在操作hibernate的SQL结果集的时候报类型转换错误，在这个问题上花费了好多时间，就将这个BUG的解决心得写在了这篇博客里面。 取出hibernate执行的SQL的结果集java取出数据报错最近在一个SSH项目中碰到了一个获取数据的问题，SQL执行后的结果集使用类型转换提取数据时报错。 下面是DAO层实现类中的方法：返回了结果集List。 1234567891011121314151617181920public List&lt;TblSwitch&gt; getPagelist(Integer limit, Integer offser, String where, Object[] obj) &#123; logger.info(\"get getPagelist by:\"); String sql=\"select a.add_user, \" + \" a.old_protocol,a.now_protocol,a.mobile,a.add_time,a.delete_mark,a.update_time,a.id,a.remark \" + \" from tbl_switch a where 1=1 and a.delete_mark=0 \"+where+\" ORDER BY a.add_time DESC \"; List&lt;TblSwitch&gt; list=null; try&#123; Query query=this.getSession().createSQLQuery(sql).setFirstResult(limit).setMaxResults(offser); if(null !=obj&amp;&amp;obj.length&gt;0)&#123; for(int i=0;i&lt;obj.length;i++)&#123; query.setParameter(i, obj[i]); &#125; &#125; list=query.list(); &#125;catch(Exception e)&#123; logger.error(\"get page getPagelist error:\"+e.getMessage()); e.printStackTrace(); &#125; return list; &#125; 在控制层对结果集list进行操作 ​ 当我想对结果集进行操作的时候，发现无法对类型进行强制转换（将list中的每个对象强转为TblSwitch类型），在这条语句中会报错，但是我需要取出每个对象的内容。 123for (int i = 0; i &lt; list.size(); i++) &#123; TblSwitch tblSwitch1=list.get(i); &#125; ​ 强转Map同样报错 1Map&lt;String, Object&gt; dataMap = (Map&lt;String, Object&gt;) list.get(i); ​ 强转Map报错信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454627-Sep-2019 15:47:26.547 涓ラ噸 [http-nio-8080-exec-8] org.apache.catalina.core.StandardWrapperValve.invoke Servlet.service() for servlet [msg] in context with path [] threw exception [Request processing failed; nested exception is java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to java.util.Map] with root cause java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to java.util.Map at com.zhirong.base.web.SwitchNumberController.popSumExport(SwitchNumberController.java:547) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.bind.annotation.support.HandlerMethodInvoker.invokeHandlerMethod(HandlerMethodInvoker.java:176) at org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.invokeHandlerMethod(AnnotationMethodHandlerAdapter.java:426) at org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.handle(AnnotationMethodHandlerAdapter.java:414) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:790) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:719) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:644) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:549) at javax.servlet.http.HttpServlet.service(HttpServlet.java:635) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at net.bull.javamelody.MonitoringFilter.doFilter(MonitoringFilter.java:203) at net.bull.javamelody.MonitoringFilter.doFilter(MonitoringFilter.java:181) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:76) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:650) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:800) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:806) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) 解决方法：方法一：​ 将对象赋值给Object map，这时map中有list中的对象的数据，但是不能用map.getAddUser()的方法获取，这时我将map强制转换成了Object[] objs，这样就将一个对象的属性用数组的形式保存起来了，通过数组下标取值，获取数据。 12345678910111213141516171819for (int i = 0; i &lt; list.size(); i++) &#123; Object map=list.get(i); Object[] objs=(Object[])map; //强转object数组对象 if (null!=objs[0])&#123; adduser=objs[0].toString(); &#125; if (null!=objs[1])&#123; oldProtocol=objs[1].toString(); &#125; if (null!=objs[2])&#123; nowProtocol=objs[2].toString(); &#125; if (null!=objs[3])&#123; mobile=objs[3].toString(); &#125; if (null!=objs[4])&#123; addtime=objs[4].toString(); &#125; &#125; 方法二：​ 将SQL结果返回值设置为List，不在是List&lt;TblSwitch&gt;，这时在遍历list的时候可以将list中的对象强转为Map类型。 修改返回值： 1234567891011121314151617181920public List getPagelist(Integer limit, Integer offser,String where, Object[] obj) &#123; logger.info(\"get getPagelist by:\"); String sql=\"select a.add_user, \" + \" a.old_protocol,a.now_protocol,a.mobile,a.add_time,a.delete_mark,a.update_time,a.id,a.remark \" + \" from tbl_switch a where 1=1 and a.delete_mark=0 \"+where+\" ORDER BY a.add_time DESC \"; List list=null; try&#123; Query query=this.getSession().createSQLQuery(sql).setFirstResult(limit).setMaxResults(offser); if(null !=obj&amp;&amp;obj.length&gt;0)&#123; for(int i=0;i&lt;obj.length;i++)&#123; query.setParameter(i, obj[i]); &#125; &#125; list=query.list(); &#125;catch(Exception e)&#123; logger.error(\"get page getPagelist error:\"+e.getMessage()); e.printStackTrace(); &#125; return list;&#125; 使用Map接收list的对象 1Map&lt;String, Object&gt; dataMap = (Map&lt;String, Object&gt;) list.get(i); 页面取值页面取值也是同样使用下标获取数据。 c:if 判断list是否为空； 1&lt;c:if test=\"$&#123;null != list&#125;\"&gt; c:forEach 遍历list； 1&lt;c:forEach items=\"$&#123;list&#125;\" var=\"dataList\" varStatus=\"status\"&gt; ${} 取值，利用下标确定对象中的某个属性。 1$&#123;dataList[3]&#125; 页面部分代码 123456789101112131415161718192021222324252627282930313233343536373839 &lt;c:if test=\"$&#123;null != list&#125;\"&gt; &lt;c:forEach items=\"$&#123;list&#125;\" var=\"dataList\" varStatus=\"status\"&gt; &lt;c:choose&gt; &lt;c:when test=\"$&#123;status.count % 2 == 0&#125;\"&gt; &lt;tr style=\"background-color:#FFFFFF\" onclick=\"Zving.DataGrid.onRowClick(this,event);\"&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;tr style=\"background-color:#F9FBFC\" onclick=\"Zving.DataGrid.onRowClick(this,event);\"&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; &lt;td rowno=\"$&#123;(page.page*page.rows) + (status.index+1) &#125;\" class=\"rowNo\" style=\"text-align: center;\"&gt; $&#123;(status.index+1)+(page.page*page.rows)&#125; &lt;/td&gt; &lt;td title=\"$&#123;dataList[3] &#125;\" style=\"text-align: center;\"&gt; $&#123;dataList[3]&#125; &lt;/td&gt; &lt;td title=\"$&#123;dataList[1] &#125;\" style=\"text-align: center;\"&gt; &lt;c:if test=\"$&#123;dataList[1]=='0'&#125;\"&gt;移动&lt;/c:if&gt; &lt;c:if test=\"$&#123;dataList[1]=='1'&#125;\"&gt;联通&lt;/c:if&gt; &lt;c:if test=\"$&#123;dataList[1]=='2'&#125;\"&gt;电信&lt;/c:if&gt; &lt;/td&gt; &lt;td title=\"$&#123;dataList[2] &#125;\" style=\"text-align: center;\"&gt; &lt;c:if test=\"$&#123;dataList[2]=='0'&#125;\"&gt;移动&lt;/c:if&gt; &lt;c:if test=\"$&#123;dataList[2]=='1'&#125;\"&gt;联通&lt;/c:if&gt; &lt;c:if test=\"$&#123;dataList[2]=='2'&#125;\"&gt;电信&lt;/c:if&gt; &lt;/td&gt; &lt;td title=\"&lt;fmt:formatDate value=\"$&#123;dataList[4]&#125;\" pattern=\"yyyy-MM-dd\" /&gt;\" style=\"text-align: center;\"&gt; &lt;fmt:formatDate value=\"$&#123;dataList[4]&#125;\" pattern=\"yyyy-MM-dd\" /&gt; &lt;/td&gt; &lt;td title=\"$&#123;dataList[0]&#125;\" style=\"text-align: center;\"&gt;$&#123;dataList[0]&#125;&lt;/td&gt; &lt;td title=\"\" style=\"text-align: center;\"&gt; &amp;nbsp;&amp;nbsp; &lt;a href=\"#\" onclick=\"return doUpdate($&#123;dataList[7]&#125;)\"&gt;修改&lt;/a&gt; &amp;nbsp;&amp;nbsp; &lt;a href=\"#\" onclick=\"return del($&#123;dataList[7]&#125;)\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt;&lt;/c:if&gt;","categories":[{"name":"bug","slug":"bug","permalink":"http://ligangit.com/categories/bug/"}],"tags":[{"name":"java","slug":"java","permalink":"http://ligangit.com/tags/java/"},{"name":"hibernate","slug":"hibernate","permalink":"http://ligangit.com/tags/hibernate/"},{"name":"object","slug":"object","permalink":"http://ligangit.com/tags/object/"},{"name":"bug","slug":"bug","permalink":"http://ligangit.com/tags/bug/"}]},{"title":"Typora学习md语法","slug":"Typoras学习md语法","date":"2019-09-04T08:41:07.000Z","updated":"2020-05-29T02:53:37.212Z","comments":true,"path":"2019/09/04/Typoras学习md语法/","link":"","permalink":"http://ligangit.com/2019/09/04/Typoras学习md语法/","excerpt":"","text":"​ 开始写博客了，对我这种小白来说，自己以前没有接触过makdown语法，现在开始使用了，就开始学习了，主要是使用Typora学习markdown语法，一边写博客一边学习。 用Typora学习.MD语法1、标题 语法 12345# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题 2、引用 语法 123&gt; 引用内容1&gt; 引用内容2&gt;&gt; 引用内容3 效果 引用内容1 引用内容2 引用内容3 3、列表3.1 无序列表 语法 123* 无序列表1+ 无序列表2_ 无序列表3 效果 无序列表1 无序列表2 无序列表3 3.2 多行无序列表 语法 123* 多行无序列表1TAB键 * 多行无序列表2TAB键 TAB键 * 多行无序列表3 效果 多行无序列表1 多行无序类表2 多行无序列表3 语法2 123* 多行无序类表1TAB键 多行无序列表2TAB键 多行无序列表3 效果2 多行无序类表1 多行无序列表2 多行无序列表3 3.3 有序列表 语法 1231. 有序列表12. 有序列表23. 有序类表3 效果 有序类表1 有序列表2 有序列表3 3.4 多行有序列表 语法 12345671. 多行有序类表12. 多行有序列表2 1. 多行有序列表2-1 2. 多行有序列表2-23. 多行有序列表3 1. 多行有序列表3-1 2. 多行有序列表3-2 效果 多行有序列表1 多行有序列表2 多行有序列表2-1 多行有序列表2-2 多行有序列表3 多行有序列表3-1 多行有序列表3-2 3.5 任务列表 语法 123-[ ] 起床-[x] 洗漱-[ ] 吃早餐 效果 -[ ] 起床 -[x] 洗漱 -[ ] 吃早餐 3.6表格 语法 123456|姓名|性别|年龄|手机号|邮箱||:---|:--:|:--:|:--:|---:||张三|男|20|18799999999|123456@qq.com||李四|女|19|18799999999|123456@qq.com||王五|男|21|18799999999|123456@qq.com||赵六|女|17|18799999999|123456qq.com| 效果 姓名 性别 年龄 手机号 邮箱 张三 男 20 18799999999 123456@qq.com 李四 女 19 18799999999 123456@qq.com 王五 男 21 18799999999 123456@qq.com 赵六 女 17 18799999999 123456@qq.com 4. 链接4.1 图片 语法1（本地图片） 12![图片上传失败...](图片地址)![图片上传失败...](hello.png) 效果 语法2（网络图片） 1![typora.jpg](https://upload-images.jianshu.io/upload_images/1538862-d91e815790b81e4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 效果 4.2 超链接 语法1（行内式） 12[无标题](https://www.baidu.com)[有标题][https://www.baidu.com \"此处是标题\"] 效果1 [无标题][https://www.baidu.com] [有标题][https://www.baidu.com “此处是标题”] 语法2（参数式） 1234[方式1]:https://www.baidu.com \"参数\"[方式2]:https://www.baidu.com '参数'[方式3]:https://www.baidu.com (参数)[方式4]:&lt;https://www.baidu.com&gt; \"参数\" 效果2 语法3（链接显示） 1&lt;https://www.ligangit.com&gt; 效果3 https://www.ligangit.com 5. 字体样式5.1 斜体 语法 12*斜体*_斜体_ 效果 斜体 斜体 5.2 加粗 语法 12**加粗**__加粗__ 效果 加粗 加粗 5.3 下划线 语法 1&lt;u&gt;下划线&lt;/u&gt; 效果 下划线 5.4 删除线 语法 1~~删除线~~ 效果 删除线 5.5 分割线 语法 1--- 效果 5.6 转义 语法 123456\\\\\\*\\+\\-\\`\\_ 效果 \\*+-`_","categories":[{"name":"博客","slug":"博客","permalink":"http://ligangit.com/categories/博客/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://ligangit.com/tags/markdown/"},{"name":"Typoras","slug":"Typoras","permalink":"http://ligangit.com/tags/Typoras/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-07-27T04:03:57.408Z","updated":"2019-11-04T10:06:33.400Z","comments":true,"path":"2019/07/27/hello-world/","link":"","permalink":"http://ligangit.com/2019/07/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}